This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/CLAUDE.md
.claude/settings.json
.cursorrules
.gitignore
configTemplate.txt
docs/ARCHITECTURE_API.md
docs/ARCHITECTURE_AUTH.md
docs/ARCHITECTURE_ROUTING.md
docs/ARCHITECTURE_SESSION.md
docs/ARCHITECTURE_SOCKET.md
docs/ARCHITECTURE_SYNC.md
docs/DEVELOPER_GUIDE.md
docs/HOSTING.md
envTemplate.txt
eslint.config.js
index.html
next plan.txt
package.json
postcss.config.mjs
prisma/schema.prisma
PROJECT_CONTEXT.md
public/apple.png
public/discord.png
public/facebook.png
public/favicon.ico
public/github.png
public/google.png
public/instagram.png
public/linkedIn.png
public/x.png
README.md
redis.conf
scripts/bundleServer.ts
scripts/clearServerRequests.ts
scripts/generateServerRequests.ts
server/auth/checkOrigin.ts
server/auth/login.ts
server/auth/loginConfig.ts
server/dev/hotReload.ts
server/dev/loader.ts
server/dev/request.py
server/dev/templateInjector.ts
server/dev/templates/api.template.ts
server/dev/templates/sync_client_paired.template.ts
server/dev/templates/sync_client_standalone.template.ts
server/dev/templates/sync_client.template.ts
server/dev/templates/sync_server.template.ts
server/dev/typeMapGenerator.ts
server/functions/boardcaster.ts
server/functions/db.ts
server/functions/game.ts
server/functions/redis.ts
server/functions/session.ts
server/functions/sleep.ts
server/functions/tryCatch.ts
server/prod/generatedApis.ts
server/prod/serveFile.ts
server/server.ts
server/sockets/handleApiRequest.ts
server/sockets/handleHttpApiRequest.ts
server/sockets/handleSyncRequest.ts
server/sockets/socket.ts
server/sockets/utils/activityBroadcaster.ts
server/sockets/utils/logout.ts
server/sockets/utils/onLocationChange.ts
server/utils/console.log.ts
server/utils/extractToken.ts
server/utils/extractTokenFromRequest.ts
server/utils/getParams.ts
server/utils/httpApiUtils.ts
server/utils/rateLimiter.ts
server/utils/repl.ts
server/utils/sentry.ts
server/utils/serveAvatars.ts
server/utils/validateRequest.ts
src/_api/logout.ts
src/_api/session.ts
src/_components/Avatar.tsx
src/_components/AvatarProvider.tsx
src/_components/ConfirmMenu.tsx
src/_components/ErrorPage.tsx
src/_components/Icon.tsx
src/_components/LocationProvider.tsx
src/_components/LoginForm.tsx
src/_components/MenuHandler.tsx
src/_components/Middleware.tsx
src/_components/Navbar.tsx
src/_components/Router.tsx
src/_components/TemplateProvider.tsx
src/_components/ThemeToggler.tsx
src/_components/TranslationProvider.tsx
src/_functions/confetti.ts
src/_functions/icon.ts
src/_functions/menuHandler.ts
src/_functions/middlewareHandler.ts
src/_functions/notify.ts
src/_functions/sentry.ts
src/_functions/sleep.ts
src/_functions/translator.ts
src/_functions/tryCatch.ts
src/_locales/de.json
src/_locales/en.json
src/_locales/fr.json
src/_locales/nl.json
src/_providers/SessionProvider.tsx
src/_providers/socketStatusProvider.tsx
src/_sockets/apiRequest.ts
src/_sockets/offlineQueue.ts
src/_sockets/socketInitializer.ts
src/_sockets/syncRequest.ts
src/admin/page.tsx
src/docs/_api/getDocs.ts
src/docs/page.tsx
src/examples/_api/adminOnly.ts
src/examples/_api/publicApi.ts
src/examples/_api/toggleAdmin.ts
src/examples/_sync/updateCounter_client.ts
src/examples/_sync/updateCounter_server.ts
src/examples/page.tsx
src/index.css
src/login/page.tsx
src/main.tsx
src/page.tsx
src/register/page.tsx
src/scrollbar-dark.css
src/scrollbar-white.css
src/settings/_api/updateUser.ts
src/settings/page.tsx
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.server.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/_api/logout.ts">
import { AuthProps, SessionLayout } from '../../config';
import { Functions, ApiResponse } from '../_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: false,
};

// Mark as DELETE method for HTTP requests
export const httpMethod = 'DELETE' as const;

export interface ApiParams {
  data: {};
  user: SessionLayout | null;
  functions: Functions;
}

export const main = async (_params: ApiParams): Promise<ApiResponse> => {
  // We dont actually do anything here, logout is handled in handleApiRequest
  // We still define the api route so our type system knows about it
  return {
    status: 'success',
    result: true
  };
};
</file>

<file path="src/_api/session.ts">
import { AuthProps, SessionLayout } from '../../config';
import { Functions, ApiResponse } from '../_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: false
};

export interface ApiParams {
  data: {};
  user: SessionLayout | null;
  functions: Functions;
}

export const main = async ({ user }: ApiParams): Promise<ApiResponse> => {
  return {
    status: 'success',
    result: user
  };
};
</file>

<file path=".claude/settings.json">
{
  "permissions": {
    "allow": [],
    "deny": []
  }
}
</file>

<file path="docs/ARCHITECTURE_ROUTING.md">
# Routing Architecture

> File-based routing for pages, APIs, and real-time sync events.

---

## Overview

LuckyStack uses file-based routing inspired by Next.js. There are three types of routes:

1. **Page routes** - React components that render at URL paths
2. **API routes** - Server-side functions callable via WebSocket or HTTP
3. **Sync routes** - Real-time event handlers for room-based broadcasting

All three follow the same convention: place files in the correct folder structure and they are automatically registered.

---

## Page Routing

### How It Works

`src/main.tsx` uses Vite's `import.meta.glob` to scan all `.tsx` files at build time. It finds files named `page.tsx` in non-underscore folders and registers them as routes with React Router.

### File Convention

```
src/{page}/page.tsx  -->  renders at /{page}
src/page.tsx         -->  renders at /
```

### Rules

- Only files named `page.tsx` become routes
- Folders starting with `_` are skipped (private folders for components, utilities, etc.)
- Each page can export a `template` constant to control its layout wrapper
- If no template is exported, defaults to `'plain'`

### Templates

```typescript
// src/settings/page.tsx
export const template = 'home';

export default function SettingsPage() {
  return <div>...</div>;
}
```

Available templates:

| Template    | Description                                                         |
| ----------- | ------------------------------------------------------------------- |
| `plain`     | Minimal wrapper, no UI chrome. Sets theme to `config.defaultTheme`. |
| `home`      | Top bar with user avatar, settings/home toggle, and logout button.  |
| `dashboard` | Side navigation bar with main content area.                         |

Both `home` and `dashboard` templates include `Middleware` for route authentication guards.

### Route Resolution Logic

From `main.tsx`:

1. Scan all `.tsx` files via `import.meta.glob('./**/*.tsx', { eager: true })`
2. For each file, split the path into segments
3. Skip if any segment starts with `_`
4. Check if the file ends with `page.tsx`
5. Extract the route path by removing `page` suffix
6. Register as a child route of the root `'/'` path

---

## API Routing

### File Convention

```
src/{page}/_api/{name}.ts  -->  accessible as api/{page}/{name}
```

### How It Works

**Development:** The server's `dev/loader.ts` scans `src/` recursively for folders ending in `api` (case-insensitive). For each `.ts` file found, it dynamically imports the module and registers it with the key `api/{page}/{name}`.

**Production:** The `scripts/generateServerRequests.ts` build script statically generates a route map that's bundled into `server/prod/generatedApis.ts`.

### Name Resolution

The API name sent from the client is automatically constructed from the current page path:

```
Client at /examples calls apiRequest({ name: 'publicApi' })
  --> fullname = "api/examples/publicApi"
  --> matches src/examples/_api/publicApi.ts
```

For nested pages:

```
Client at /games/chess calls apiRequest({ name: 'getGameState' })
  --> fullname = "api/games/chess/getGameState"
  --> matches src/games/chess/_api/getGameState.ts
```

### Required Exports

Each API file must export:

```typescript
// Required
export const main = async ({
  data,
  user,
  functions,
}: ApiParams): Promise<ApiResponse> => {
  return {
    status: "success",
    result: {
      /* ... */
    },
  };
};

// Required
export const auth: AuthProps = {
  login: true, // Require authentication
  additional: [], // Extra checks (e.g., admin role)
};

// Required for type generation
export interface ApiParams {
  data: {
    /* typed input from client */
  };
  user: SessionLayout;
  functions: Functions;
}

// Optional
export const rateLimit: number | false = 60; // Requests per minute (false = use global config)
export const httpMethod: "GET" | "POST" | "PUT" | "DELETE" = "POST"; // Override HTTP method inference
```

### WebSocket Access

The primary way to call APIs. The client sends a socket event and gets a response:

```typescript
// Client
const result = await apiRequest({
  name: "getUserData",
  data: { userId: "123" },
});
```

Flow:

1. Client emits `apiRequest` event with `{ name, data, responseIndex }`
2. Server looks up handler in `devApis` (dev) or `apis` (prod)
3. Validates auth requirements
4. Checks rate limits
5. Executes `main()` function
6. Emits response on `apiResponse-{responseIndex}`

### HTTP Access

All APIs are also accessible via HTTP for testing, webhooks, or non-socket clients:

```
GET    /api/{page}/{name}?key=value
POST   /api/{page}/{name}  with JSON body
PUT    /api/{page}/{name}  with JSON body
DELETE /api/{page}/{name}
```

HTTP method is either explicitly exported from the API file or inferred from the name:

| Name Prefix                  | Inferred Method |
| ---------------------------- | --------------- |
| `get*`, `fetch*`, `list*`    | GET             |
| `delete*`, `remove*`         | DELETE          |
| `update*`, `edit*`, `patch*` | PUT             |
| Everything else              | POST            |

Authentication via HTTP: include token as cookie (`token=...`) or `Authorization: Bearer ...` header.

### Built-In APIs

Two APIs are handled internally without files:

| Name      | Purpose                          |
| --------- | -------------------------------- |
| `session` | Returns the current user session |
| `logout`  | Logs out the user                |

### Type Generation

Types are automatically generated by `server/dev/typeMapGenerator.ts`:

1. Watches `_api/` folders for file changes
2. Extracts `ApiParams` interface and `main` return type from each file
3. Generates `src/_sockets/apiTypes.generated.ts`
4. Provides full autocomplete for API names, input data, and output types

---

## Sync Routing

### File Convention

```
src/{page}/_sync/{name}_server.ts  -->  Server-side validation (runs once)
src/{page}/_sync/{name}_client.ts  -->  Client-side handler (runs per client in room)
```

At least one of the two files must exist. Both are optional individually.

### How It Works

**Development:** The server's `dev/loader.ts` scans for folders ending in `sync`. For each `_server.ts` or `_client.ts` file, it registers with key `sync/{page}/{name}_server` or `sync/{page}/{name}_client`.

**Production:** Same build script generates static route maps.

### Name Resolution

Similar to APIs, the sync name is prefixed with the current page path:

```
Client at /examples calls syncRequest({ name: 'updateCounter', ... })
  --> fullname = "sync/examples/updateCounter"
  --> server looks for sync/examples/updateCounter_server and sync/examples/updateCounter_client
```

### Sync Flow

```
1. Client A sends syncRequest({ name, data, receiver: roomCode })
   |
2. Server validates message format
   |
3. If _server.ts exists:
   |  a. Check auth requirements
   |  b. Run main() for validation/DB operations
   |  c. Get serverOutput
   |
4. Get all sockets in the target room
   |
5. For each socket in room:
   |  a. Get that user's session
   |  b. If ignoreSelf and it's the sender, skip
   |  c. If _client.ts exists:
   |     - Run main() with { clientInput, serverOutput, user, functions, roomCode }
   |     - If returns { status: 'error' }, skip this client
   |     - If returns { status: 'success' }, emit to this client
   |  d. If no _client.ts, emit serverOutput directly
   |
6. Confirm success back to sender via sync-{responseIndex}
```

### Required Exports

**Server file (`_server.ts`):**

```typescript
export const auth: AuthProps = { login: true, additional: [] };

export interface SyncParams {
  clientInput: {
    /* data from sender */
  };
  user: SessionLayout;
  functions: Functions;
  roomCode: string;
}

export const main = async ({
  clientInput,
  user,
  functions,
  roomCode,
}: SyncParams): Promise<SyncServerResponse> => {
  // Validate and transform data
  return { status: "success" /* additional data for clients */ };
};
```

**Client file (`_client.ts`):**

```typescript
export interface SyncParams {
  clientInput: SyncClientInput<PagePath, SyncName>;
  serverOutput: SyncServerOutput<PagePath, SyncName>;
  user: SessionLayout;
  functions: Functions;
  roomCode: string;
}

export const main = async ({
  clientInput,
  serverOutput,
  user,
  functions,
  roomCode,
}: SyncParams): Promise<SyncClientResponse> => {
  // Filter: return error to skip this client, success to deliver
  return { status: "success" /* additional client-specific data */ };
};
```

### Receiving Sync Events

On the client, register callbacks to handle incoming sync events:

```typescript
const { upsertSyncEventCallback } = useSyncEvents();

upsertSyncEventCallback("updateCounter", ({ clientOutput, serverOutput }) => {
  // clientOutput = return from _client.ts (success only)
  // serverOutput = return from _server.ts
});
```

### Data Flow Types

| Type           | Source                | Description                                           |
| -------------- | --------------------- | ----------------------------------------------------- |
| `clientInput`  | Sender's `data` param | Original data passed to `syncRequest({ data: ... })`  |
| `serverOutput` | `_server.ts` return   | Data returned from server-side handler                |
| `clientOutput` | `_client.ts` return   | Data returned from client-side handler (success only) |

---

## Private Folders

Any folder prefixed with `_` is private and excluded from routing:

| Folder         | Purpose                                  |
| -------------- | ---------------------------------------- |
| `_api/`        | API handlers (registered separately)     |
| `_sync/`       | Sync handlers (registered separately)    |
| `_components/` | Page-specific or shared React components |
| `_functions/`  | Utility functions                        |
| `_providers/`  | React context providers                  |
| `_sockets/`    | Socket.io client utilities               |
| `_locales/`    | i18n translation JSON files              |

---

## Hot Reload

In development mode, the server watches for file changes:

1. `server/dev/hotReload.ts` monitors `src/` for changes in `_api/` and `_sync/` folders
2. On change, `server/dev/loader.ts` re-imports the modified module
3. `server/dev/typeMapGenerator.ts` regenerates `apiTypes.generated.ts` with updated types
4. No server restart needed for API/sync changes
5. Vite HMR handles frontend component changes
</file>

<file path="docs/HOSTING.md">
# Hosting LuckyStack

This guide covers everything you need to deploy LuckyStack from development to production.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Development Setup](#development-setup)
3. [Production Build](#production-build)
4. [Deployment Options](#deployment-options)
   - [VPS with nginx](#vps-deployment-with-nginx)
   - [VPS with Caddy](#vps-deployment-with-caddy)
   - [Docker](#docker-deployment)
5. [Environment Variables Reference](#environment-variables-reference)
6. [Troubleshooting](#troubleshooting)

---

## Prerequisites

Before deploying LuckyStack, ensure you have:

| Requirement  | Version | Notes                                            |
| ------------ | ------- | ------------------------------------------------ |
| **Node.js**  | 18+     | LTS recommended                                  |
| **Redis**    | 6+      | Used for session storage                         |
| **Database** | -       | Your choice (see database section below)         |
| **npm**      | 9+      | Comes with Node.js                               |

### Database

LuckyStack uses **Prisma** as its ORM, which supports multiple database providers. Choose whichever fits your project:

| Provider       | Config Value   | Notes                                              |
| -------------- | -------------- | -------------------------------------------------- |
| **MongoDB**    | `mongodb`      | Currently active in `prisma/schema.prisma`         |
| **MySQL**      | `mysql`        | Uncomment in schema, update `DATABASE_URL`         |
| **PostgreSQL** | `postgresql`   | Uncomment in schema, update `DATABASE_URL`         |
| **SQLite**     | `sqlite`       | Uncomment in schema, no server needed (dev only)   |

To switch databases:
1. Open `prisma/schema.prisma`
2. Comment out the current `datasource db` block
3. Uncomment the one for your chosen provider
4. Adjust the `id` field syntax if switching between MongoDB and SQL (see comments in schema)
5. Update `DATABASE_URL` in `.env`
6. Run `npx prisma generate && npx prisma db push`

### Installing Redis

**Windows (WSL/Docker recommended):**
```bash
# Using Docker
docker run -d --name redis -p 6379:6379 redis:alpine

# Or download from https://github.com/microsoftarchive/redis/releases
```

**macOS:**
```bash
brew install redis
brew services start redis
```

**Linux (Ubuntu/Debian):**
```bash
sudo apt update
sudo apt install redis-server
sudo systemctl enable redis-server
sudo systemctl start redis-server
```

### Installing a Database

**MongoDB (if using MongoDB provider):**

Use [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) (free tier available) or install locally.

> Local MongoDB installations must be configured as a **Replica Set** to support transactions.

Docker:
```bash
docker run -d --name mongodb -p 27017:27017 mongo:latest --replSet rs0
docker exec -it mongodb mongosh --eval "rs.initiate()"
```

**MySQL (if using MySQL provider):**
```bash
# Docker
docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:latest

# Then set DATABASE_URL="mysql://root:password@localhost:3306/PROJECT_NAME"
```

**PostgreSQL (if using PostgreSQL provider):**
```bash
# Docker
docker run -d --name postgres -p 5432:5432 -e POSTGRES_PASSWORD=password postgres:latest

# Then set DATABASE_URL="postgresql://postgres:password@localhost:5432/PROJECT_NAME"
```

**SQLite (development only):**

No installation needed. Set the datasource in `prisma/schema.prisma` to:
```prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}
```

---

## Development Setup

### 1. Clone and Install

```bash
git clone https://github.com/ItsLucky23/LuckyStack-v2 <PROJECT_NAME>
cd PROJECT_NAME
npm install
```

### 2. Configure Environment

Copy the environment template:
```bash
cp envTemplate.txt .env
```

Edit `.env` with your settings. **Minimum required for development:**

```env
NODE_ENV=development
VITE_SESSION_BASED_TOKEN=true
SECURE=false
PROJECT_NAME=my_project

SERVER_IP=localhost
SERVER_PORT=80

DNS=http://localhost:5173

REDIS_HOST=127.0.0.1
REDIS_PORT=6379

DATABASE_URL="mongodb://localhost:27017/PROJECT_NAME"
```

> Adjust `DATABASE_URL` to match your chosen database provider.

### 3. Configure Application

Copy the config template:
```bash
cp configTemplate.txt config.ts
```

### 4. Initialize Database

```bash
npx prisma generate
npx prisma db push
```

### 5. Start Development Servers

**Terminal 1 - Backend:**
```bash
npm run server
```

**Terminal 2 - Frontend:**
```bash
npm run client
```

The app is now running at:
- Frontend: `http://localhost:5173`
- Backend: `http://localhost:80`

---

## Production Build

### 1. Build Everything

```bash
npm run build
```

This runs:
1. `tsx scripts/generateServerRequests.ts` - Generates API/Sync route maps
2. `tsc -b && vite build` - Builds the frontend to `dist/`
3. `tsx scripts/bundleServer.ts` - Bundles the server

### 2. Build Output

After building, you'll have:
```
dist/
├── server.js          # Bundled Node.js server
├── assets/            # Frontend JS/CSS bundles
├── index.html         # Frontend entry point
└── ...
```

### 3. Run Production

```bash
npm run prod
# or
node dist/server.js
```

---

## Deployment Options

### VPS Deployment with nginx

#### 1. Server Setup

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install Node.js 20.x
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs

# Install nginx
sudo apt install -y nginx

# Install Redis
sudo apt install -y redis-server
sudo systemctl enable redis-server

# Install PM2 for process management
sudo npm install -g pm2
```

> Install your chosen database separately (see database section above).

#### 2. Deploy Application

```bash
# Clone your repo
cd /var/www
git clone https://github.com/ItsLucky23/LuckyStack-v2 PROJECT_NAME
cd PROJECT_NAME

# Install dependencies
npm ci --production

# Build
npm run build

# Start with PM2
pm2 start dist/server.js --name PROJECT_NAME
pm2 save
pm2 startup
```

#### 3. Configure nginx

Create `/etc/nginx/sites-available/PROJECT_NAME`:

```nginx
server {
    listen 80;
    server_name your-domain.com;

    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;

    # SSL certificates (use Certbot for free certs)
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;

    # Proxy to Node.js server
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # WebSocket support (critical for Socket.io)
    location /socket.io/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

Enable the site:
```bash
sudo ln -s /etc/nginx/sites-available/PROJECT_NAME /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

#### 4. SSL with Certbot

```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d your-domain.com
```

#### 5. Production Environment

Update your `.env`:

```env
NODE_ENV=production
SECURE=true
SERVER_IP=127.0.0.1
SERVER_PORT=3000
DNS=https://your-domain.com

# Use production OAuth credentials
GOOGLE_CLIENT_ID=your_prod_id
GOOGLE_CLIENT_SECRET=your_prod_secret
# ... etc
```

---

### VPS Deployment with Caddy

Caddy automatically handles SSL certificates.

#### 1. Install Caddy

```bash
sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list
sudo apt update
sudo apt install caddy
```

#### 2. Configure Caddy

Edit `/etc/caddy/Caddyfile`:

```caddy
your-domain.com {
    reverse_proxy localhost:3000
}
```

```bash
sudo systemctl reload caddy
```

That's it! Caddy automatically provisions SSL.

---

### Docker Deployment

#### 1. Create Dockerfile

Create `Dockerfile` in project root:

```dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner

WORKDIR /app

# Copy built files
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
COPY --from=builder /app/prisma ./prisma

# Generate Prisma client
RUN npx prisma generate

EXPOSE 3000

ENV NODE_ENV=production
ENV SERVER_PORT=3000
ENV SERVER_IP=0.0.0.0

CMD ["node", "dist/server.js"]
```

#### 2. Create docker-compose.yml

The example below uses MongoDB. Replace the `mongo` service with your chosen database.

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - DATABASE_URL=mongodb://mongo:27017/PROJECT_NAME
    depends_on:
      - redis
      - mongo
    restart: unless-stopped

  redis:
    image: redis:alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # Replace with your chosen database
  mongo:
    image: mongo:latest
    volumes:
      - mongo_data:/data/db
    restart: unless-stopped

volumes:
  redis_data:
  mongo_data:
```

#### 3. Deploy

```bash
docker-compose up -d --build
```

---

## Environment Variables Reference

| Variable                   | Required | Default       | Description                              |
| -------------------------- | -------- | ------------- | ---------------------------------------- |
| `NODE_ENV`                 | Yes      | `development` | `development` or `production`            |
| `PROJECT_NAME`             | Yes      | -             | Unique name for Redis key prefixing      |
| `SERVER_IP`                | Yes      | `localhost`   | Server bind address                      |
| `SERVER_PORT`              | Yes      | `80`          | Server port                              |
| `DNS`                      | Yes      | -             | Public URL for OAuth redirects           |
| `SECURE`                   | Yes      | `false`       | Enable HTTPS cookies                     |
| `VITE_SESSION_BASED_TOKEN` | Yes      | `true`        | Token storage method                     |
| `REDIS_HOST`               | Yes      | `127.0.0.1`   | Redis server host                        |
| `REDIS_PORT`               | Yes      | `6379`        | Redis server port                        |
| `DATABASE_URL`             | Yes      | -             | Database connection string (any Prisma-supported DB) |
| `SENTRY_DSN`               | No       | -             | Sentry error tracking DSN               |
| `GOOGLE_CLIENT_ID`         | No       | -             | Google OAuth client ID                   |
| `GOOGLE_CLIENT_SECRET`     | No       | -             | Google OAuth client secret               |
| `GITHUB_CLIENT_ID`         | No       | -             | GitHub OAuth client ID                   |
| `GITHUB_CLIENT_SECRET`     | No       | -             | GitHub OAuth client secret               |
| `DISCORD_CLIENT_ID`        | No       | -             | Discord OAuth client ID                  |
| `DISCORD_CLIENT_SECRET`    | No       | -             | Discord OAuth client secret              |
| `FACEBOOK_CLIENT_ID`       | No       | -             | Facebook OAuth client ID                 |
| `FACEBOOK_CLIENT_SECRET`   | No       | -             | Facebook OAuth client secret             |

---

## Troubleshooting

### Socket.io Connection Fails

**Symptom:** Frontend can't connect to backend, WebSocket errors in console.

**Solutions:**
1. Ensure nginx/Caddy is configured for WebSocket upgrades
2. Check `DNS` env variable matches your actual domain
3. Verify `EXTERNAL_ORIGINS` includes your domain

### OAuth Redirect Fails

**Symptom:** Login redirects to wrong URL or fails silently.

**Solutions:**
1. Check OAuth callback URLs in provider dashboard match exactly:
   - Google: `https://your-domain.com/auth/callback/google`
   - GitHub: `https://your-domain.com/auth/callback/github`
   - etc.
2. Ensure `DNS` env variable is correctly set
3. Use production OAuth credentials (not DEV_ prefixed ones)

### Redis Connection Errors

**Symptom:** Server crashes with Redis connection refused.

**Solutions:**
1. Verify Redis is running: `redis-cli ping`
2. Check `REDIS_HOST` and `REDIS_PORT` are correct
3. If using Docker, ensure services are on same network

### Session Not Persisting

**Symptom:** User gets logged out on page refresh.

**Solutions:**
1. Check `SECURE=true` only if using HTTPS
2. Verify `VITE_SESSION_BASED_TOKEN` matches between client and server
3. Check Redis is properly storing data: `redis-cli keys "*"`

### Build Fails

**Symptom:** TypeScript or Vite build errors.

**Solutions:**
1. Ensure `config.ts` exists (copy from `configTemplate.txt`)
2. Run `npx prisma generate` before building
3. Check all dependencies installed: `rm -rf node_modules && npm install`

### Database Connection Issues

**Symptom:** Prisma errors on startup or API calls.

**Solutions:**
1. Verify `DATABASE_URL` in `.env` matches your database provider
2. Ensure only ONE `datasource db` block is uncommented in `prisma/schema.prisma`
3. Run `npx prisma generate` after changing providers
4. For MongoDB: ensure replica set is configured if using transactions

---

## Quick Reference

```bash
# Development
npm run client          # Start Vite dev server
npm run server          # Start Node.js server
npm run liveServer      # Start server with hot reload

# Production
npm run build           # Build everything
npm run prod            # Run production server

# Database
npx prisma generate     # Generate Prisma client
npx prisma db push      # Push schema to database
npx prisma studio       # Open database GUI
```
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- <script src="https://unpkg.com/react-scan/dist/auto.global.js"></script> -->
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div class="w-full h-svh m-0 p-0" id="root"></div>
    <div 
      class="w-full h-svh m-0 p-0 absolute top-0 pointer-events-none overflow-hidden" id="portalRoot"
      style="z-index: 999999999;"
    ></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="postcss.config.mjs">
export default {
    plugins: {
        "@tailwindcss/postcss": {},
    }
}
</file>

<file path="redis.conf">
appendonly yes          # Enable AOF persistence
appendfsync everysec    # Sync every write operation to disk every second
</file>

<file path="scripts/bundleServer.ts">
import { build } from "esbuild";
import { dependencies } from "../package.json";

const externalDeps = [
  ...Object.keys(dependencies || {}),
  // Native Node.js modules
  "fs", "path", "url", "os", "child_process", "crypto"
];

await build({
  entryPoints: ["server/server.ts"], // Adjust if entry is different
  outfile: "dist/server.js",         // Final bundled output
  bundle: true,
  platform: "node",
  target: "node22",                  // Match your runtime (Node 18, 20 etc.)
  format: "esm",                     // Your project uses "type": "module"
  sourcemap: true,
  external: externalDeps,
  logLevel: "info",
}).catch((e) => {
  console.error("Build failed:", e);
  process.exit(1);
});
</file>

<file path="scripts/clearServerRequests.ts">
//? used when running npm run dev
//? in dev mode we dont need the production apis and syncs so we clear them to avoid it erroring when e.g. changing file names

import fs from "fs";

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = { };\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };\n";
let functionsMap = "export const functions: Record<string, any> = { };";

const output = `${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
// console.log("✅ server/prod/generatedApis.ts Cleared");
</file>

<file path="scripts/generateServerRequests.ts">
import fs from "fs";
import path from "path";

const normalizePath = (p: string) => p.split(path.sep).join("/");

// Recursively walk dirs to collect _api and _sync files
const walkSrcFiles = (dir: string, results: string[] = []) => {
  const list = fs.readdirSync(dir);
  for (const file of list) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      walkSrcFiles(fullPath, results);
    } else if (file.endsWith(".ts") && (fullPath.includes("_api") || fullPath.includes("_sync"))) {
      // if (file.endsWith("_client.ts")) continue; // skip client stubs
      results.push(fullPath);
    }
  }
  return results;
};

// Collect server function files
const walkFunctionFiles = (dir: string) => {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir)
    .filter((file) => file.endsWith(".ts"))
    .map((file) => normalizePath(path.join(dir, file)));
};

// --------------------
// Collect files
// --------------------
const rawSrcFiles = walkSrcFiles("./src").map(normalizePath).sort();
const functionFiles = walkFunctionFiles("./server/functions").sort();

// --------------------
// Buckets
// --------------------
const apiImports: string[] = [];
const syncImports: string[] = [];
const functionImports: string[] = [];

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = {\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = {\n";
let functionsMap = "export const functions: Record<string, any> = {\n";

let apiCount = 0;
let syncCount = 0;
let fnCount = 0;

// --------------------
// Process API + Sync
// --------------------
rawSrcFiles.forEach((normalized) => {
  const importPath = "../../" + normalized.replace(/\.ts$/, "");

  // API
  if (normalized.includes("_api/")) {
    const varName = `api${apiCount++}`;
    apiImports.push(`import * as ${varName} from '${importPath}';`);

    // capture "games/boerZoektVrouw" and "getGameData"
    const match = normalized.match(/src\/(.+?)\/_api\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, apiName] = match;
    const routeKey = `api/${pagePath}/${apiName}`; // clean route-like key

    apiMap += `  "${routeKey}": {\n    auth: "auth" in ${varName} ? ${varName}.auth : {},\n    main: ${varName}.main,\n  },\n`;
  }

  // Sync
  if (normalized.includes("_sync/")) {
    const match = normalized.match(/src\/(.+?)\/_sync\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, syncName] = match;
    const routeKey = `sync/${pagePath}/${syncName}`;
  
    console.log(syncName)
    if (syncName.endsWith("_client")) {
      const varName = `syncClient${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": ${varName}.main,\n`;
    }
  
    if (syncName.endsWith("_server")) {
      const varName = `syncServer${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": { auth: "auth" in ${varName} ? ${varName}.auth : {}, main: ${varName}.main },\n`;
    }
  }
});

// --------------------
// Process Functions
// --------------------
functionFiles.forEach((filePath) => {
  const importPath = "../../" + filePath.replace(/\.ts$/, "");
  const varName = `fn${fnCount++}`;
  functionImports.push(`import * as ${varName} from '${importPath}';`);
  functionsMap += `  ...${varName},\n`;
});

// --------------------
// Close Maps
// --------------------
apiMap += "};\n";
syncMap += "};\n";
functionsMap += "};";

// --------------------
// Final Output
// --------------------
const importStatements = [
  ...apiImports,
  "",
  ...syncImports,
  "",
  ...functionImports,
].join("\n");

const output = `${importStatements}\n\n${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
console.log("✅ server/prod/generatedApis.ts created");
</file>

<file path="server/auth/checkOrigin.ts">
const allowedOrigin = (origin: string) => {
  const location = `http${process.env.SECURE == 'true'?'s' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}/`;
  const formattedOrigin = origin.includes('://') ? origin : `http${process.env.SECURE == 'true' ? 's' : ''}://${origin}/`;
    
  //? we check if the origin of the user is allowed to access the server directly
  if (location == formattedOrigin) { return true; } 
  if (origin == 'localhost') { return true; }

  //? if the origin is not allowed we check if the origin is allowed we port 80 or port 443 cause the browser removes these sometimes

  const externalOrigins = process.env.EXTERNAL_ORIGINS?.split(',') || [];
  for (const externalOrigin of externalOrigins) {
    if (origin == externalOrigin) { return true; }
    if (origin == externalOrigin+'/') { return true; }
  }

  if (origin == process.env.DNS) { return true; }
  if (origin == process.env.DNS+'/') { return true; }
  if (!origin.startsWith('http://') && !origin.startsWith('https://')) {
    // origin = 'https://' + origin;
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}`) { return true; }
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}/`) { return true; }
  }

  console.log('')
  console.log('origin not allowed')
  console.log('origin:', origin)
  console.log('formattedOrigin:', formattedOrigin)
  console.log('dns:', process.env.DNS)
  console.log('dns:', process.env.DNS+'/')
  for (const externalOrigin of externalOrigins) {
    console.log('externalOrigin:', externalOrigin)
    console.log('externalOrigin:', externalOrigin+'/')
  }
  return false;
}

export default allowedOrigin;
</file>

<file path="server/auth/login.ts">
import dotenv from 'dotenv';
import oauthProviders from "./loginConfig";
import { IncomingMessage, ServerResponse } from 'http';
import { URLSearchParams } from 'url';
import { tryCatch } from '../functions/tryCatch';
import { prisma } from '../functions/db';
import { Prisma, PROVIDERS } from '@prisma/client';
import bcrypt from 'bcrypt';
import { randomBytes } from 'crypto';
import { saveSession } from "../functions/session"
import validator from "validator"
import config, { SessionLayout } from '../../config';
import path from 'path';
import { existsSync } from 'fs';

dotenv.config();

type paramsType = {
  email?: string,
  password?: string,
  name?: string,
  confirmPassword?: string,
}

const uploadsFolder = path.join(process.cwd(), "uploads");

// Route that starts the OAuth flow for the specified provider and redirects to the callback endpoint
const loginWithCredentials = async (params: paramsType) => {

  const email = validator.escape(params.email || '');
  const password = validator.escape(params.password || '');
  const name = params.name ? validator.escape(params.name) : undefined;
  const confirmPassword = params. confirmPassword ? validator.escape(params.confirmPassword) : undefined;

  console.log(name, email, password, confirmPassword)
  
  if (!email || !password) { return { status: false, reason: 'login.empty' }; }
  if (email.length > 191) { return { status: false, reason: 'login.emailCharacterLimit' }; }
  if (password.length < 8) { return { status: false, reason: 'login.passwordCharacterMinimum' }; }
  if (password.length > 191) { return { status: false, reason: 'login.passwordCharacterLimit' }; }
  if (name && name.length > 191) { return { status: false, reason: 'login.nameCharacterLimit' }; }
  if (!validator.isEmail(email)) { return { status: false, reason: 'login.invalidEmailFormat' }; }

  if (name && confirmPassword) { //? register
    if (password != confirmPassword) { return { status: false, reason: 'login.passwordNotMatch' }; }

    const checkEmail = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        },
      })
    }

    //? check if email already exists
    const [checkEmailError, checkEmailResponse] = await tryCatch(checkEmail);
    if (checkEmailError) { 
      console.log(checkEmailError);
      return { status: false, reason: checkEmailError }; 
    }
    if (checkEmailResponse) { return { status: false, reason: 'login.emailExist' }; }

    //? email is not in use so we define the function to create the new user
    const createNewUser = async () => {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      return await prisma.user.create({
        data: {
          email: email,
          provider: PROVIDERS.credentials,
          name: name,
          password: hashedPassword,
          avatar: '',
          admin: false,
          language: config.defaultLanguage
        }
      }) 
    }

    //? here we create the new user
    const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
    if (createNewUserError) { return { status: false, reason: createNewUserError }; }
    if (createNewUserResponse) { return { status: true, reason: 'login.userCreated', session: createNewUserResponse }; }
    return { status: false, reason: 'login.createUserFailed' };

  } else { //? login
    //? here we define the function to find the user
    const findUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        }
      }) 
    }

    //? attempt to find the user
    const [findUserError, findUserResponse] = await tryCatch(findUser);
    if (findUserError) { 
      console.log(findUserError, ' findUserError');
      return { status: false, reason: findUserError }; 
    }
    if (!findUserResponse) { return { status: false, reason: 'login.userNotFound' }; }

    //? if we found a user we check if the password matches the hashed one in the db
    const checkPassword = async () => { return await bcrypt.compare(password, findUserResponse.password as string); }
    const [checkPasswordError, checkPasswordResponse] = await tryCatch(checkPassword);
    if (checkPasswordError) { 
      console.log(checkPasswordError, ' checkPasswordError');
      return { status: false, reason: checkPasswordError }; 
    }
    if (!checkPasswordResponse) { return { status: false, reason: 'login.wrongPassword' }; }

    //? if the password matches we return the user
    if (checkPasswordResponse) {
      const newToken = randomBytes(32).toString("hex")
      const newUser = { 
        id: findUserResponse.id,
        name: findUserResponse.name,
        provider: 'credentials',
        email: findUserResponse.email,
        createdAt: findUserResponse.createdAt,
        updatedAt: findUserResponse.updatedAt,
        token: newToken,
        avatar: findUserResponse.avatar || '',
        avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        admin: findUserResponse.admin,
        language: findUserResponse.language,
        theme: findUserResponse.theme
      };

      const filePath = path.join(uploadsFolder, `${newUser.id}.webp`);
      if (existsSync(filePath)) {
        newUser.avatar = `${newUser.id}.webp`;
      }

      await saveSession(newToken, newUser, true);
      console.log(newUser);
      return { status: true, reason: 'login.loggedIn', newToken, session: newUser };
    }
  }
}

// Route that handles the callback from the OAuth provider
const loginCallback = async (pathname: string, req: IncomingMessage, res: ServerResponse) => {
  //? check if provider exists
  const providerName = pathname.split('/')[3]; // Extract the provider (google/github)
  const provider = oauthProviders.find(p => p.name === providerName);
  if (!provider || !req.url) { return false }
  if (!('clientID' in provider)) { return }

  const queryString = req.url.split('?')[1]; // Get the part after '?'
  const params = new URLSearchParams(queryString);
  const code = params.get('code');

  //? if no code provided in the url we return false (the code is used to get the access token and should be provided by the oauth provider)
  if (!code || code == '') { 
    console.log('no code provided in callback url')
    return false 
  }

  const values = {
    code,
    client_id: provider.clientID,
    client_secret: provider.clientSecret,
    redirect_uri: provider.callbackURL,
    grant_type: 'authorization_code'
  }

  //? with the code we can get the access token
  const getToken = async () => {
    if (provider.tokenExchangeMethod == 'json') {
      const url = provider.tokenExchangeURL;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(values),
      })
      return await response.json();
    } else if (provider.tokenExchangeMethod == 'form') {
      const url = provider.tokenExchangeURL;
      const params = new URLSearchParams();
      params.append('client_id', provider.clientID);
      params.append('client_secret', provider.clientSecret);
      params.append('code', values.code);
      params.append('grant_type', 'authorization_code');
      params.append('redirect_uri', provider.callbackURL);
    
      console.log(params)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body: params.toString()
      });
    
      return await response.json();
    }
  }

  const [getTokenError, getTokenResponse] = await tryCatch(getToken)
  if (getTokenError) {
    console.log(getTokenError, 'getTokenError');
    return false;
  }

  //? here we get the access token
  const { access_token, id_token } = getTokenResponse;
  const getUserData = async () => {
    // const url = `${provider.userInfoURL}?alt=json&access_token=${access_token}`;
    const url = provider.userInfoURL;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${access_token}`
      },
    })
    return await response.json();
  }

  //? with the access_token token we get the user data 
  const [getUserDataError, getUserDataResponse] = await tryCatch(getUserData);
  if (getUserDataError) {
    console.log(getUserDataError);
    return false;
  }

  const name: string = getUserDataResponse[provider.nameKey] || 'didnt find a name'

  let email: string | undefined = getUserDataResponse[provider.emailKey];
  const avatar: string = 
    provider?.avatarKey ? getUserDataResponse[provider.avatarKey] : 
    provider.getAvatar ? provider.getAvatar({userData: getUserDataResponse, avatarId: getUserDataResponse[provider.avatarCodeKey]}) : '';

  console.log(avatar)
  // const user = {
  //   id: '',
  //   name,
  //   provider: provider.name,
  //   email,
  //   createdAt: new Date(),
  //   updatedAt: new Date(),
  //   token: '',
  //   avatar,
  //   admin: false,
  //   language: config.defaultLanguage
  // }

  //? if we didnt find the email we try to get it with a external link if this one is provided
  if (!email && provider.getEmail) {
    const selectedEmail = await provider.getEmail(access_token);
    
    if (!selectedEmail) {
      console.log('no email found');
      return false; 
    }

    email = selectedEmail;
  }

  let tempUser: SessionLayout | undefined;
  if (email) {
    const fetchUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: provider.name as PROVIDERS
        }
      })
    } 

    //? here we check if the user exists in the db
    const [userDataError, userDataResponse] = await tryCatch(fetchUser);
    if (userDataError) {
      console.log(userDataError);
      return false;
    }

    console.log('ASDSADASDDASDA')
    //? if the user exists we assign it to the tempUser variable
    if (userDataResponse?.id) { 
      const { password, ...safeData } = userDataResponse;
      const filePath = path.join(uploadsFolder, `${safeData.id}.webp`);
      if (existsSync(filePath)) {
        safeData.avatar = `${safeData.id}.webp`;
      }

      tempUser = {
        ...safeData, 
        avatarFallback: 
        `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        token: '' 
      }; 
    }

    //? if the user doesnt exist we create a new one
    if (!tempUser) {
      const createNewUser = async () => {
        if (!email) { return false; }
        return await prisma.user.create({
          data: {
            email,
            provider: provider.name as PROVIDERS,
            name,
            avatar,
            language: config.defaultLanguage
          }
        })
      }
      const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
      if (createNewUserError) {
        console.log(createNewUserError);
        return false;
      }

      if (createNewUserResponse) { 
        const { password,...safeData } = createNewUserResponse;
        tempUser = {
          ...safeData, 
          avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
          token: ''
        }; 
      }
    }
  }

  if (!tempUser) {
    return false;
  }

  //? here we create a new token, create the users session and return the token as a sign of success
  const newToken = randomBytes(32).toString("hex")
  // user.id = tempUser.id;
  // user.createdAt = tempUser.createdAt;
  // user.updatedAt = tempUser.updatedAt;
  // user.token = newToken;
  // user.admin = tempUser.admin
  // user.language = config.defaultLanguage;
  // if (tempUser.avatar) { user.avatar = tempUser.avatar; }


  tempUser.token = newToken;
  await saveSession(newToken, tempUser, true);
  console.log(tempUser)
  return newToken;
}

export { loginWithCredentials, loginCallback }
</file>

<file path="server/auth/loginConfig.ts">
import dotenv from 'dotenv';
import { tryCatch } from '../functions/tryCatch';

dotenv.config(); // Load environment variables from .env file

interface BasicProvider {
  name: string;
}

interface FullProvider {
  name: string,
  clientID: string,
  clientSecret: string,
  callbackURL: string,
  authorizationURL: string,
  tokenExchangeURL: string,
  tokenExchangeMethod: 'json' | 'form',
  userInfoURL: string,
  scope: string[],
  getEmail?: (access_token: string) => Promise<string | false | undefined>,
  nameKey: string,
  emailKey: string, 

  avatarKey?: string, //? the avatarKey represent the url to the img
  avatarCodeKey: string, //? the avatarCodeKey should be the key representing the avatar id if the provider doesnt give the avatar url directly, we use the getAvatar function with this value together
  getAvatar?: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => any
}

type oauthProvidersProps = | BasicProvider | (Required<FullProvider>); 

// const backendUrl = `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`;
const prod = process.env.NODE_ENV !== 'development';
const backendUrl = process.env.NODE_ENV == 'development' 
  ? `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`
  : process.env.DNS
  
const oauthProviders: oauthProvidersProps[] = [
  {
    name: 'credentials',
  },
  {
    name: 'google',
    clientID: prod ?  process.env.GOOGLE_CLIENT_ID : process.env.DEV_GOOGLE_CLIENT_ID,
    clientSecret: prod ?  process.env.GOOGLE_CLIENT_SECRET : process.env.DEV_GOOGLE_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/google`,
    authorizationURL: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenExchangeURL: 'https://oauth2.googleapis.com/token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://www.googleapis.com/oauth2/v1/userinfo',
    scope: [
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/userinfo.email"
    ],
    nameKey: 'name',
    emailKey: 'email',
    avatarKey: 'picture'
  },
  {
    name: 'github',
    clientID: prod ?  process.env.GITHUB_CLIENT_ID : process.env.DEV_GITHUB_CLIENT_ID,
    clientSecret: prod ?  process.env.GITHUB_CLIENT_SECRET : process.env.DEV_GITHUB_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/github`,
    authorizationURL: 'https://github.com/login/oauth/authorize',
    tokenExchangeURL: 'https://github.com/login/oauth/access_token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://api.github.com/user',
    scope: ['read:user', 'user:email'],
    nameKey: 'login',
    emailKey: 'email',
    avatarKey: 'avatar_url',
    getEmail: async (access_token: string) => {
      const getEmail = async () => {
        const url = 'https://api.github.com/user/emails';
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${access_token}`
          },
        })
        return await response.json(); 
      }
  
      const [getEmailError, getEmailResponse] = await tryCatch(getEmail);
      if (getEmailError) {
        console.log(getEmailError);
        return false;
      }
  
      //? if we found the email we set it to the user object
      let mainEmail: string | undefined;
      for (const email of getEmailResponse) {
        if (email.primary) { mainEmail = email.email; }
      }
      if (!mainEmail) { mainEmail = getEmailResponse?.[0]?.email; }
      return mainEmail;
    },
  },
  {
    name: 'discord',
    clientID: prod ?  process.env.DISCORD_CLIENT_ID : process.env.DEV_DISCORD_CLIENT_ID,
    clientSecret: prod ?  process.env.DISCORD_CLIENT_SECRET : process.env.DEV_DISCORD_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/discord`,
    authorizationURL: 'https://discord.com/oauth2/authorize',
    tokenExchangeURL: 'https://discord.com/api/oauth2/token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://discord.com/api/users/@me',
    scope: [
      "identify",
      'email',
    ],
    nameKey: 'username',
    emailKey: 'email',
    avatarCodeKey: 'avatar',
    getAvatar: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => {
      if (!avatarId) {
        // Default avatar (based on discriminator % 5)
        // const defaultAvatarIndex = userId % 5;
        // return `https://cdn.discordapp.com/embed/avatars/${defaultAvatarIndex}.png`;
        return undefined;
      }
      const userId = userData.id;
      const format = avatarId.startsWith("a_") ? "gif" : "png";
      return `https://cdn.discordapp.com/avatars/${userId}/${avatarId}.${format}`;
    }
  },
  {
    name: 'facebook',
    clientID: prod ?  process.env.FACEBOOK_CLIENT_ID : process.env.DEV_FACEBOOK_CLIENT_ID,
    clientSecret: prod ?  process.env.FACEBOOK_CLIENT_SECRET : process.env.DEV_FACEBOOK_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/facebook`,
    authorizationURL: 'https://www.facebook.com/v10.0/dialog/oauth',
    tokenExchangeURL: 'https://graph.facebook.com/v10.0/oauth/access_token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://graph.facebook.com/me?fields=id,name,email,picture.type(large)',
    scope: ['public_profile', 'email'],
    nameKey: 'name',
    emailKey: 'email',
    getAvatar: ({userData}: {userData: Record<string, any>}) => {
      return userData?.picture?.data?.url || undefined;
    }
  },
];

export default oauthProviders;
</file>

<file path="server/dev/loader.ts">
import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";
import { tryCatch } from "../functions/tryCatch";

// ----------------------------
// Storage for loaded modules
// ----------------------------
export const devApis: Record<string, any> = {};
export const devSyncs: Record<string, any> = {};
export const devFunctions: Record<string, any> = {};

// ----------------------------
// Unified Initialization
// ----------------------------
export const initializeAll = async () => {
  await Promise.all([initializeApis(), initializeSyncs(), initializeFunctions()]);
  console.log(devApis)
  console.log(devSyncs)
  console.log("DEV modules initialized.");
  // console.log(devFunctions)
};

// ----------------------------
// Helper: convert absolute path to proper file URL for import
// ----------------------------
const importFile = async (absolutePath: string) => {
  const url = pathToFileURL(absolutePath).href;
  return import(`${url}?update=${Date.now()}`);
};

// ----------------------------
// API Loader
// ----------------------------
export const initializeApis = async () => {
  Object.keys(devApis).forEach(k => delete devApis[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanApiFolder(file);
  }
};

const scanApiFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("api")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith(".ts")) continue;

      const modulePath = path.join(fullPath, f);
      const [err, module] = await tryCatch(async () => importFile(modulePath));
      if (err) continue;

      const { auth = {}, main } = module;
      if (!main || typeof main !== "function") continue;

      // const pageLocation = modulePath.split(`/${file}/`)[0].replace(/^src[\/\\]/, "");
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split("/api")[0];

      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      devApis[`api/${pageLocation}/${f.replace(".ts", "")}`] = {
        main,
        auth: {
          login: auth.login || false,
          additional: auth.additional || [],
        },
      };
    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanApiFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Sync Loader
// ----------------------------
export const initializeSyncs = async () => {
  Object.keys(devSyncs).forEach(k => delete devSyncs[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanSyncFolder(file);
  }
};

const scanSyncFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("sync")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith("_client.ts") && !f.endsWith("_server.ts")) { continue; }

      const filePath = path.join(fullPath, f);
      const [fileError, fileResult] = await tryCatch(async () => importFile(filePath));

      if (fileError) { continue; }

      // build the route key similar to API routes
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split('/sync')[0];

      // remove last segment
      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      if (f.endsWith("_server.ts")) {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = { 
          main: fileResult.main, 
          auth: fileResult.auth || {} 
        };
      } else {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = fileResult.main;
      }

      // // optional _server.ts
      // const serverFile = f.replace("_client.ts", "_server.ts");
      // const serverPath = path.join(fullPath, serverFile);

      // if (fs.existsSync(serverPath)) {
      //   const [errServer, serverModule] = await tryCatch(async () => importFile(serverPath));
      //   if (!errServer && typeof serverModule.main === "function") {
      //     // final key style: sync/games/boerZoektVrouw/getCards
      //     devSyncs[`sync/${pageLocation}/${f.replace("_client.ts", "_server")}`] = { main: serverModule.main, auth: serverModule.auth || {} };
      //   }
      // }


    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanSyncFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Functions Loader
// ----------------------------
export const initializeFunctions = async () => {
  Object.keys(devFunctions).forEach(k => delete devFunctions[k]);
  const functionsFolder = fs.readdirSync(path.resolve("./server/functions"));

  for (const file of functionsFolder) {
    const filePath = path.join("./server/functions", file);
    if (!fs.statSync(filePath).isFile() || !file.endsWith(".ts")) continue;

    const [err, module] = await tryCatch(async () => importFile(filePath));
    if (err) continue;


    Object.assign(devFunctions, module);
  }
};
</file>

<file path="server/dev/request.py">
import requests

url = "http://192.168.178.68:80"
data = {"name": "mike", "age": 18}

response = requests.get(url, json=data)

print("Status Code:", response.status_code)
print("Response:", response.text)
</file>

<file path="server/functions/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="server/functions/game.ts">
import redis from "./redis";

export interface GameDataProps {
  players: { 
    id: string, 
    name: string, 
    avatar: string,
    role: 'farmer' | 'queen' | 'manipulator' | null,
    selected?: boolean
  }[],
  gameCode: string,
  queenRoles: number,
  manipulatorRoles: number,
  currentCountdownId: number,
  state: 'lobby' | 'loadingScreen' | 'started' | 'finished',
  loadingScreenState: 'roulette' | 'focusFarmer' | 'focusPersonalCard' | null;
  selectedRewards: { [key: string]: string[] },
  availableRewards: {
    name: string,
    id: string
  }[],
  lives: number,
  maxLives: number,
  gameStartTime: number | null,
  totalDrinkTime: number,
  won: 'farmer' | 'player' | 'none' | false,
  revealed: { 
    id: string, 
    role: 'queen' | 'manipulator'
  }[],
}


const saveGameData = async (gameCode: string, data: GameDataProps) => {
  // console.log(gameCode)
  // console.log(data)
  await redis.set(`${process.env.PROJECT_NAME}-games:${gameCode}`, JSON.stringify(data));
  await redis.expire(`${process.env.PROJECT_NAME}-games:${gameCode}`, 60 * 60 * 24 * 7); // same TTL as session or adjust
  return true;
};

const getGameData = async (gameCode: string) => {
  const data = await redis.get(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return data ? JSON.parse(data) as GameDataProps : null;
};

const getAllGameDatas = async () => {
  const allGameDatas = await redis.keys("*");
  const GameDatas = await Promise.all(allGameDatas.map((gameData) => redis.get(gameData)));
  return GameDatas.map((gameData) => JSON.parse(gameData || "{}")); 
}


const deleteGameData = async (gameCode: string) => {
  await redis.del(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return true;
};

const gameExists = async (gameCode: string): Promise<boolean> => {
  const exists = await redis.exists(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return exists === 1;
};

export { saveGameData, getGameData, getAllGameDatas, deleteGameData, gameExists  };
</file>

<file path="server/functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="server/prod/generatedApis.ts">
export const apis: Record<string, { auth: any, main: any }> = { };

export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };

export const functions: Record<string, any> = { };
</file>

<file path="server/prod/serveFile.ts">
import fs from "fs";
import { IncomingMessage, ServerResponse } from "http";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootFolder = path.join(__dirname, '../dist');

export const serveFavicon = (res: ServerResponse) => {
  //? here we get the favicon.ico file from the public folder and serve it to the client
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const faviconPath = path.join(__dirname, '../public', 'favicon.ico');
  res.writeHead(200, { 'Content-Type': 'image/x-icon' });
  fs.createReadStream(faviconPath).pipe(res); 
}

export const serveFile = async (req: IncomingMessage | { url: string }, res: ServerResponse) => {

  //? if request is / (root) we serve the index.html 
  const url = !req.url ? 'index.html' : req.url == '/' ? 'index.html' : req.url;
  const safePath = path.normalize(decodeURIComponent(url)).replace(/^(\.\.[\/\\])+/, '');
  let filePath = path.join(rootFolder, safePath);

  console.log(filePath)
  console.log(rootFolder)

  if (!filePath.startsWith(rootFolder)) {
    //! here we avoid directory traversal attacks
    res.writeHead(403, { "Content-Type": "text/plain" });
    return res.end("Forbidden");
  }

  //? here we check if the file extension or just the filename is in the list of files we dont want to serve
  //? a file that is in the list below should not be able to run this function in the first place cause we filter the routePath using zod before calling this function
  //? but if it passes somehow, we avoid it being served
  if (filePath.includes('.env') || 
      filePath.includes('.ts') || 
      filePath.includes('.tsx') || 
      filePath.includes('.py') || 
      filePath.includes('package.json') || 
      filePath.includes('package-lock.json') || 
      filePath.includes('.gitignore') || 
      filePath.includes('eslint.config.js') || 
      filePath.includes('postcss.config.mjs') || 
      filePath.includes('README.md') || 
      filePath.includes('redis.conf') || 
      filePath.includes('tailwind.config.js') || 
      filePath.includes('tsconfig.app.json') || 
      filePath.includes('tsconfig.json') || 
      filePath.includes('tsconfig.node.json') || 
      filePath.includes('vite.config.ts') || 
      filePath.includes('schema.prisma')
  ) {
    return res.end("Forbidden");
  }
  

  const extname = path.extname(filePath);
  let contentType = 'text/html';

  //? here we get the content type of the file and serve it to the client
  //? if the file extension is not in the list below, we serve the index.html file
  switch (extname) {
    case '.css': contentType = 'text/css'; break;
    case '.js': contentType = 'text/javascript'; break;
    case '.json': contentType = 'application/json'; break;
    case '.png': contentType = 'image/png'; break;
    case '.jpg':
    case '.jpeg': contentType = 'image/jpeg'; break;
    case '.gif': contentType = 'image/gif'; break;
    case '.svg': contentType = 'image/svg+xml'; break;
    case '.ico': contentType = 'image/x-icon'; break;
    default:
      contentType = 'text/html';
      filePath = path.join(rootFolder, 'index.html');
  }

  try {
    //? attempt to read the file and serve it to the client
    const content = await fs.promises.readFile(filePath);
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(content);
  } catch (err) {
    if (url == 'index.html') {
      res.end("-_- you have to run the 'npm run build' command first -_-")
    } else {
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("Not Found");
    }
  }
};
</file>

<file path="server/sockets/handleHttpApiRequest.ts">
import { tryCatch } from '../functions/tryCatch';
import { apis, functions } from '../prod/generatedApis';
import { devApis, devFunctions } from '../dev/loader';
import { getSession } from '../functions/session';
import config, { SessionLayout } from '../../config';
import { validateRequest } from '../utils/validateRequest';
import { captureException } from '../utils/sentry';
import { checkRateLimit } from '../utils/rateLimiter';
import { inferHttpMethod, HttpMethod } from '../utils/httpApiUtils';

/**
 * HTTP API Request Handler
 * 
 * Handles API requests coming via HTTP (instead of WebSocket).
 * Reuses existing API handlers but returns results as HTTP response.
 * 
 * Payload format:
 * ```json
 * {
 *   "name": "api/examples/publicApi",
 *   "data": { "message": "hello" }
 * }
 * ```
 * 
 * @example
 * ```typescript
 * // In server.ts
 * if (pathname.startsWith('/api/')) {
 *   const token = extractTokenFromRequest(req);
 *   const body = await parseJsonBody(req);
 *   const result = await handleHttpApiRequest({ name: body.name, data: body.data, token });
 *   res.end(JSON.stringify(result));
 * }
 * ```
 */

interface HttpApiRequestParams {
  name: string;
  data: Record<string, any>;
  token: string | null;
  /** HTTP method from the request */
  method?: HttpMethod;
}

interface ApiResponse {
  status: 'success' | 'error';
  result?: any;
  message?: string;
  /** HTTP status code to return (for error cases) */
  httpStatus?: number;
}

export async function handleHttpApiRequest({
  name,
  data,
  token,
  method = 'POST'
}: HttpApiRequestParams): Promise<ApiResponse> {

  // Validate request format
  if (!name || typeof name !== 'string') {
    return {
      status: 'error',
      message: 'Missing or invalid API name'
    };
  }

  if (data && typeof data !== 'object') {
    return {
      status: 'error',
      message: 'Data must be an object'
    };
  }

  const requestData = data || {};

  // Get user session
  const user = await getSession(token);

  console.log(`http api: ${name} called`, 'cyan');

  const apisObject = process.env.NODE_ENV === 'development' ? devApis : apis;

  // Check if API exists
  if (!apisObject[name]) {
    return {
      status: 'error',
      message: `API not found: ${name}`,
      httpStatus: 404
    };
  }

  const { auth, main, httpMethod: declaredMethod } = apisObject[name];

  // HTTP method validation
  const expectedMethod = declaredMethod ?? inferHttpMethod(name);
  if (method !== expectedMethod) {
    console.log(`Method mismatch for ${name}: expected ${expectedMethod}, got ${method}`, 'yellow');
    return {
      status: 'error',
      message: `Method not allowed. Use ${expectedMethod} for this endpoint.`,
      httpStatus: 405
    };
  }

  // Auth validation: check login requirement
  if (auth?.login) {
    if (!user?.id) {
      console.log(`ERROR: HTTP API ${name} requires login`, 'red');
      return {
        status: 'error',
        message: 'Authentication required'
      };
    }
  }

  // Auth validation: check additional requirements
  const authResult = validateRequest({ auth, user: user as SessionLayout });
  if (authResult.status === 'error') {
    console.log(`ERROR: Auth failed for HTTP API ${name}: ${authResult.message}`, 'red');
    return authResult as ApiResponse;
  }

  // Rate limiting check
  const apiRateLimit = apisObject[name].rateLimit;
  const effectiveLimit = apiRateLimit !== undefined
    ? apiRateLimit
    : config.rateLimiting.defaultApiLimit;

  if (effectiveLimit !== false && effectiveLimit > 0) {
    // For HTTP, we use token-based key or fall back to a generic "http" key
    const rateLimitKey = user?.id
      ? `user:${user.id}:api:${name}`
      : `http:api:${name}`;

    const { allowed, remaining, resetIn } = checkRateLimit({
      key: rateLimitKey,
      limit: effectiveLimit,
      windowMs: config.rateLimiting.windowMs
    });

    if (!allowed) {
      console.log(`Rate limit exceeded for HTTP API ${name}`, 'yellow');
      return {
        status: 'error',
        message: `Rate limit exceeded. Try again in ${resetIn} seconds.`
      };
    }
  }

  // Execute the API handler
  const functionsObject = process.env.NODE_ENV === 'development' ? devFunctions : functions;
  const [error, result] = await tryCatch(
    async () => await main({ data: requestData, user, functions: functionsObject })
  );

  if (error) {
    console.log(`ERROR in HTTP API ${name}:`, error, 'red');
    captureException(error, { api: name, userId: user?.id, source: 'http' });
    return {
      status: 'error',
      message: error.message || 'Internal server error'
    };
  }

  if (result) {
    console.log(`http api: ${name} completed`, 'cyan');

    // Check if result is already formatted as ApiResponse
    if (result && typeof result === 'object' && (result.status === 'success' || result.status === 'error')) {
      return result as ApiResponse;
    }

    // Wrap raw data in success response
    return { status: 'success', result };
  }

  console.log(`WARNING: HTTP API ${name} returned nothing`, 'yellow');
  return {
    status: 'error',
    message: 'API returned no result'
  };
}
</file>

<file path="server/sockets/utils/logout.ts">
import { Socket } from "socket.io";
import redis from "../../functions/redis";
import { tryCatch } from "../../functions/tryCatch";
import { disconnectTimers, tempDisconnectedSockets } from "./activityBroadcaster";
import { deleteSession } from "../../functions/session";
import { socketLeaveRoom } from "./activityBroadcaster";

export const logout = async ({ token, socket, userId }: {
  token: string | null,
  socket: Socket | undefined,
  userId: string | null,
}) => {
  const [error, result] = await tryCatch(async () => {
    if (!socket) { 
      console.log('Trying to logout but invalid socket', 'red');
      return;
    }
    if (!token) { 
      console.log('Trying to logout without a token', 'red');
      return;
    }
    
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    }

    if (disconnectTimers.has(token)) {
      const timer = disconnectTimers.get(token);
      if (timer) {
        clearTimeout(timer);
        disconnectTimers.delete(token);
      } 
    }

    console.log(`Logging out user with token: ${token}`, 'cyan');
    
    await socketLeaveRoom({ token, socket, newPath: null });
    await deleteSession(token);
    const tokensOfActiveUsers = `${process.env.PROJECT_NAME}-activeUsers:${userId}`
    await redis.srem(tokensOfActiveUsers, token);
    socket.leave(token);
    return true;
  });
  if (error) {
    if (socket) {
      socket.emit(`logout`, "error");
    }
  } else if (result) {
    if (socket) {
      socket.emit(`logout`, "success");
    }
  }
}
</file>

<file path="server/sockets/utils/onLocationChange.ts">

</file>

<file path="server/utils/console.log.ts">
const COLORS: Record<string, string> = {
  black: "\x1b[30m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  white: "\x1b[37m",
  reset: "\x1b[0m",
};

export const initConsolelog = () => {
  const originalLog = console.log;
  console.log = (...args: any[]) => {
    const stack = new Error().stack?.split("\n")[2]?.trim();
    if (!stack) return originalLog(...args);
  
    let lineInfo = stack.substring(stack.indexOf("(") + 1, stack.lastIndexOf(")"));
    if (lineInfo === "") lineInfo = stack;
    const extractedInfo = lineInfo
      .substring(lineInfo.lastIndexOf("\\") + 1)
      .replace(/:\d+$/, "");
  
    // find color keyword and remove it from args
    let colorCode = COLORS.white;
    for (const key of Object.keys(COLORS)) {
      const index = args.findIndex((a) => a === key);
      if (index !== -1) {
        colorCode = COLORS[key];
        args.splice(index, 1);
        break;
      }
    }
  
    // handle object vs text
    if (typeof args[0] === "object") {
      originalLog(`${colorCode}${extractedInfo}${COLORS.reset}`);
      originalLog(args);
    } else {
      originalLog(`${colorCode}${extractedInfo} -- ${args.join(" ")}${COLORS.reset}`);
    }
  };
}
</file>

<file path="server/utils/extractTokenFromRequest.ts">
import { IncomingMessage } from 'http';

/**
 * Extract the authentication token from an HTTP request.
 * 
 * Supports tokens from:
 * - `Authorization: Bearer <token>` header
 * - `token=<token>` cookie
 * 
 * @param req - The HTTP incoming message
 * @returns The token string or null if not found
 * 
 * @example
 * ```typescript
 * const token = extractTokenFromRequest(req);
 * const session = token ? await getSession(token) : null;
 * ```
 */
export const extractTokenFromRequest = (req: IncomingMessage): string | null => {
  // 1. Check Authorization header (Bearer token)
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.slice(7);
  }

  // 2. Check cookies
  const cookieHeader = req.headers.cookie;
  if (cookieHeader) {
    const tokenCookie = cookieHeader
      .split('; ')
      .find(row => row.startsWith('token='));

    if (tokenCookie) {
      return tokenCookie.split('=')[1] ?? null;
    }
  }

  return null;
};
</file>

<file path="server/utils/getParams.ts">
import { IncomingMessage, ServerResponse } from "http";
import { tryCatch } from "../functions/tryCatch";

type getParamsType = {
  method: string;
  req: IncomingMessage;
  res: ServerResponse;
  queryString?: string;
}

export default async function getParams({ method, req, res, queryString }: getParamsType): Promise<Record<string, any> | null> {

  if (method == "GET") {
    //? if get request we return the query string as an object
    return Object.fromEntries(new URLSearchParams(queryString || '')) as Record<string, string>;
  }

  //? if a POST, PUT or DELETE method we return the body as an object
  return new Promise((resolve, reject) => {
    const contentType = req.headers['content-type'] || '';

    //? we store the passed data chunks in a string
      let body = '';
      req.on('data', (chunk) => {
        body += chunk.toString();
      }); 

      req.on('end', async () => {
        //? here we parse the data depending on the content type
        //? if the content type is application/x-www-form-urlencoded we parse the data as a URLSearchParams object
        if (contentType.startsWith('application/x-www-form-urlencoded')) {
          const parseData = () => {
            const data = new URLSearchParams(body);
            return Object.fromEntries(data);
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        //? if the content type is application/json we parse the data as a JSON object
        if (contentType.startsWith('application/json')) {
          const parseData = () => {
            return JSON.parse(body || '{}');
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        resolve({ body });
      })

      req.on('error', (error) => {
        reject(error);
      })
    // }

  });
}
</file>

<file path="server/utils/httpApiUtils.ts">
/**
 * HTTP API Utilities
 * 
 * Helpers for HTTP API request handling including:
 * - Smart HTTP method detection based on API name
 * - Method validation
 */

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

/**
 * Infer the HTTP method from an API name based on common naming conventions.
 * 
 * - Names starting with "get" → GET
 * - Names starting with "delete" or "remove" → DELETE
 * - Names starting with "update" or "edit" → PUT
 * - Everything else → POST (create operations, actions)
 * 
 * @example
 * ```typescript
 * inferHttpMethod('getUserData')   // → 'GET'
 * inferHttpMethod('deleteAccount') // → 'DELETE'
 * inferHttpMethod('updateProfile') // → 'PUT'
 * inferHttpMethod('createUser')    // → 'POST'
 * inferHttpMethod('sendEmail')     // → 'POST'
 * ```
 */
export const inferHttpMethod = (apiName: string): HttpMethod => {
  // Extract the method name from the full path (e.g., "api/examples/getUserData" → "getUserData")
  const nameParts = apiName.split('/');
  const methodName = nameParts[nameParts.length - 1].toLowerCase();

  if (methodName.startsWith('get') || methodName.startsWith('fetch') || methodName.startsWith('list')) {
    return 'GET';
  }

  if (methodName.startsWith('delete') || methodName.startsWith('remove')) {
    return 'DELETE';
  }

  if (methodName.startsWith('update') || methodName.startsWith('edit') || methodName.startsWith('patch')) {
    return 'PUT';
  }

  // Default: POST for create operations and general actions
  return 'POST';
};

/**
 * Get the effective HTTP method for an API.
 * Uses explicit export if available, otherwise infers from name.
 */
export const getEffectiveHttpMethod = (
  apiConfig: { httpMethod?: HttpMethod },
  apiName: string
): HttpMethod => {
  return apiConfig.httpMethod ?? inferHttpMethod(apiName);
};

/**
 * Check if an HTTP method is valid for an API.
 * 
 * @param requestMethod - The method from the HTTP request
 * @param allowedMethod - The method the API accepts
 * @returns true if the method matches or if it's a preflight OPTIONS request
 */
export const isMethodAllowed = (
  requestMethod: string,
  allowedMethod: HttpMethod
): boolean => {
  return requestMethod === allowedMethod || requestMethod === 'OPTIONS';
};
</file>

<file path="server/utils/rateLimiter.ts">
/**
 * In-Memory Rate Limiter
 * 
 * Simple rate limiter using in-memory Map storage.
 * Suitable for single-server deployments.
 * 
 * Features:
 * - Per-key rate limiting (user ID, IP address, API name, etc.)
 * - Configurable window duration
 * - Automatic cleanup of expired entries
 * 
 * @example
 * ```typescript
 * // Check if request is allowed
 * const { allowed, remaining, resetIn } = checkRateLimit({
 *   key: `user:${userId}:api:${apiName}`,
 *   limit: 60,
 *   windowMs: 60000
 * });
 * 
 * if (!allowed) {
 *   return { status: 'error', message: `Rate limit exceeded. Try again in ${resetIn}s` };
 * }
 * ```
 */

interface RateLimitEntry {
  count: number;
  resetAt: number;
}

const rateLimitStore = new Map<string, RateLimitEntry>();

interface CheckRateLimitParams {
  /** Unique key for rate limiting (e.g., "user:123:api:getData") */
  key: string;
  /** Maximum requests allowed in window */
  limit: number;
  /** Time window in milliseconds (default: 60000 = 1 minute) */
  windowMs?: number;
}

interface RateLimitResult {
  /** Whether the request is allowed */
  allowed: boolean;
  /** Remaining requests in current window */
  remaining: number;
  /** Seconds until rate limit resets */
  resetIn: number;
}

/**
 * Check if a request is allowed under rate limiting rules.
 * Increments the counter for the key if allowed.
 */
export const checkRateLimit = ({
  key,
  limit,
  windowMs = 60000
}: CheckRateLimitParams): RateLimitResult => {
  const now = Date.now();
  const entry = rateLimitStore.get(key);

  // No entry or expired - create new window
  if (!entry || entry.resetAt < now) {
    rateLimitStore.set(key, {
      count: 1,
      resetAt: now + windowMs
    });
    return {
      allowed: true,
      remaining: limit - 1,
      resetIn: Math.ceil(windowMs / 1000)
    };
  }

  // Increment counter
  entry.count++;

  const resetIn = Math.ceil((entry.resetAt - now) / 1000);

  return {
    allowed: entry.count <= limit,
    remaining: Math.max(0, limit - entry.count),
    resetIn
  };
};

/**
 * Get current rate limit status without incrementing counter.
 * Useful for rate limit headers in responses.
 */
export const getRateLimitStatus = (key: string, limit: number): RateLimitResult => {
  const now = Date.now();
  const entry = rateLimitStore.get(key);

  if (!entry || entry.resetAt < now) {
    return { allowed: true, remaining: limit, resetIn: 0 };
  }

  return {
    allowed: entry.count < limit,
    remaining: Math.max(0, limit - entry.count),
    resetIn: Math.ceil((entry.resetAt - now) / 1000)
  };
};

/**
 * Clear rate limit for a specific key.
 * Useful for admin overrides or testing.
 */
export const clearRateLimit = (key: string): void => {
  rateLimitStore.delete(key);
};

/**
 * Clear all rate limits.
 * Useful for testing or server restart.
 */
export const clearAllRateLimits = (): void => {
  rateLimitStore.clear();
};

// Cleanup expired entries every minute
setInterval(() => {
  const now = Date.now();
  let cleaned = 0;
  for (const [key, entry] of rateLimitStore) {
    if (entry.resetAt < now) {
      rateLimitStore.delete(key);
      cleaned++;
    }
  }
  if (cleaned > 0) {
    console.log(`[RateLimiter] Cleaned ${cleaned} expired entries`, 'gray');
  }
}, 60000);
</file>

<file path="server/utils/repl.ts">
import { getAllGameDatas, getGameData, saveGameData } from "../functions/game"
import { deleteSession, getAllSessions, getSession } from "../functions/session"
import repl from 'repl';

export const initRepl = () => {
  const replInstance = repl.start({
    prompt: 'server> ',
    useColors: true,
    useGlobal: true,
  })
  
  replInstance.context.getAllSessions = async () => {
    console.log(await getAllSessions())
  }

  replInstance.context.getSession = async (token: string) => {
  
    const session = await getSession(token)
    if (session && typeof session == 'object' && Object.keys(session).length > 0) {
      console.log(session) 
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.deleteSession = async (token: string) => {
  
    const result = await deleteSession(token)
    console.log(result)
  }
  
  replInstance.context.getGame = async (code: string, keys?: string) => {
    if (!code) {
      console.log(await getAllGameDatas())
      return;
    }
  
    const gameData = await getGameData(code)
    if (typeof gameData == 'object' && gameData?.gameCode) {
      if (keys) {
        const parts = keys
        .replace(/\[(\w+)\]/g, ".$1")   // turn [0] into .0
        .replace(/^\./, "")             // remove leading dot
        .split(/(?:\?\.)|\./);          // split on ?. or .
        
        // @ts-ignore
        console.log(parts.reduce((acc, key) => acc?.[key], gameData));
      } else {
        console.log(gameData) 
      }
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.updateGame = async (code: string, keys: string, value: any) => {
    if (!code || !keys) {
      console.log("Usage: updateGame(code, 'nested.path.like.this', value)");
      return;
    }
  
    let gameData = await getGameData(code);
    if (typeof gameData !== "object" || !gameData?.gameCode) {
      console.log("No session found");
      return;
    }
  
    // Parse the keys string into parts (supporting [0], ?. etc.)
    const parts = keys
      .replace(/\[(\w+)\]/g, ".$1") // turn [0] into .0
      .replace(/^\./, "")           // remove leading dot
      .split(/(?:\?\.)|\./);        // split on ?. or .
  
    // Walk into object and set the value
    let target = gameData;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (!(key in target)) {
        // @ts-ignore
        target[key] = {}; // create missing objects
      }
      // @ts-ignore
      target = target[key];
    }
  
    const lastKey = parts[parts.length - 1];
    // @ts-ignore
    target[lastKey] = value;
  
    // Persist the change (assuming you already have a saveGameData function)
    await saveGameData(code, gameData);
  
    console.log(`Updated ${keys} to:`, value);
  };
  
  
  replInstance.context.commands = () => {
    console.log('commands:')
    console.log('getSession(token) -- if no token provided then it will return all sessions')
    console.log('deleteSession(token) -- if no token provided then it will delete all sessions')
    console.log('getGame(code) -- if no code provided then it will return all sessions')
  }
}
</file>

<file path="server/utils/sentry.ts">
/**
 * Sentry error monitoring initialization for the server.
 * 
 * This module initializes Sentry for capturing errors, performance data,
 * and other monitoring information on the backend.
 * 
 * @see https://docs.sentry.io/platforms/node/
 */

import * as Sentry from '@sentry/node';

/**
 * Initialize Sentry error monitoring.
 * Should be called as early as possible in server startup.
 * 
 * @example
 * ```typescript
 * import { initializeSentry } from './utils/sentry';
 * 
 * // At the very top of server.ts, before any other imports
 * initializeSentry();
 * ```
 */
export const initializeSentry = () => {
  const dsn = process.env.SENTRY_DSN;

  if (!dsn) {
    if (process.env.NODE_ENV === 'production') {
      console.log('⚠️ SENTRY_DSN not configured. Error monitoring disabled.', 'yellow');
    }
    return;
  }

  Sentry.init({
    dsn,
    environment: process.env.NODE_ENV || 'development',

    // Performance monitoring
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,

    // Profiling (optional - requires @sentry/profiling-node)
    // profilesSampleRate: 0.1,

    // Additional options
    serverName: process.env.PROJECT_NAME || 'luckystack-server',

    // Only send errors in production by default
    enabled: process.env.NODE_ENV === 'production' || process.env.SENTRY_ENABLED === 'true',

    // Ignore certain errors
    ignoreErrors: [
      'Socket connection timeout',
      'ECONNREFUSED',
    ],

    // Attach additional context
    beforeSend(event) {
      // Remove sensitive data if needed
      if (event.request?.cookies) {
        delete event.request.cookies;
      }
      return event;
    },
  });

  console.log('✅ Sentry initialized for error monitoring', 'green');
};

/**
 * Capture an exception and send it to Sentry.
 * 
 * @param error - The error to capture
 * @param context - Additional context to attach to the error
 * 
 * @example
 * ```typescript
 * try {
 *   await riskyOperation();
 * } catch (error) {
 *   captureException(error, { userId: user.id, action: 'riskyOperation' });
 * }
 * ```
 */
export const captureException = (
  error: unknown,
  context?: Record<string, unknown>
) => {
  if (context) {
    Sentry.setContext('additional', context);
  }
  Sentry.captureException(error);
};

/**
 * Capture a message (non-error event) and send it to Sentry.
 * 
 * @param message - The message to capture
 * @param level - Severity level (info, warning, error, fatal)
 * @param context - Additional context to attach
 * 
 * @example
 * ```typescript
 * captureMessage('User exceeded rate limit', 'warning', { userId: user.id });
 * ```
 */
export const captureMessage = (
  message: string,
  level: 'info' | 'warning' | 'error' | 'fatal' = 'info',
  context?: Record<string, unknown>
) => {
  if (context) {
    Sentry.setContext('additional', context);
  }
  Sentry.captureMessage(message, level);
};

/**
 * Set user context for error tracking.
 * Call this after user authentication.
 * 
 * @param user - User information to attach to errors
 * 
 * @example
 * ```typescript
 * setSentryUser({ id: user.id, email: user.email });
 * ```
 */
export const setSentryUser = (user: {
  id?: string;
  email?: string;
  username?: string;
} | null) => {
  Sentry.setUser(user);
};

/**
 * Create a performance transaction span.
 * Useful for tracking custom operations.
 * 
 * @param name - Name of the operation
 * @param op - Operation type (e.g., 'http', 'db', 'function')
 * @returns A span object with a finish method
 * 
 * @example
 * ```typescript
 * const span = startSpan('processPayment', 'payment');
 * try {
 *   await processPayment();
 * } finally {
 *   span.end();
 * }
 * ```
 */
export const startSpan = (name: string, op: string) => {
  return Sentry.startInactiveSpan({ name, op });
};

export default Sentry;
</file>

<file path="server/utils/validateRequest.ts">
/**
 * Shared validation utilities for API and Sync request handlers.
 * Extracted to avoid code duplication between handleApiRequest and handleSyncRequest.
 */

import type { SessionLayout, AuthProps } from '../../config';

/**
 * Check if a value is falsy (false, 0, 0n, '', null, undefined, or NaN)
 */
export const isFalsy = (value: unknown): boolean => {
  return (
    value === false ||
    value === 0 ||
    value === 0n ||
    value === '' ||
    value === null ||
    value === undefined ||
    (typeof value === 'number' && isNaN(value))
  );
};

export interface ValidationResult {
  status: 'success' | 'error';
  message?: string;
}

/**
 * Validate a request against authentication requirements.
 * 
 * @example Basic login check
 * ```typescript
 * const auth = { login: true };
 * const result = validateRequest({ auth, user });
 * ```
 * 
 * @example Additional field checks
 * ```typescript
 * const auth = { 
 *   login: true,
 *   additional: [
 *     { key: 'admin', value: true },           // Must be admin
 *     { key: 'email', type: 'string' },        // Email must be string
 *     { key: 'deletedAt', nullish: true },     // Must be null/undefined
 *     { key: 'isVerified', mustBeFalsy: false } // Must be truthy
 *   ]
 * };
 * ```
 */
export const validateRequest = ({
  auth,
  user
}: {
  auth: AuthProps;
  user: SessionLayout;
}): ValidationResult => {

  if (!auth.additional) {
    return { status: 'success' };
  }

  for (const condition of auth.additional) {
    // Validate condition has required key
    if (!condition.key) {
      return {
        status: 'error',
        message: 'Missing key in auth.additional condition',
      };
    }

    // Check if key exists in user session
    if (!(condition.key in user)) {
      return {
        status: 'error',
        message: `Key ${condition.key} not found in user session`
      };
    }

    const val = user[condition.key as keyof SessionLayout];

    // Check nullish constraint
    if (typeof condition.nullish === 'boolean') {
      const isNullish = val === null || val === undefined;
      if (condition.nullish && !isNullish) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to be null or undefined`,
        };
      }
      if (!condition.nullish && isNullish) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to be not null and not undefined`,
        };
      }
    }

    // Check type constraint (skip null or undefined values)
    if (condition.type && val != null) {
      if (typeof val !== condition.type) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to be of type ${condition.type}`,
        };
      }
    }

    // Check exact value constraint (strict equality)
    if ('value' in condition) {
      if (val !== condition.value) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to equal ${JSON.stringify(condition.value)}`,
        };
      }
    }

    // Check truthy/falsy constraint
    if (typeof condition.mustBeFalsy === 'boolean') {
      if (condition.mustBeFalsy && !isFalsy(val)) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to be falsy`,
        };
      }
      if (!condition.mustBeFalsy && isFalsy(val)) {
        return {
          status: 'error',
          message: `Expected ${condition.key} to be truthy`,
        };
      }
    }
  }

  return { status: 'success' };
};
</file>

<file path="src/_components/ThemeToggler.tsx">
import { useState } from "react";

export default function ThemeToggler() {

  const [theme, setTheme] = useState<"light" | "dark">("dark");

  //? on default we set the theme to the session of the user but we allow to change it using a useState hook
  //? reason for this is that the settings page can display how it looks in the differnt theme without needing to call the server to update the sesion if the user hasnt clicked save yet
  const updateTheme = (newTheme: string) => {
    setTheme(newTheme == 'light' ? newTheme : "dark");
    document.documentElement.classList.toggle("dark", !(newTheme == "light"));
  };

  return { theme, updateTheme };
}
</file>

<file path="src/_functions/confetti.ts">
declare const confetti: (options: { particleCount: number; spread: number; origin: { y: number } }) => void;

//? function makes confetti appear on the screen
export default function launchConfetti(): void {
  if (typeof confetti === 'function') {
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { y: 0.6 },
    });
  } else {
    console.warn("Confetti script is not loaded yet.");
  }
};
</file>

<file path="src/_functions/icon.ts">
// src/icons.ts
export { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
export * from "@fortawesome/free-solid-svg-icons";
// export * from "@fortawesome/free-regular-svg-icons";
// export * from "@fortawesome/free-brands-svg-icons";
</file>

<file path="src/_functions/menuHandler.ts">
import { ReactElement } from 'react';
import { useMenuHandler } from 'src/_components/MenuHandler';

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

let handler: ReturnType<typeof useMenuHandler> | null = null;
export const setMenuHandlerRef = (ref: ReturnType<typeof useMenuHandler>) => {
  handler = ref;
};

export const menuHandler = {
  open: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.open(component, options);
  },
  replace: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.replace(component, options);
  },
  close: (success?: boolean) => {
    handler?.close();
    return success;
  },
  closeAll: () => handler?.closeAll(),
  logStack: () => handler?.logStack()
};
</file>

<file path="src/_functions/notify.ts">
import { toast } from "sonner";
import { translate } from "src/_components/TranslationProvider";
import nlJson from "src/_locales/nl.json";
import enJson from "src/_locales/en.json";
import deJson from "src/_locales/de.json";
import frJson from "src/_locales/fr.json";
import { getCurrentSession } from "src/_providers/SessionProvider";
// import Translator from "./translator";

const Translator = () => {
  const session = getCurrentSession();
  if (!session) { return }

  switch (session.language) {
    case "nl": return nlJson;
    case "en": return enJson;
    case "de": return deJson;
    case "fr": return frJson;
    default: return enJson;
  }
}

const notify = {
  success: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.success(translate({ translationList, key, params })); }
  },
  error: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.error(translate({ translationList, key, params })); }
  },
  info: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.info(translate({ translationList, key, params })); }
  },
  warning: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.warning(translate({ translationList, key, params })); }
  },
}

export default notify;
</file>

<file path="src/_functions/sentry.ts">
/**
 * Sentry error monitoring initialization for the client.
 * 
 * This module initializes Sentry for capturing errors, performance data,
 * and session replays on the frontend.
 * 
 * @see https://docs.sentry.io/platforms/javascript/guides/react/
 */

import * as Sentry from '@sentry/react';

const env = import.meta.env;

/**
 * Initialize Sentry error monitoring for the React application.
 * Should be called as early as possible in the application startup.
 * 
 * @example
 * ```typescript
 * // In main.tsx, before ReactDOM.createRoot
 * import { initializeSentry } from './utils/sentry';
 * initializeSentry();
 * ```
 */
export const initializeSentry = () => {
  const dsn = env.VITE_SENTRY_DSN;

  if (!dsn) {
    if (env.PROD) {
      console.warn('VITE_SENTRY_DSN not configured. Error monitoring disabled.');
    }
    return;
  }

  Sentry.init({
    dsn,
    environment: env.MODE,

    // Performance Monitoring
    tracesSampleRate: env.PROD ? 0.2 : 1.0,

    // Session Replay
    replaysSessionSampleRate: env.PROD ? 0.1 : 0,
    replaysOnErrorSampleRate: 1.0,

    // Integrations
    integrations: [
      Sentry.browserTracingIntegration(),
      Sentry.replayIntegration({
        // Mask all text and block media for privacy
        maskAllText: false,
        blockAllMedia: false,
      }),
    ],

    // Only send errors in production by default
    enabled: env.PROD || env.VITE_SENTRY_ENABLED === 'true',

    // Ignore common non-actionable errors
    ignoreErrors: [
      'ResizeObserver loop limit exceeded',
      'ResizeObserver loop completed with undelivered notifications',
      'Non-Error promise rejection captured',
      /^Network Error$/,
      /^Socket connection/,
    ],

    // Filter out sensitive data
    beforeSend(event) {
      // Remove sensitive URL parameters
      if (event.request?.url) {
        const url = new URL(event.request.url);
        url.searchParams.delete('token');
        url.searchParams.delete('code');
        event.request.url = url.toString();
      }
      return event;
    },
  });

  console.log('✅ Sentry initialized for error monitoring');
};

/**
 * Capture an exception and send it to Sentry.
 * 
 * @param error - The error to capture
 * @param context - Additional context to attach to the error
 * 
 * @example
 * ```typescript
 * try {
 *   await riskyOperation();
 * } catch (error) {
 *   captureException(error, { userId: session?.id, action: 'riskyOperation' });
 * }
 * ```
 */
export const captureException = (
  error: unknown,
  context?: Record<string, unknown>
) => {
  if (context) {
    Sentry.setContext('additional', context);
  }
  Sentry.captureException(error);
};

/**
 * Capture a message (non-error event) and send it to Sentry.
 * 
 * @param message - The message to capture
 * @param level - Severity level
 * @param context - Additional context to attach
 */
export const captureMessage = (
  message: string,
  level: 'info' | 'warning' | 'error' | 'fatal' = 'info',
  context?: Record<string, unknown>
) => {
  if (context) {
    Sentry.setContext('additional', context);
  }
  Sentry.captureMessage(message, level);
};

/**
 * Set user context for error tracking.
 * Call this after user authentication.
 * 
 * @param user - User information to attach to errors
 * 
 * @example
 * ```typescript
 * // In SessionProvider after session loads
 * if (session?.id) {
 *   setSentryUser({ id: session.id, email: session.email });
 * }
 * ```
 */
export const setSentryUser = (user: {
  id?: string;
  email?: string;
  username?: string;
} | null) => {
  Sentry.setUser(user);
};

/**
 * Error Boundary component for React.
 * Wrap your app or components to catch and report errors.
 * 
 * @example
 * ```tsx
 * import { SentryErrorBoundary } from './utils/sentry';
 * 
 * <SentryErrorBoundary fallback={<ErrorFallback />}>
 *   <App />
 * </SentryErrorBoundary>
 * ```
 */
export const SentryErrorBoundary = Sentry.ErrorBoundary;

/**
 * HOC to wrap components with Sentry profiling.
 * 
 * @example
 * ```typescript
 * export default withSentryProfiler(MyComponent);
 * ```
 */
export const withSentryProfiler = Sentry.withProfiler;

export default Sentry;
</file>

<file path="src/_functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="src/_functions/translator.ts">
// useTranslator.ts
import { useTranslation, translate } from "src/_components/TranslationProvider";

export const useTranslator = () => {
  const translations = useTranslation();
  return ({ key, params }: { key: string; params?: { key: string; value: string | number | boolean }[] }) =>
    translate({ translationList: translations, key, params });
};
</file>

<file path="src/_functions/tryCatch.ts">
//? wrap your funcions in this function and check if the first value has a truthy value if it does than there is an error
//? if the first value is null than there is no error and you can access the second value wich is the response of your function
export default async function <T, P>(
  func: (values: P) => Promise<T> | T, 
  params?: P
): Promise<[unknown, T | null]> {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error: unknown) {
    return [error, null];
  }
}
</file>

<file path="src/_locales/de.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FEHLER",
    "404": "Etwas ist schiefgelaufen, versuche es später erneut."
  },
  "middleware": {
    "notAdmin": "Du bist kein Admin."
  },
  "login": {
    "empty": "Keine E-Mail oder kein Passwort angegeben.",
    "emailCharacterLimit": "E-Mail darf nicht länger als 191 Zeichen sein.",
    "passwordCharacterMinimum": "Passwort muss mindestens 8 Zeichen lang sein.",
    "passwordCharacterLimit": "Passwort darf nicht länger als 191 Zeichen sein.",
    "nameCharacterLimit": "Name darf nicht länger als 191 Zeichen sein.",
    "invalidEmailFormat": "Ungültiges E-Mail-Format.",
    "passwordNotMatch": "Passwörter stimmen nicht überein.",
    "emailExists": "E-Mail existiert bereits.",
    "userCreated": "Benutzer erstellt.",
    "createUserFailed": "Fehler beim Erstellen des Benutzers.",
    "userNotFound": "Benutzer nicht gefunden.",
    "wrongPassword": "Passwort stimmt nicht überein.",
    "loggedIn": "Benutzer eingeloggt.",
    "providerNotFound": "Provider nicht gefunden.",
    "noReason": "Kein Grund angegeben."
  },
  "settings": {
    "changeAvatar": "Avatar ändern",
    "changeAvatarDescription": "JPG, GIF oder PNG. Max 4 MB.",
    "language": {
      "title": "Sprache",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Hell",
      "dark": "Dunkel"
    },
    "saveChanges": "Änderungen speichern",
    "updatedUser": "Benutzer aktualisiert",
    "failedUpdateUser": "Fehler beim Aktualisieren des Benutzers",
    "noChangesMade": "Keine Änderungen vorgenommen",
    "sizeToLarge": "Maximale Uploadgröße ist 4~5 MB, wähle ein kleineres Bild!!",
    "loadingImg": "Foto wird geladen",
    "imgLoaded": "Foto wurde geladen"
  }
}
</file>

<file path="src/_locales/en.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERROR",
    "404": "Something went wrong, try again later."
  },
  "middleware": {
    "notAdmin": "You are not an admin."
  },
  "login": {
    "empty": "No email or password provided.",
    "emailCharacterLimit": "Email can't be longer than 191 characters.",
    "passwordCharacterMinimum": "Password must be at least 8 characters long.",
    "passwordCharacterLimit": "Password can't be longer than 191 characters.",
    "nameCharacterLimit": "Name can't be longer than 191 characters.",
    "invalidEmailFormat": "Invalid email format.",
    "passwordNotMatch": "Passwords do not match.",
    "emailExists": "Email already exists.",
    "userCreated": "User created.",
    "createUserFailed": "Failed to create new user.",
    "userNotFound": "User not found.",
    "wrongPassword": "Password does not match.",
    "loggedIn": "User logged in.",
    "providerNotFound": "Provider not found.",
    "noReason": "No reason provided."
  },
  "settings": {
    "changeAvatar": "Change avatar",
    "deleteAvatar": "Delete avatar",
    "changeAvatarDescription": "JPG, GIF or PNG. 4MB max.",
    "language": {
      "title": "Language",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Theme",
      "light": "Light",
      "dark": "Dark"
    },
    "saveChanges": "Save changes",
    "updatedUser": "updated the user",
    "failedUpdateUser": "Failed to update the user",
    "noChangesMade": "No changes made",
    "sizeToLarge": "Max upload size is 4~5 MB, chose a smaller img!!",
    "loadingImg": "Photo is loading",
    "imgLoaded": "Photo has loaded"
  }
}
</file>

<file path="src/_locales/fr.json">
{
  "test": "Bonjour {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERREUR",
    "404": "Un problème est survenu, réessayez plus tard."
  },
  "middleware": {
    "notAdmin": "Vous n'êtes pas administrateur."
  },
  "login": {
    "empty": "Aucun e-mail ou mot de passe fourni.",
    "emailCharacterLimit": "L'e-mail ne peut pas dépasser 191 caractères.",
    "passwordCharacterMinimum": "Le mot de passe doit comporter au moins 8 caractères.",
    "passwordCharacterLimit": "Le mot de passe ne peut pas dépasser 191 caractères.",
    "nameCharacterLimit": "Le nom ne peut pas dépasser 191 caractères.",
    "invalidEmailFormat": "Format d'e-mail invalide.",
    "passwordNotMatch": "Les mots de passe ne correspondent pas.",
    "emailExists": "L'e-mail existe déjà.",
    "userCreated": "Utilisateur créé.",
    "createUserFailed": "Échec de la création de l'utilisateur.",
    "userNotFound": "Utilisateur non trouvé.",
    "wrongPassword": "Le mot de passe est incorrect.",
    "loggedIn": "Utilisateur connecté.",
    "providerNotFound": "Fournisseur introuvable.",
    "noReason": "Aucune raison fournie."
  },
  
  "settings": {
    "changeAvatar": "Changer d'avatar",
    "changeAvatarDescription": "JPG, GIF ou PNG. Max 4 Mo.",
    "language": {
      "title": "Langue",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thème",
      "light": "Clair",
      "dark": "Sombre"
    },
    "saveChanges": "Enregistrer les modifications",
    "updatedUser": "utilisateur mis à jour",
    "failedUpdateUser": "Échec de la mise à jour de l'utilisateur",
    "noChangesMade": "Aucun changement effectué",
    "sizeToLarge": "La taille maximale est de 4~5 Mo, choisissez une image plus petite !!",
    "loadingImg": "La photo est en cours de chargement",
    "imgLoaded": "La photo a été chargée"
  }
}
</file>

<file path="src/_locales/nl.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FOUT",
    "404": "Er is iets misgegaan, probeer het later opnieuw."
  },
  "middleware": {
    "notAdmin": "Je bent geen admin."
  },
  "login": {
    "empty": "Geen e-mail of wachtwoord opgegeven.",
    "emailCharacterLimit": "E-mail mag niet langer zijn dan 191 tekens.",
    "passwordCharacterMinimum": "Wachtwoord moet minimaal 8 tekens lang zijn.",
    "passwordCharacterLimit": "Wachtwoord mag niet langer zijn dan 191 tekens.",
    "nameCharacterLimit": "Naam mag niet langer zijn dan 191 tekens.",
    "invalidEmailFormat": "Ongeldig e-mailformaat.",
    "passwordNotMatch": "Wachtwoorden komen niet overeen.",
    "emailExists": "E-mail bestaat al.",
    "userCreated": "Gebruiker aangemaakt.",
    "createUserFailed": "Gebruiker aanmaken mislukt.",
    "userNotFound": "Gebruiker niet gevonden.",
    "wrongPassword": "Wachtwoord komt niet overeen.",
    "loggedIn": "Gebruiker ingelogd.",
    "providerNotFound": "Provider niet gevonden.",
    "noReason": "Geen reden opgegeven."
  },
  "settings": {
    "changeAvatar": "Verander avatar",
    "changeAvatarDescription": "JPG, GIF of PNG. Max 4MB.",
    "language": {
      "title": "Taal",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Licht",
      "dark": "Donker"
    },
    "saveChanges": "Wijzigingen opslaan",
    "updatedUser": "gebruiker bijgewerkt",
    "failedUpdateUser": "Bijwerken gebruiker mislukt",
    "noChangesMade": "Geen wijzigingen gemaakt",
    "sizeToLarge": "Maximale uploadgrootte is 4~5 MB, kies een kleinere afbeelding!!",
    "loadingImg": "Foto word geladen",
    "imgLoaded": "Foto is geladen"
  }
}
</file>

<file path="src/_sockets/offlineQueue.ts">
import { dev } from "config";

type ApiQueueItem = {
  id: string;
  key: string;
  run: () => void;
  createdAt: number;
};

type SyncQueueItem = {
  id: string;
  key: string;
  run: () => void;
  createdAt: number;
};

const apiQueue: ApiQueueItem[] = [];
const syncQueue: SyncQueueItem[] = [];
let isFlushing = false;

export const isOnline = () => {
  if (typeof navigator === "undefined") return true;
  return navigator.onLine !== false;
};

export const enqueueApiRequest = (item: ApiQueueItem) => {
  apiQueue.push(item);
  if (dev) {
    console.log("API request queued", { key: item.key, queueSize: apiQueue.length });
  }
};

export const enqueueSyncRequest = (item: SyncQueueItem) => {
  syncQueue.push(item);
  if (dev) {
    console.log("Sync request queued", { key: item.key, queueSize: syncQueue.length });
  }
};

export const removeApiQueueItem = (id: string) => {
  const index = apiQueue.findIndex((item) => item.id === id);
  if (index >= 0) {
    apiQueue.splice(index, 1);
  }
};

export const removeSyncQueueItem = (id: string) => {
  const index = syncQueue.findIndex((item) => item.id === id);
  if (index >= 0) {
    syncQueue.splice(index, 1);
  }
};

export const removeApiQueueItemsByKey = (key: string) => {
  for (let i = apiQueue.length - 1; i >= 0; i -= 1) {
    if (apiQueue[i].key === key) {
      apiQueue.splice(i, 1);
    }
  }
};

export const flushApiQueue = (canRun: () => boolean) => {
  if (isFlushing) return;
  if (apiQueue.length === 0) return;
  if (!canRun()) return;

  isFlushing = true;
  while (apiQueue.length > 0) {
    if (!canRun()) break;
    const item = apiQueue.shift();
    item?.run();
  }
  isFlushing = false;
};

export const flushSyncQueue = (canRun: () => boolean) => {
  if (isFlushing) return;
  if (syncQueue.length === 0) return;
  if (!canRun()) return;

  isFlushing = true;
  while (syncQueue.length > 0) {
    if (!canRun()) break;
    const item = syncQueue.shift();
    item?.run();
  }
  isFlushing = false;
};

export const getApiQueueSize = () => apiQueue.length;
export const getSyncQueueSize = () => syncQueue.length;
</file>

<file path="src/admin/page.tsx">
export default function Home() {
  return (
    <div className='flex items-center justify-center text-4xl font-semibold w-full h-full'>
      Admin
    </div>
  )
}
</file>

<file path="src/docs/_api/getDocs.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, ApiResponse } from '../../../src/_sockets/apiTypes.generated';
import fs from 'fs';
import path from 'path';

export const rateLimit: number | false = 10; // Rate limit for this docs endpoint itself

export const auth: AuthProps = {
  login: false, // Publicly accessible documentation
  additional: []
};

export interface ApiParams {
  data: {};
  user: SessionLayout;
  functions: Functions;
}

// Interfaces for our documentation structure
interface ApiDoc {
  page: string;
  name: string;
  method: string;
  description?: string;
  input: string;
  output: string;
  auth: any;
  // rateLimit: number | false | undefined;
  rateLimit: number | boolean | undefined; //? should never contain the value true but just in case we have a mismatch in te code we support the type
  path: string;
}

interface SyncDoc {
  page: string;
  name: string;
  clientInput: string;
  serverOutput: string;
  clientOutput: string;
  path: string;
}

interface DocsResult {
  apis: Record<string, ApiDoc[]>;
  syncs: Record<string, SyncDoc[]>;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {
  const rootDir = process.cwd();
  const apiTypesPath = path.join(rootDir, 'src', '_sockets', 'apiTypes.generated.ts');

  if (!fs.existsSync(apiTypesPath)) {
    return { status: 'error', message: 'apiTypes.generated.ts not found' };
  }

  const apiTypesContent = fs.readFileSync(apiTypesPath, 'utf-8');
  
  const docs: DocsResult = {
    apis: {},
    syncs: {}
  };

  // 1. Extract API definitions
  // Look for sections in ApiTypeMap
  const apiMapMatch = apiTypesContent.match(/export interface ApiTypeMap \{([\s\S]*?)\n\}/);
  if (apiMapMatch) {
    const apiMapBody = apiMapMatch[1];
    
    // Split by page (e.g. 'examples': { ... })
    const pageRegex = /'([^']+)':\s*\{([\s\S]*?)\n\s\s\};/g;
    let pageMatch;

    while ((pageMatch = pageRegex.exec(apiMapBody)) !== null) {
      const pageName = pageMatch[1];
      const pageBody = pageMatch[2];
      
      docs.apis[pageName] = [];

      // Extract APIs within the page
      const apiRegex = /'([^']+)':\s*\{([\s\S]*?)\n\s\s\s\s\};/g;
      let apiMatch;

      while ((apiMatch = apiRegex.exec(pageBody)) !== null) {
        const apiName = apiMatch[1];
        const apiBody = apiMatch[2];

        // Extract types
        const inputMatch = apiBody.match(/input:\s*(\{[\s\S]*?\});/);
        const outputMatch = apiBody.match(/output:\s*(\{[\s\S]*?\});/);
        const methodMatch = apiBody.match(/method:\s*'([^']+)';/);

        // Read the actual API file for auth and rateLimit
        const apiFilePath = path.join(rootDir, 'src', pageName, '_api', `${apiName}.ts`);
        let authConfig = null;
        let rateLimitConfig = undefined;

        if (fs.existsSync(apiFilePath)) {
          const apiFileContent = fs.readFileSync(apiFilePath, 'utf-8');
          
          // Simple regex to extract auth and rateLimit - in a real compiler we'd use AST
          // This is a "best effort" runtime extraction
          const authMatch = apiFileContent.match(/export const auth: AuthProps = (\{[\s\S]*?\});/);
          if (authMatch) {
            try {
              // Dangerous eval-like parsing, but strictly for JSON-like structures in this controlled env
              // Replacing strictly JSON incompatible syntax if necessary, but assuming simple objects
               // For safety, we just pass the string string for the frontend to display or try to parse loosely
               // Let's just pass the string representation for now, or try to parse keys
               authConfig = authMatch[1]; 
            } catch (e) {}
          }

          const rateLimitMatch = apiFileContent.match(/export const rateLimit: number \| false = ([\d\w]+|false);/);
          if (rateLimitMatch) {
             const val = rateLimitMatch[1];
             rateLimitConfig = val === 'false' ? false : parseInt(val);
          }
        }

        docs.apis[pageName].push({
          page: pageName,
          name: apiName,
          method: methodMatch ? methodMatch[1] : 'POST',
          input: inputMatch ? inputMatch[1] : '{}',
          output: outputMatch ? outputMatch[1] : '{}',
          auth: authConfig,
          rateLimit: rateLimitConfig,
          path: `api/${pageName}/${apiName}`
        });
      }
    }
  }

  // 2. Extract Sync definitions
  const syncMapMatch = apiTypesContent.match(/export interface SyncTypeMap \{([\s\S]*?)\n\}/);
  if (syncMapMatch) {
    const syncMapBody = syncMapMatch[1];
    
    const pageRegex = /'([^']+)':\s*\{([\s\S]*?)\n\s\s\};/g;
    let pageMatch;

    while ((pageMatch = pageRegex.exec(syncMapBody)) !== null) {
      const pageName = pageMatch[1];
      const pageBody = pageMatch[2];
      
      docs.syncs[pageName] = [];

      const syncRegex = /'([^']+)':\s*\{([\s\S]*?)\n\s\s\s\s\};/g;
      let syncMatch;

      while ((syncMatch = syncRegex.exec(pageBody)) !== null) {
        const syncName = syncMatch[1];
        const syncBody = syncMatch[2];

        const clientInputMatch = syncBody.match(/clientInput:\s*(\{[\s\S]*?\});/);
        const serverOutputMatch = syncBody.match(/serverOutput:\s*(\{[\s\S]*?\});/);
        const clientOutputMatch = syncBody.match(/clientOutput:\s*(\{[\s\S]*?\});/);

        docs.syncs[pageName].push({
          page: pageName,
          name: syncName,
          clientInput: clientInputMatch ? clientInputMatch[1] : '{}',
          serverOutput: serverOutputMatch ? serverOutputMatch[1] : '{}',
          clientOutput: clientOutputMatch ? clientOutputMatch[1] : '{}',
          path: `sync/${pageName}/${syncName}`
        });
      }
    }
  }

  return {
    status: 'success',
    result: docs
  };
};
</file>

<file path="src/login/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-background">
      <LoginForm formType="login" />
    </div>
  )
}
</file>

<file path="src/register/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center bg-background">
        <LoginForm formType="register" />
      </div>
    )
}
</file>

<file path="src/scrollbar-dark.css">
/* Global scrollbar styling */

/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background-color: #a3a3a3; /* Medium dark gray */
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background-color: #6b6b6b; /* Lighter gray on hover */
}

::-webkit-scrollbar-button {
    display: none;
}
</file>

<file path="src/scrollbar-white.css">
/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px; /* Customize width */
    height: 8px; /* Customize height for horizontal scrollbars */
}
  
::-webkit-scrollbar-track {
    background: transparent; /* Remove the white background behind the scrollbar */
}
  
::-webkit-scrollbar-thumb {
    background-color: #ffffff; /* Customize thumb color */
    border-radius: 4px; /* Optional: make scrollbar thumb rounded */
    transition: all 0.3s; /* Optional: add hover effect */
    padding: 20px; /* Optional: just make scrollbar thinner */
}
  
::-webkit-scrollbar-thumb:hover {
    background-color: #ffffff; /* Customize thumb color on hover */
}
  
::-webkit-scrollbar-button {
    display: none; /* Remove arrows */
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".claude/CLAUDE.md">
# LuckyStack - AI Development Rules

> These rules are automatically loaded by Claude Code on every prompt.
> Last updated: 2026-02-10

---

## Project Overview

**LuckyStack** is a socket-first fullstack framework built with React 19 + raw Node.js (no Express). All client-server communication happens via Socket.io WebSockets, with HTTP fallback. The project uses file-based routing for pages, APIs, and real-time sync events.

**Tech stack:** React 19, React Router 7, TailwindCSS 4, Socket.io, Prisma 6.5, TypeScript 5.7, Vite, Redis

**Database:** Configurable via Prisma - supports MongoDB, MySQL, PostgreSQL, and SQLite. Check `prisma/schema.prisma` for the currently active provider.

---

## Rules

### 1. Styling

- Use **TailwindCSS** exclusively for styling.
- Only use colors defined in `src/index.css` (the `@theme` block and `.dark` overrides). Never use arbitrary color values.
- Available color tokens: `background`, `container`, `container2`, `container3`, `container4` (each with `-border` and `-hover` variants), `title`, `common`, `muted`, `correct`, `correct-hover`, `wrong`, `wrong-hover`.
- Prefer `flex` and `gap` for layout. Avoid using `margin` unless absolutely necessary.
- Dark mode is handled via CSS class `.dark` on `<html>`. Colors auto-switch via CSS variables.
- Use existing Components like our Dropdown, MenuHandler, Avatar, ConfirmMenu, Icon, etc.
### 2. No Emojis

- Never add emojis in code, comments, UI text, debug output, documentation, or html (use fontawesome icons instead).

### 3. SOLID Principles

- Follow SOLID principles in all code:
  - **S**ingle Responsibility: each file/function does one thing.
  - **O**pen/Closed: extend behavior without modifying existing code.
  - **L**iskov Substitution: subtypes must be substitutable for their base types.
  - **I**nterface Segregation: prefer small, focused interfaces.
  - **D**ependency Inversion: depend on abstractions, not concretions.

### 4. Comments

- Write simple comments explaining **why** something is done, not what.
- Do not add long JSDoc blocks or examples at the start of functions if the function name is self-explanatory.
- No redundant comments on obvious code.

### 5. Error Handling

- Always use the custom `tryCatch` function for error handling:
  - **Client:** `import tryCatch from 'src/_functions/tryCatch'` - returns `[error, result]` tuple.
  - **Server:** `import { tryCatch } from 'server/functions/tryCatch'` - returns `[error, result]` tuple with automatic Sentry capture (in api and sync calls we get tryCatch in the function parameter ).
- Check the first value: if truthy, there's an error. If null, access the second value for the result.
- Never use raw `try/catch` blocks. Always wrap async operations in `tryCatch`.

### 6. Terminal Commands

- Do not run terminal commands automatically. Instead, tell the user what to run and explain why.
- Exception: reading files, searching code, and git operations are fine.

### 7. No Test Files

- Do not create test files to verify backend functionality.
- Instead, explain to the user how to test the feature (e.g., via browser console, curl, or the examples page) and why that approach works.

### 8. Use Existing Code and Patterns

- Always look at existing code before implementing something new.
- Match the coding style, patterns, and conventions already in the codebase.
- Reuse existing utilities (`tryCatch`, `notify`, `apiRequest`, `syncRequest`, etc.).
- Follow the established file-based routing pattern for new APIs and sync events.

### 9. Ask When Unsure

- If requirements are unclear or you're unsure about an approach, always ask the user before guessing.
- This applies to architecture decisions, feature scope, UI behavior, and anything ambiguous.

### 10. Suggest Next Steps

- After completing code, suggest what the user should do next (e.g., code review, testing approach, related changes).

### 11. Report Issues Without Auto-Fixing

- When analyzing code and you notice potential mistakes, unhandled errors, or improvement opportunities, report them to the user.
- Do not fix them automatically. Let the user decide.

### 12. Verify Code Flow Against Docs

- Before writing code, verify that the code flow you've analyzed matches what the docs describe.
- If the flow matches the docs, proceed with implementation.
- If the flow doesn't match the docs, re-analyze the code. If you're still confident the docs are wrong after a second look, tell the user so the docs can be updated. Otherwise, follow the docs.

### 13. Keep Documentation Updated

- After making significant code changes, update the relevant documentation files (`PROJECT_CONTEXT.md`, `docs/ARCHITECTURE_*.md`, etc.) to stay in sync with the codebase.
- After updating docs, tell the user to run `npx repomix` to regenerate the codebase summary.

### 14. Keep Design Updated

- when updating files that are listed in the .gitignore check if there is a template file for it and update that too. (e.g. .env -> envTemplate.txt or config.ts -> configTemplate.txt)
---

## Project Structure

```
LuckyStack/
├── server/                    # Backend (raw Node.js + Socket.io)
│   ├── server.ts              # HTTP server entry point
│   ├── auth/                  # OAuth + credentials authentication
│   ├── sockets/               # Socket.io event handlers
│   │   ├── socket.ts          # Socket server setup
│   │   ├── handleApiRequest.ts
│   │   ├── handleHttpApiRequest.ts
│   │   └── handleSyncRequest.ts
│   ├── functions/             # Server utilities (session, db, redis, tryCatch)
│   ├── utils/                 # Helpers (rateLimiter, validateRequest, sentry)
│   └── dev/                   # Hot-reload & type generation
│
├── src/                       # Frontend (React 19)
│   ├── main.tsx               # Entry point + file-based router
│   ├── index.css              # Tailwind theme colors (ONLY color source)
│   ├── _sockets/              # apiRequest, syncRequest, socketInitializer
│   ├── _providers/            # SessionProvider, SocketStatusProvider
│   ├── _components/           # Shared UI (Navbar, Middleware, MenuHandler, etc.)
│   ├── _functions/            # Client utilities (tryCatch, notify, translator)
│   ├── _locales/              # i18n translations (nl, en, de, fr)
│   └── {page}/                # Feature pages
│       ├── page.tsx           # Page component (exports template)
│       ├── _components/       # Page-specific components
│       ├── _api/              # API endpoints for this page
│       └── _sync/             # Sync handlers for this page
│
├── docs/                      # Architecture documentation
│   ├── ARCHITECTURE_API.md    # API request system
│   ├── ARCHITECTURE_AUTH.md   # Authentication flows
│   ├── ARCHITECTURE_ROUTING.md # File-based routing (pages, APIs, syncs)
│   ├── ARCHITECTURE_SESSION.md # Session management
│   ├── ARCHITECTURE_SOCKET.md # Socket.io setup
│   ├── ARCHITECTURE_SYNC.md   # Real-time sync system
│   ├── DEVELOPER_GUIDE.md     # Getting started
│   └── HOSTING.md             # Deployment guide
│
├── prisma/schema.prisma       # Database schema (supports MongoDB, MySQL, PostgreSQL, SQLite)
├── config.ts                  # App config (gitignored, use configTemplate.txt)
├── .env                       # Environment vars (gitignored, use envTemplate.txt)
├── README.md                  # Framework overview
└── PROJECT_CONTEXT.md         # Detailed architecture reference
```

## Key Patterns

### File-Based Routing

- `src/{page}/page.tsx` renders at route `/{page}`
- `src/{page}/_api/{name}.ts` creates an API endpoint accessible as `api/{page}/{name}`
- `src/{page}/_sync/{name}_server.ts` + `{name}_client.ts` creates a sync event as `sync/{page}/{name}`
- Folders prefixed with `_` are private (not routes)
- For full routing details see `docs/ARCHITECTURE_ROUTING.md`

### API Pattern

```typescript
// src/{page}/_api/{name}.ts
export const rateLimit: number | false = 60;
export const method: "GET" | "POST" | "PUT" | "DELETE" = "POST";

export const auth: AuthProps = { 
  login: true, 
  additional: [] 
};

export interface ApiParams {
  data: { /* typed input */ };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {
  return { status: 'success', result: { /* data */ } };
};
```

### Sync Pattern

- `_server.ts` runs once on server for validation
- `_client.ts` runs on server for each client in the room
- Client sends: `syncRequest({ name, data, receiver: roomCode, ignoreSelf?: boolean })`
- Client receives: `upsertSyncEventCallback(name, ({ clientOutput, serverOutput }) => {})`

### Provider Hierarchy

```
SocketStatusProvider > SessionProvider > TranslationProvider > AvatarProvider > MenuHandlerProvider > Router
```

### Templates

Pages export `template` as `'plain'`, `'home'`, or a new template that you can create yourself. 

- `plain` - No UI chrome (login, register, docs)
- `home` - Top bar with avatar, settings toggle, logout

---

## Documentation Reference

For detailed architecture docs, read the files in `docs/`:
- Routing: `docs/ARCHITECTURE_ROUTING.md`
- API system: `docs/ARCHITECTURE_API.md`
- Auth flows: `docs/ARCHITECTURE_AUTH.md`
- Sessions: `docs/ARCHITECTURE_SESSION.md`
- Socket setup: `docs/ARCHITECTURE_SOCKET.md`
- Sync events: `docs/ARCHITECTURE_SYNC.md`
- Getting started: `docs/DEVELOPER_GUIDE.md`
- Deployment: `docs/HOSTING.md`
- Full context: `PROJECT_CONTEXT.md`


## JSX

- Always use self-closing tags for components that don't have children: `<MyComponent />` instead of `<MyComponent></MyComponent>`.
- Use div tags for basicly everything besides obvious cases like buttons or inputs, e.g. don't use header or footer tags.
- With text use our i18n implementation.
```tsx
import { useTranslator } from "src/_functions/translator";

const translate = useTranslator();
{translate({ key: 'settings.theme.light' })}
```
- always use `` in a className tag instead of '' or "".
</file>

<file path=".cursorrules">
# Cursor AI Project Rules

You have access to valid project context in the following files. You should prioritize reading these files to understand the project structure, configuration, and current state before proposing changes or answering complex questions:

1. **`.claude/CLAUDE.md`**: Contains AI development rules, coding conventions, and project overview. Read this first.
2. **`PROJECT_CONTEXT.md`**: Contains detailed architecture documentation, terminology, and design decisions.
3. **`docs/`**: Contains architecture documentation for Routing, API, Auth, Session, Socket, and Sync systems.
4. **`config.ts`**: Contains the main application configuration constants and types.
5. **`.env`**: Contains environment variables and active configuration settings.

## Behavior
- When starting a significant task, always check `.claude/CLAUDE.md` and `PROJECT_CONTEXT.md` first.
- Verify configuration values in `config.ts` and `.env` when debugging or adding features.
- Follow all rules defined in `.claude/CLAUDE.md` (styling, error handling, comments, SOLID, etc.).

## Context Update Rule (IMPORTANT)
**After every code change, you MUST:**
1. **Update `PROJECT_CONTEXT.md`** - Document any new files, functions, patterns, or behavior changes you've made. Keep the documentation in sync with the codebase.
2. **Regenerate `repomix-output.xml`** - Run `npx repomix` to regenerate the codebase summary with your changes.

This ensures future AI sessions have accurate context about the current state of the codebase.


## Files for extra context
**These files are meant for the user but can be usefull for the AI to understand the project**
1. `docs/ARCHITECTURE_API.md`
2. `docs/ARCHITECTURE_AUTH.md`
3. `docs/ARCHITECTURE_SESSION.md`
4. `docs/ARCHITECTURE_SOCKET.md`
5. `docs/ARCHITECTURE_SYNC.md`
6. `docs/DEVELOPER_GUIDE.md`

After changes are made all files can be updated if they are related to the changes.
</file>

<file path="docs/ARCHITECTURE_AUTH.md">
# Authentication Architecture

> OAuth and credentials-based authentication system.

---

## Quick Reference

```typescript
// Trigger OAuth login (redirects)
window.location.href = "/auth/api/google";

// Credentials login
const response = await fetch("/auth/api/credentials", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ email, password }),
});
```

---

## Supported Providers

| Provider    | Type           | Config Required   |
| ----------- | -------------- | ----------------- |
| Credentials | Email/Password | None (built-in)   |
| Google      | OAuth 2.0      | Client ID, Secret |
| GitHub      | OAuth 2.0      | Client ID, Secret |
| Discord     | OAuth 2.0      | Client ID, Secret |
| Facebook    | OAuth 2.0      | Client ID, Secret |

---

## Configuration

### Environment Variables

```bash
# .env
DNS=http://localhost:5173                    # Frontend URL
EXTERNAL_ORIGINS=https://myapp.com           # Allowed origins (comma-separated)

# OAuth Providers
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
GITHUB_CLIENT_ID=...
GITHUB_CLIENT_SECRET=...
DISCORD_CLIENT_ID=...
DISCORD_CLIENT_SECRET=...
FACEBOOK_CLIENT_ID=...
FACEBOOK_CLIENT_SECRET=...
```

### Provider Config (`server/auth/loginConfig.ts`)

```typescript
const oauthProviders = [
  {
    name: "google",
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    authorizationURL: "https://accounts.google.com/o/oauth2/auth",
    tokenURL: "https://oauth2.googleapis.com/token",
    callbackURL: `${process.env.DNS}/auth/callback/google`,
    scope: ["email", "profile"],
  },
  // ... other providers
];
```

---

## Login Flows

### OAuth Flow

```
1. User clicks "Login with Google"
   ↓
2. Redirect to: /auth/api/google
   ↓
3. Server redirects to Google OAuth URL
   ↓
4. User authenticates with Google
   ↓
5. Google redirects to: /auth/callback/google?code=...
   ↓
6. Server exchanges code for token
   ↓
7. Server fetches user profile from Google
   ↓
8. Server creates/finds user in database
   ↓
9. Server creates session in Redis
   ↓
10. Redirect to frontend with token cookie
```

### Credentials Flow

```
1. User submits email + password
   ↓
2. POST to: /auth/api/credentials
   ↓
3. Server validates credentials
   ↓
4. If action='register': Create user, hash password
   If action='login': Verify password hash
   ↓
5. Server creates session in Redis
   ↓
6. Return { status: true, session, newToken }
```

---

## Auth Endpoints

| Endpoint                    | Method | Purpose                        |
| --------------------------- | ------ | ------------------------------ |
| `/auth/api/{provider}`      | GET    | Initiate OAuth login           |
| `/auth/api/credentials`     | POST   | Credentials login/register     |
| `/auth/callback/{provider}` | GET    | OAuth callback (from provider) |

---

## API And SYNC Authorization

### Basic login requirement

```typescript
// In _api/*.ts
export const auth: AuthProps = {
  login: true, // User must be logged in
  additional: [], // No extra requirements
};
```

### Role-based access

```typescript
export const auth: AuthProps = {
  login: true,
  additional: [
    {
      key: "admin",
      value: true, // User must have 'admin' role
    },
  ],
};
```

---

## Frontend Components

### Login Buttons

```tsx
function LoginPage() {
  return (
    <div>
      <button onClick={() => (window.location.href = "/auth/api/google")}>
        Login with Google
      </button>
      <button onClick={() => (window.location.href = "/auth/api/github")}>
        Login with GitHub
      </button>
    </div>
  );
}
```

### Middleware

```ts
switch (location) {
  case "/test":
    if (session?.email && session?.provider) {
      return { success: true };
    }
    return { redirect: "/login" };

  case "/admin":
    if (session?.email && session?.provider && session?.admin === true) {
      return { success: true };
    } else if (!session?.email || !session?.provider) {
      return { redirect: "/login" };
    } else if (!session?.admin) {
      notify.error({ key: "middleware.notAdmin" });
    }
    return;

  default:
    return { success: true };
}
```

---

## Security Considerations

1. **CORS** - Only `DNS` and `EXTERNAL_ORIGINS` are allowed
2. **HttpOnly cookies** - Tokens not accessible via JavaScript
3. **bcrypt** - Passwords hashed with salt rounds
4. **CSRF** - WebSocket architecture inherently prevents CSRF
5. **Origin check** - Every request validates origin header
</file>

<file path="docs/ARCHITECTURE_SESSION.md">
# Session Architecture

> Session management using Redis with OAuth provider support.

---

## Quick Reference

```typescript
// Client: Get current session
const session = await apiRequest({ name: "session" });
// Returns: { id, email, name, provider, ... } or null

// Client: Logout
await apiRequest({ name: "logout" });
```

---

## Session Storage

Sessions are stored in **Redis** with configurable expiry.

```
Redis Key: {PROJECT_NAME}:session:{token}
Value: JSON-encoded SessionLayout
Expiry: config.sessionExpiryDays (default: 7 days)
```

---

## SessionLayout

Define your session structure in `config.ts`:

```typescript
export interface SessionLayout {
  id: string;
  name: string;
  email: string;
  provider: string;
  admin: boolean;
  avatar: string;
  avatarFallback: string;
  language: string;
  theme: "light" | "dark";
  createdAt: Date;
  updatedAt: Date;
  token: string;
  location?: {
    pathName: string;
    searchParams: { [key: string]: string };
  };
}
```

---

## Configuration

```typescript
// config.ts
const config = {
  // Session behavior
  allowMultipleSessions: false, // false = new login kicks other sessions
  sessionExpiryDays: 7,

  // Redirects
  loginPageUrl: "/login",
  loginRedirectUrl: "/examples",
};
```

---

## Session Flow

```
1. User logs in (OAuth or credentials)
   ↓
2. Server generates random token (UUID)
   ↓
3. Session stored in Redis: {token} → {user data}
   ↓
4. Token sent to client:
   - Cookie-based: Set-Cookie: token={token}; HttpOnly
   - Session-based: Returned in response body
   ↓
5. Subsequent requests include token:
   - WebSocket: socket.handshake.auth.token
   - HTTP: Cookie header or Authorization: Bearer {token}
```

---

## Token Modes

Controlled by `VITE_SESSION_BASED_TOKEN` env variable:

| Mode              | Storage         | Best For                   |
| ----------------- | --------------- | -------------------------- |
| `false` (default) | HttpOnly cookie | Web apps, security-focused |
| `true`            | sessionStorage  | Developing                 |

---

## Session Functions

### Server-side

```typescript
import {
  getSession,
  createSession,
  deleteSession,
} from "server/functions/session";

// Get session from token
const user = await getSession(token);

// Create new session
const token = await createSession(userId, sessionData);

// Delete session (logout)
await deleteSession(token);
```

### Client-side

```typescript
import { useSession } from 'src/_providers/sessionProvider';

function UserProfile() {
  const session = useSession();

  if (!session) return <LoginButton />;
  return <div>Welcome, {session.name}</div>;
}
```

---

## Multi-Session Behavior

```typescript
// config.ts
allowMultipleSessions: false; // Default

// When false:
// - User logs in on device A → Session A created
// - User logs in on device B → Session A deleted, Session B created
// - Device A's socket receives 'logout' event

// When true:
// - Both sessions remain active
// - Useful for: multiple browser tabs, phone + desktop
```

---

## Security Notes

1. **Tokens are random UUIDs** - Not predictable
2. **HttpOnly cookies** - Not accessible via JavaScript
3. **Session validation** - Every API/sync request validates token
4. **Automatic cleanup** - Redis TTL handles expiry
</file>

<file path="docs/ARCHITECTURE_SOCKET.md">
# Socket Architecture

> Socket.io-based real-time communication layer.

---

## Quick Reference

```typescript
// Client: Access socket instance
import { socket, waitForSocket } from "src/_sockets/socketInitializer";

await waitForSocket(); // Ensure connected
socket.emit("event", data);
```

---

## Core Events

| Event                 | Direction        | Purpose                      |
| --------------------- | ---------------- | ---------------------------- |
| `apiRequest`          | Client → Server  | RPC-style API calls          |
| `apiResponse-{index}` | Server → Client  | API response by index        |
| `sync`                | Client → Server  | Sync event to broadcast      |
| `syncEvent-{name}`    | Server → Clients | Broadcasted sync data        |
| `joinRoom`            | Client → Server  | Join a specific room         |
| `updateLocation`      | Client → Server  | Track user's current page    |
| `logout`              | Server → Client  | Force logout (other session) |

---

## Room System

```typescript
// Server-side: socket joins room
socket.join(roomCode);

// Server-side: broadcast to room
io.to(roomCode).emit("syncEvent-updateCounter", data);

// Client triggers room join
socket.emit("joinRoom", { roomCode: "game-123" });
```

Room codes are automatically extracted from URL paths:

- `/games/chess/room-abc` → room code = `room-abc`

---

## Connection State

```typescript
import { useSocketStatus } from 'src/_providers/socketStatusProvider';

function ConnectionIndicator() {
  const { connected, reconnecting } = useSocketStatus();

  if (!connected && reconnecting) return <Spinner />;
  if (!connected) return <Offline />;
  return <Online />;
}
```

---

## Activity Broadcasting

When `config.socketActivityBroadcaster = true`:

```typescript
// Other users in same room can see status
const { socketStatus } = useSocketStatus();
// socketStatus['user-id'] = { status: 'CONNECTED' | 'DISCONNECTED' | 'RECONNECTING' }
```

---

## Configuration

```typescript
// config.ts
const config = {
  backendUrl: 'http://localhost:80',
  socketActivityBroadcaster: false,  // Enable presence tracking
};

// .env
SERVER_IP=127.0.0.1
SERVER_PORT=80
```

---

## Error Handling

```typescript
socket.on("connect_error", (error) => {
  console.error("Connection failed:", error);
});

socket.on("disconnect", (reason) => {
  if (reason === "io server disconnect") {
    // Server forced disconnect - try reconnect
    socket.connect();
  }
});
```
</file>

<file path="docs/DEVELOPER_GUIDE.md">
# Developer Guide

> Getting started with LuckyStack development.

---

## Quick Start

### 1. Setup

```bash
# Install dependencies
npm install

# Copy config templates
cp configTemplate.txt config.ts
cp envTemplate.txt .env

# Edit .env with your credentials
# Edit config.ts with your settings
```

### 2. Start Development

```bash
# Terminal 1: Start backend
npm run server

# Terminal 2: Start frontend (Vite)
npm run client
```

### 3. Create Your First API

```typescript
// src/mypage/_api/hello.ts
import { AuthProps, SessionLayout } from "config";
import { Functions, ApiResponse } from "src/_sockets/apiTypes.generated";

export const auth: AuthProps = { login: false, additional: [] };

export interface ApiParams {
  data: { name: string };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data }: ApiParams): Promise<ApiResponse> => {
  return {
    status: "success",
    result: { message: `Hello, ${data.name}!` },
  };
};
```

Types are auto-generated! Just save the file and use:

```typescript
const result = await apiRequest({ name: "hello", data: { name: "World" } });
```

---

## Project Structure

```
luckystack/
├── src/                    # Frontend (React)
│   ├── _components/        # Shared UI components
│   ├── _functions/         # Client utilities
│   ├── _providers/         # React context providers
│   ├── _sockets/           # Socket client utilities
│   ├── _locales/           # i18n translations
│   ├── admin/              # Admin pages
│   └── {page}/             # Feature pages
│       ├── page.tsx        # Main page component
│       ├── _components/    # Page-specific components
│       ├── _api/           # API handlers for this page
│       └── _sync/          # Sync handlers for this page
│
├── server/                 # Backend (Node.js)
│   ├── auth/               # Authentication logic
│   ├── sockets/            # Socket event handlers
│   ├── functions/          # Shared server functions
│   ├── utils/              # Server utilities
│   ├── dev/                # Hot reload & type generation
│   └── server.ts           # Entry point
│
├── docs/                   # Architecture documentation
├── config.ts               # App configuration
└── .env                    # Environment variables
```

---

## Common Patterns

### Page with API and Sync

```
src/game/
├── page.tsx                # Main game UI
├── _components/
│   ├── Board.tsx
│   └── ScoreBoard.tsx
├── _api/
│   ├── createGame.ts       # POST - create new game
│   ├── getGameState.ts     # GET - fetch game state
│   └── deleteGame.ts       # DELETE - end game
└── _sync/
    ├── movePlayer_server.ts  # Server validates move
    └── movePlayer_client.ts  # Client processes move
```

### Using in Components

```tsx
import { apiRequest } from "src/_sockets/apiRequest";
import { syncRequest, upsertSyncEventCallback } from "src/_sockets/syncRequest";

function GameBoard() {
  const [state, setState] = useState(null);

  // Fetch initial state
  useEffect(() => {
    apiRequest({ name: "getGameState", data: { gameId } }).then((result) =>
      setState(result),
    );
  }, [gameId]);

  // Listen for moves
  useEffect(() => {
    upsertSyncEventCallback("movePlayer", ({ serverOutput }) => {
      setState((prev) => ({ ...prev, ...serverOutput }));
    });
  }, []);

  // Send a move
  const handleMove = (move) => {
    syncRequest({ name: "movePlayer", data: move });
  };

  return <Board onMove={handleMove} {...state} />;
}
```

---

## Hot Reload

The dev server watches for file changes and automatically:

1. **API files** (`_api/*.ts`) - Regenerates types in `apiTypes.generated.ts`
2. **Sync files** (`_sync/*.ts`) - Injects templates and updates types
3. **Components** - Vite HMR handles the rest

Just save and your types are updated!

---

## Testing APIs

### Via HTTP (curl/Postman)

```bash
# GET-style API
curl http://localhost/api/mypage/getGameState?gameId=123

# POST-style API
curl -X POST http://localhost/api/mypage/createGame \
  -H "Content-Type: application/json" \
  -d '{"name": "My Game"}'

# With auth
curl http://localhost/api/mypage/getGameState?gameId=123 \
  -H "Authorization: Bearer your-token-here"
```

### Via Browser Console

```javascript
// If socket is connected
socket.emit("apiRequest", {
  name: "api/mypage/hello",
  data: { name: "Test" },
  responseIndex: 999,
});

socket.on("apiResponse-999", console.log);
```

---

## Debugging

### Server Logs

Colorized console output:

- 🔵 **Blue** - API calls
- 🟢 **Green** - Success
- 🔴 **Red** - Errors
- 🟡 **Yellow** - Warnings
- 🟣 **Magenta** - HTTP requests

### Dev REPL

In server terminal, type commands directly:

```
> session.get('token-123')  // Check session
> io.sockets.sockets.size   // Connected sockets
```

### Sentry Integration

Errors are automatically captured if `SENTRY_DSN` is set in `.env`.

---

## Best Practices

1. **Keep APIs small** - One responsibility per file
2. **Use type inference** - Don't manually type API responses
3. **Handle errors** - Always return `{ status: 'error', message }` on failure
4. **Clean up callbacks** - Remove sync callbacks when component unmounts
5. **Use rooms** - Don't broadcast to everyone, use targeted rooms
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import reactX from 'eslint-plugin-react-x'
import eslintPluginUnicorn from 'eslint-plugin-unicorn'
import eslintPluginImportX from 'eslint-plugin-import-x'
import jsxA11y from 'eslint-plugin-jsx-a11y'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      ...tseslint.configs.strictTypeChecked,
      ...tseslint.configs.stylisticTypeChecked,
      js.configs.recommended,
      tseslint.configs.recommended,
      reactX.configs.recommended,
      eslintPluginUnicorn.configs['flat/recommended'],
      eslintPluginImportX.flatConfigs.recommended,
      eslintPluginImportX.flatConfigs.typescript,
      jsxA11y.flatConfigs.recommended,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
    },
    settings: {
      'import-x/resolver': {
        typescript: {
          alwaysTryTypes: true,
          project: ['./tsconfig.json', './tsconfig.app.json', './tsconfig.node.json', './tsconfig.server.json'],
        },
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      'unicorn/filename-case': [
        'error',
        {
          cases: {
            camelCase: true,
            pascalCase: true,
          },
        },
      ],
      'unicorn/prevent-abbreviations': 'off',
      'unicorn/no-null': 'off',
      'import-x/order': [
        'error',
        {
          groups: [
            'builtin',
            'external',
            'internal',
            'parent',
            'sibling',
            'index',
            'object',
            'type',
          ],
          'newlines-between': 'always',
          alphabetize: {
            order: 'asc',
            caseInsensitive: true,
          },
        },
      ],
    },
  },
  {
    files: [
      'src/**/*api/**/*.ts', 
      'src/**/*Api/**/*.ts', 
      'src/**/*sync/**/*.ts',
      'src/**/*Sync/**/*.ts'
    ],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
    },
  }
)
//npx eslint src/**/*.tsx
// ctrl + shift + p -> Restart TS server
</file>

<file path="server/dev/templates/sync_client_paired.template.ts">
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { SessionLayout } from '{{REL_PATH}}config';
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { Functions, SyncClientResponse, SyncClientInput, SyncServerOutput } from '{{REL_PATH}}src/_sockets/apiTypes.generated';

// Types are imported from the generated file based on the _server.ts definition
type PagePath = '{{PAGE_PATH}}';
type SyncName = '{{SYNC_NAME}}';

export interface SyncParams {
  clientInput: SyncClientInput<PagePath, SyncName>;
  serverOutput: SyncServerOutput<PagePath, SyncName>;
  user: SessionLayout; // session data from any user that is in the room
  functions: Functions; // contains all functions that are available on the server in the functions folder
  roomCode: string; // room code
}

export const main = async ({ user, clientInput, serverOutput, functions, roomCode }: SyncParams): Promise<SyncClientResponse> => {
  // PAIRED SYNC: Types are shared with the _server.ts file
  // clientInput type comes from _server.ts SyncParams
  // serverOutput type is inferred from _server.ts return value

  // Example: Only allow users on set page to receive the event
  // if (user?.location?.pathName === '/your-page') {
  //   return { status: 'success' };
  // }

  return {
    status: 'success',
    // Add any additional data to pass to the client
  };
};
</file>

<file path="server/dev/templates/sync_client_standalone.template.ts">
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { SessionLayout } from '{{REL_PATH}}config';
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { Functions, SyncClientResponse } from '{{REL_PATH}}src/_sockets/apiTypes.generated';


export interface SyncParams {
  clientInput: {
    // Define the data shape sent from the client e.g.
    // message: string;
  };
  // Note: No serverOutput in client-only syncs (no _server.ts file)
  user: SessionLayout; // session data from any user that is in the room
  functions: Functions; // contains all functions that are available on the server in the functions folder
  roomCode: string; // room code
}

export const main = async ({ user, clientInput, functions, roomCode }: SyncParams): Promise<SyncClientResponse> => {
  // CLIENT-ONLY SYNC: No server processing, runs for each client in the room

  // Example: Only allow users on set page to receive the event
  // if (user?.location?.pathName === '/your-page') {
  //   return { status: 'success' };
  // }

  return {
    status: 'success',
    // Add any additional data to pass to the client
  };
};
</file>

<file path="server/dev/templates/sync_server.template.ts">
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { AuthProps, SessionLayout } from '{{REL_PATH}}config';
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { Functions, SyncServerResponse } from '{{REL_PATH}}src/_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: true,
  additional: []
};

export interface SyncParams {
  clientInput: {
    // Define the data shape sent from the client e.g.
    // message: string;
    // targetUserId: string;
  };
  user: SessionLayout; // session data of the user who called the sync event
  functions: Functions; // functions object
  roomCode: string; // room code
}

export const main = async ({ clientInput, user, functions, roomCode }: SyncParams): Promise<SyncServerResponse> => {
  // THIS FILE RUNS JUST ONCE ON THE SERVER

  // Please validate clientInput here and dont just send the data back to the other clients
  // optional: database action or something else

  return {
    status: 'success',
    // Add any data you want to broadcast to clients
  };
};
</file>

<file path="server/functions/boardcaster.ts">
import { ioInstance } from "../../server/sockets/socket"
import { getSession } from "./session";

export default async function boardcaster({
  code,
  event,
  session,
  data,
  ignoreSelf
}: {
  code: string,
  event: string,
  session?: boolean,
  data?: any,
  ignoreSelf?: string
}) {
  const io = ioInstance;
  if (!io) { return; }

  const sockets = io.sockets.adapter.rooms.get(code);
  if (!sockets) { return; }


  for (const socketId of sockets || []) {
    const tempSocket = io.sockets.sockets.get(socketId as string);
    if (!tempSocket) { continue; }

    if (ignoreSelf || session) {

      const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
      const tempSessionToken = tempSocket.handshake.auth?.token
      const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1]
        : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
          : null;

      if (ignoreSelf == tempToken) {
        console.log(' skipping self emit ');
        continue;
      } //? we dont send the event to the client who called the event


      if (!tempToken) { continue; }
      const sessionData = await getSession(tempToken);

      tempSocket.emit(event, { ...data, session: sessionData });

    } else {
      tempSocket.emit(event, { ...data });
    }
  }

}
</file>

<file path="server/functions/redis.ts">
import Redis from 'ioredis';
import dotenv from 'dotenv';

dotenv.config(); 

//? here we create a Redis instance
const redis = new Redis({
  host: process.env.REDIS_HOST as string,
  port: parseInt(process.env.REDIS_PORT as string),
  ...(process.env.REDIS_PASSWORD && { password: process.env.REDIS_PASSWORD }),
  
  retryStrategy(times) {
    return Math.min(times * 50, 2000);
  },
});

redis.on('connect', async () => {
  console.log('Connected to Redis');

  if (process.env.NODE_ENV == 'development') { return; }

  const prefix = `${process.env.PROJECT_NAME}-games:`;
  await clearKeysWithPrefix(prefix);
});

redis.on('error', (err) => {
  console.error('Error connecting to Redis:', err);
});

async function clearKeysWithPrefix(prefix: string) {
  let cursor = '0';
  do {
    const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', `${prefix}*`, 'COUNT', 100);
    cursor = nextCursor;
    if (keys.length > 0) {
      // delete keys in bulk
      await redis.del(...keys);
      console.log(`Deleted Redis keys: ${keys.join(', ')}`);
    }
  } while (cursor !== '0');
}

export default redis;
</file>

<file path="server/functions/tryCatch.ts">
import { captureException } from '../utils/sentry';

/**
 * Wraps an async function with error handling.
 * Errors are automatically captured by Sentry (if enabled).
 * 
 * @param func - The async function to execute
 * @param params - Optional parameters to pass to the function
 * @param context - Optional context for Sentry error tracking
 * @returns Tuple of [error, result] - only one will be non-null
 * 
 * @example
 * ```typescript
 * const [error, users] = await tryCatch(
 *   async () => await prisma.user.findMany(),
 *   undefined,
 *   { operation: 'getUsers' }
 * );
 * 
 * if (error) {
 *   return { status: 'error', message: 'Failed to fetch users' };
 * }
 * return { status: 'success', users };
 * ```
 */
const tryCatch = async <T, P>(
  func: (values: P) => Promise<T> | T,
  params?: P,
  context?: Record<string, any>
): Promise<[Error | null, T | null]> => {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error) {
    // Capture error in Sentry with optional context
    captureException(error, context);
    return [error as Error, null];
  }
}

export { tryCatch }
</file>

<file path="server/sockets/socket.ts">
import dotenv from 'dotenv';
dotenv.config();

import handleApiRequest from "./handleApiRequest";
import { getSession, saveSession } from "../functions/session";
import { Server as SocketIOServer } from 'socket.io';
import handleSyncRequest from "./handleSyncRequest";
import allowedOrigin from '../auth/checkOrigin';
import { initAcitivityBroadcaster, socketConnected, socketDisconnecting, socketLeaveRoom } from './utils/activityBroadcaster';
import config, { SessionLayout } from '../../config';
import { extractTokenFromSocket } from '../utils/extractToken';

export type apiMessage = {
  name: string;
  data: object;
  responseIndex: number;
}

export type syncMessage = {
  name: string;
  data: object;
  cb: string;
  receiver: string;
  responseIndex?: number;
  ignoreSelf?: boolean;
}

export let ioInstance: SocketIOServer | null = null;

export default function loadSocket(httpServer: any) {

  //? here we create the SocketIOServer instance
  const io = new SocketIOServer(httpServer, {
    cors: {
      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      origin: (origin, callback) => {
        if (!origin || allowedOrigin(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
    },
    maxHttpBufferSize: 5 * 1024 * 1024, // 5 MB
  });

  ioInstance = io;

  console.log('SocketIO server initialized', 'green');

  //? when a client connects to the SocketIO server we extract their token and set up event handlers
  io.on('connection', (socket) => {
    const token = extractTokenFromSocket(socket);

    if (token) {
      socketConnected({ token, io });
    }

    socket.on('apiRequest', async (msg: apiMessage) => {
      handleApiRequest({ msg, socket, token });
    });
    socket.on('sync', async (msg: syncMessage) => {
      handleSyncRequest({ msg, socket, token });
    });
    socket.on('joinRoom', async (data) => {
      const { group, responseIndex } = data;
      if (!token) {
        socket.emit(`joinRoom-${responseIndex}`, { error: 'Not authenticated' });
        return;
      }
      const session = await getSession(token);
      if (!session) {
        socket.emit(`joinRoom-${responseIndex}`, { error: 'Session not found' });
        return;
      }
      await socket.join(group);
      await saveSession(token, { ...session, code: group });
      socket.emit(`joinRoom-${responseIndex}`);
      console.log(`Socket ${socket.id} joined group ${group}`, 'cyan');
    });

    socket.on('disconnect', async (reason) => {
      if (config.socketActivityBroadcaster && token) {
        socketDisconnecting({ token, socket, reason });
      } else {
        if (!token) { return; }
        console.log(`user disconnected, reason: ${reason}`, 'yellow');
      }
    });

    socket.on('updateLocation', async (newLocation) => {
      if (!token) { return; }
      console.log('updating location to: ', newLocation.pathName, 'yellow')

      let returnedUser: SessionLayout | null = null;
      if (config.socketActivityBroadcaster) {
        returnedUser = await socketLeaveRoom({ token, socket, newPath: newLocation.pathName });
      }

      if (!newLocation) { return; }
      const user = returnedUser || await getSession(token);
      if (!user) { return; }

      user.location = newLocation;
      return await saveSession(token, user);
    });

    if (config.socketActivityBroadcaster && token) {
      initAcitivityBroadcaster({ socket, token });
    }

    if (token) {
      socket.join(token);
    }

  });
  return io;
}
</file>

<file path="server/sockets/utils/activityBroadcaster.ts">
// ------------
// Activity Broadcaster
// ------------
// This module provides info about the users activty
// this is usefull to make a game to pause it for example when the user is not active

import { Server, Socket } from "socket.io";
import { deleteSession, getSession } from "../../functions/session";
import { ioInstance } from "../socket";
import { extractTokenFromSocket } from "../../utils/extractToken";
import type { SessionLayout } from "../../../config";

export const disconnectTimers = new Map<string, NodeJS.Timeout>();
export const disconnectReasonsWeIgnore: string[] = ['ping timeout'];
export const disconnectReasonsWeAllow: string[] = ['transport close', 'transport error'];
export const tempDisconnectedSockets = new Set<string>();
export const clientSwitchedTab = new Set<string>();

export const socketConnected = async ({
  token,
  io
}: {
  token: string,
  io: Server
}) => {
  const timer = disconnectTimers.get(token);
  if (timer) {
    console.log(`user came back with token: ${token}`, 'yellow');
    clearTimeout(timer);
    disconnectTimers.delete(token);
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else {
      console.log(`a user connected with token: ${token}`, 'cyan');
    }
  }

  const session = await getSession(token);
  const userId = session?.id || null;
  const code = session?.code || null;

  if (!code) { return; }
  if (!userId) { return; }

  informRoomPeers({ token, io, event: 'userBack', extraData: { ignoreSelf: true } });
}


export const socketLeaveRoom = async ({ token, socket, newPath }: {
  token: string | null,
  socket: Socket,
  newPath: string | null
}): Promise<SessionLayout | null> => {

  //? retrieve users session data
  if (!token) {
    console.log('trying to update room peers but no token provided', 'red');
    return null;
  }

  const user = await getSession(token);
  if (!user?.id) {
    console.log(`no session data for given token: ${token}`, 'red');
    return null;
  }

  const { pathName, searchParams } = user.location || {};



  /////////////
  //? EXAMPLE USAGE
  /////////////


  // console.log(`
  //   check1: ${pathName == '/games/test123'}
  //   check2: ${user.code}
  //   check3: ${!newPath || newPath !== pathName}
  // `, 'cyan');

  // //? if user is at a certain location we run a sync function to update the other players that are in the same room has him
  // if (
  //   pathName == '/games/test123' &&
  //   user.code &&
  //   (!newPath || newPath !== pathName)
  // ) {
  //   console.log('socket is leaving test123 game', 'cyan');
  //   handleSyncRequest({
  //     msg: { 
  //       name: 'sync/games/test123/playerLeave', 
  //       data: { gameCode: user.code, oldUser: user },
  //       cb: 'playerLeave',
  //       receiver: searchParams?.code, ignoreSelf: true
  //     },
  //     socket,
  //     token
  //   });
  //   socket.leave(user.code);
  // }

  return user;

}

const getDisconnectTime = ({
  token,
  reason
}: {
  token: string,
  reason: string | undefined
}) => {
  return clientSwitchedTab.has(token)
    ? 20000
    // ? 3000 
    : disconnectReasonsWeAllow.includes(reason ?? "NULL")
      ? 60000
      : 2000
}

export const socketDisconnecting = async ({
  token,
  reason,
  socket
}: {
  token: string,
  reason: string,
  socket: Socket
}) => {

  if (disconnectReasonsWeIgnore.includes(reason)) {
    console.log(`user disconnected but we ignore it, reason: ${reason}`, 'yellow');
    return;
  }

  if (!token) { return; }
  if (!tempDisconnectedSockets.has(token)) {
    tempDisconnectedSockets.add(token);
  } else {
    return; //? if the user is already in the tempDisconnectedSockets array we ignore the disconnect event
  }

  const time = getDisconnectTime({ token, reason });

  let deleteSessionOnDisconnect = true;
  if (clientSwitchedTab.has(token)) {
    deleteSessionOnDisconnect = false;
    clientSwitchedTab.delete(token);
  }

  console.log(`user disconnected, reason: ${reason}, timer: ${time / 1000} seconds`, 'yellow');

  const timeout = setTimeout(async () => {
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else { return; } //? if the user has reconnected we dont run the logout function

    if (disconnectTimers.get(token) !== timeout) { return };

    await socketLeaveRoom({ token, socket, newPath: null });

    //? we only delete the session if the user disconnected themself, it the server kicked them it means that they were kicked from a game
    if (deleteSessionOnDisconnect) {
      await deleteSession(token);
    }

    console.log(`user fully disconnected, reason: ${reason}, timer : ${time / 1000} seconds, deleteSessionOnDisconnect: ${deleteSessionOnDisconnect}`, 'yellow');
  }, time);

  if (disconnectTimers.has(token)) {
    clearTimeout(disconnectTimers.get(token)!);
    disconnectTimers.delete(token);
  }
  disconnectTimers.set(token, timeout);

}

const informRoomPeers = async ({
  token,
  io = ioInstance,

  event,
  extraData,
}: {
  token: string,
  io?: Server | null

  event: 'userAfk' | 'userBack',
  extraData?: any
}) => {
  if (!io) {
    console.log('no io instance found to inform room peers', 'red');
    return;
  }

  const session = await getSession(token);
  if (!session || !session.code) { return; }

  const roomSockets = io.sockets.adapter.rooms.get(session.code);
  console.log(roomSockets);

  for (const socketId of roomSockets || []) {
    const tempSocket = io.sockets.sockets.get(socketId as string);
    if (!tempSocket) { continue; }

    if (extraData?.ignoreSelf) {
      console.log(' skipping self emit ');

      const tempToken = extractTokenFromSocket(tempSocket);

      if (token == tempToken) { continue; } //? we dont send the event to the client who called the event
    }

    if (event == 'userAfk') {
      console.log({ userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
      tempSocket?.emit('userAfk', { userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
    } else if (event == 'userBack') {
      tempSocket?.emit('userBack', { userId: session.id });
    }
  }
}

export const initAcitivityBroadcaster = ({
  token,
  socket
}: {
  token: string,
  socket: Socket,
}) => {
  socket.on("intentionalDisconnect", async () => {
    clientSwitchedTab.add(token);
    const time = getDisconnectTime({ token, reason: undefined });

    await informRoomPeers({ token, event: 'userAfk', extraData: { time } });

    socket.disconnect(false);
  });
}
</file>

<file path="server/utils/extractToken.ts">
import { Socket } from 'socket.io';

/**
 * Extract the authentication token from a Socket.io connection.
 * 
 * Checks environment variable `VITE_SESSION_BASED_TOKEN` to determine where to look:
 * - `true`: Token is in `socket.handshake.auth.token` (sessionStorage on client)
 * - `false`: Token is in cookies via `socket.handshake.headers.cookie`
 * 
 * @param socket - The Socket.io socket instance
 * @returns The token string or null if not found
 * 
 * @example
 * ```typescript
 * import { extractTokenFromSocket } from '../utils/extractToken';
 * 
 * io.on('connection', (socket) => {
 *   const token = extractTokenFromSocket(socket);
 *   if (token) {
 *     // User has a token
 *   }
 * });
 * ```
 */
export const extractTokenFromSocket = (socket: Socket): string | null => {
  const cookie = socket.handshake.headers.cookie;
  const sessionToken = socket.handshake.auth?.token;

  // Session-based token (stored in sessionStorage on client)
  if (process.env.VITE_SESSION_BASED_TOKEN === 'true') {
    return sessionToken ?? null;
  }

  // Cookie-based token
  if (process.env.VITE_SESSION_BASED_TOKEN === 'false' && cookie) {
    // Parse the token from cookie string "token=abc123; other=value"
    const tokenCookie = cookie
      .split('; ')
      .find(row => row.startsWith('token='));

    return tokenCookie?.split('=')[1] ?? null;
  }

  // Fallback: try both methods
  return sessionToken ?? (cookie?.split('=')[1]) ?? null;
};
</file>

<file path="server/utils/serveAvatars.ts">
import path from "path";
import { access } from 'fs/promises';
import fs from "fs";
import { ServerResponse } from "http";

export const serveAvatar = async ({ 
  routePath,
  res,
}: {
  routePath: string;
  res: ServerResponse;
}) => {
  const uploadsFolder = path.join(process.cwd(), "uploads");
      
  // Always append .webp since that's the stored format
  const fileId = path.basename(routePath, path.extname(routePath)); // remove any extension if present
  const fileName = `${fileId}.webp`;
  const filePath = path.join(uploadsFolder, fileName);

  if (!fileId) return;

  try {
    await access(filePath)

    res.writeHead(200, {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=86400",
    });

    const readStream = fs.createReadStream(filePath);
    readStream.pipe(res);
  } catch (err) {
    // console.log('File not found:', err, 'red');
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("File not found");
  };

  return;
}
</file>

<file path="src/_components/Icon.tsx">
interface Props {
	name: string,
	size?: string,
	weight?: string,
  customClasses?: string,
  onClick?: () => void
}

export default function Icon({ name, size, weight, customClasses, onClick }: Props) {
  if (!name) return null

  return (
    <span
      style={{ fontSize: size ?? '20px', fontWeight: weight ?? 'lighter' }}
      className={`material-icons select-none ${customClasses ?? ''}`}
      onClick={onClick}
      onKeyDown={(e) => { if (onClick && (e.key === 'Enter' || e.key === ' ')) onClick(); }}
      role={onClick ? 'button' : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {name}
    </span>
  )
}
</file>

<file path="src/_components/LocationProvider.tsx">
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

import { updateLocationRequest } from 'src/_sockets/socketInitializer';

export default function LocationProvider({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  
  useEffect(() => {
    //? when the user changes the url, update the location in the users session data on the server, also update navbar from default tempalte
    const searchParams: Record<string, string> = {};
    for (const [key, value] of new URLSearchParams(location.search)) {
      searchParams[key] = value;
    }
    const locationObj = {
      pathName: location.pathname,
      searchParams
    }

    void updateLocationRequest({ location: locationObj })
  }, [location]);

  //? Outlet is all the child components in the browser router
  return (
    <>
      {children}
    </>
  );
}
</file>

<file path="src/_functions/middlewareHandler.ts">
//? here you can add your own route
//? return an object with the success key set to true if the user is allowed to access the route
//? return an object with the redirect key set to the path you want to redirect the user to if you want to redirect the user to a different page
//? return nothing if the user is not allowed to access the route and it will be send back to its previous page
//? if you dont add your page in here it will allow the user to access the page
import { SessionLayout } from "config";
import notify from "src/_functions/notify";

// @ts-ignore // we use ts-ignore because we dont use the searcParams in the example and this will cause a bundle error
export default function middlewareHandler({ location, searchParams, session }: { location: string, searchParams: Record<string, any>, session: SessionLayout | null }) {
  console.log(session)

  switch (location) {
    case '/test':
      if (session?.email && session?.provider) {
        return { success: true };
      }
      return { redirect: '/login' };

    case '/admin':
      if (session?.email && session?.provider && session?.admin === true) {
        return { success: true };
      } else if (!session?.email || !session?.provider) {
        return { redirect: '/login' };
      } else if (!session?.admin) {
        notify.error({ key: 'middleware.notAdmin' });
      }
      return

    case '/games/boerZoektVrouw':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    case '/home':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    case '/games':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    case '/examples':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    default:
      return { success: true };
  }
}
</file>

<file path="src/examples/_api/adminOnly.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, ApiResponse } from '../../../src/_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: true,
  additional: [
    { key: 'admin', value: true }
  ]
};

export interface ApiParams {
  data: {};
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ user }: ApiParams): Promise<ApiResponse> => {
  return {
    status: 'success',
    result: {
      message: `Welcome Admin ${user.name}! This is a protected endpoint.`,
      adminInfo: {
        userId: user.id,
        email: user.email,
        isAdmin: true,
        accessedAt: new Date().toISOString()
      }
    }
  };
};
</file>

<file path="src/examples/_api/publicApi.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, ApiResponse } from '../../../src/_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: false,
  additional: [

  ]
};

export interface ApiParams {
  data: {
    message: string;
  };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {
  console.log("received message: " + data.message);
  return {
    status: 'success',
    result: {
      message: 'This API can be called without logging in!',
      serverTime: Date.now()
    }
  };
};
</file>

<file path="src/examples/_api/toggleAdmin.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, ApiResponse } from '../../../src/_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: true,
};

export interface ApiParams {
  data: {};
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {
  const { prisma, saveSession } = functions;

  // Toggle admin status
  const newAdminStatus = !user.admin;

  // Update in database
  await prisma.user.update({
    where: { id: user.id },
    data: { admin: newAdminStatus }
  });

  // Update session
  const updatedUser = { ...user, admin: newAdminStatus };
  await saveSession(user.token, updatedUser);

  return {
    status: 'success',
    result: {
      message: `Admin status toggled to: ${newAdminStatus}`,
      admin: newAdminStatus,
      previousStatus: user.admin
    }
  };
};
</file>

<file path="src/settings/_api/updateUser.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, ApiResponse } from '../../../src/_sockets/apiTypes.generated';
import sharp from 'sharp';
import path from 'path';

// Set the request limit per minute. Set to false to use the default config value config.rateLimiting
export const rateLimit: number | false = 20;

// HTTP method for this API. If not set, inferred from name (get* = GET, delete* = DELETE, else POST)
export const httpMethod: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'POST';

export const auth: AuthProps = {
  login: true,
  additional: []
};

export interface ApiParams {
  data: {
    name?: string;
    theme?: 'light' | 'dark';
    language?: string;
    avatar?: string;
  };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {

  const { avatar, name, theme, language } = data;

  if (avatar) {
    console.log(avatar)
    const matches = avatar.match(/^data:(.+);base64,(.+)$/);
    if (matches) {
      const base64Data = matches[2];
      const buffer = Buffer.from(base64Data, "base64");

      // save as WebP under user's ID
      const fileName = `${user.id}.webp`;
      const filePath = path.join(process.cwd(), "uploads", fileName);

      try {
        await sharp(buffer)
          .webp({ quality: 80 }) // adjust quality if you want
          .toFile(filePath);

        console.log(`✅ Avatar saved for ${user.name} at ${filePath}`);
      } catch (err) {
        console.error("Error saving avatar:", err);
        return { status: "error" };
      }
    } else { console.log("failed to upload new avatar") }
  }

  let newData = {};

  if (avatar) newData = { ...newData, avatar: `${user.id}` }
  if (name) newData = { ...newData, name }
  if (theme) newData = { ...newData, theme }
  if (language) newData = { ...newData, language }

  //? here we can assume the avatar was uploaded successfully if avatar !=  null

  console.log(user)
  if (!user.token) return { status:'error' }

  await functions.prisma.user.update({
    where: { id: user.id },
    data: newData
  })

  await functions.saveSession(user.token, {...user, ...newData});

  return { status: 'success', result: {} }
};
</file>

<file path="tailwind.config.js">
module.exports = {
  darkMode: "class",
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {}
    },
  }
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,
    
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "./",
    "paths": {
      "src/*": ["src/*"],
      "config": ["./config.ts"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": [ // this excludes files from being build
    "src/**/api",                    // exclude any api folder
    "src/**/sync/*_server.ts",       // only exclude server_*.ts files inside sync folders
    "src/**/sync/*_client.ts",       // only exclude server_*.ts files inside sync folders
    "src/**/sync/*_server.js",       // (optional) in case you have JS mixed in
    "src/**/sync/*_client.js",       // (optional) in case you have JS mixed in
  ]

}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" },
    { "path": "./tsconfig.server.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="tsconfig.server.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "lib": ["ES2022"],
    "downlevelIteration": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist/server",
    "resolveJsonModule": true,
    "types": ["node"],
    "sourceMap": true
  },
  "include": ["server/**/*"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path';
// import tsconfigPaths from 'vite-tsconfig-paths'

// https://vite.dev/config/
export default defineConfig({
  base: '/',
  plugins: [
    react(),
    // tsconfigPaths()
  ],
  build: {
    rollupOptions: {
      external: (id) => { // this is just for the server side to tell these files will be available at runtime, to ignore files in build process go to tsconfig.app.json
        // Match if path includes /api/
        if (/\/api\//.test(id)) return true;

        // Ignore files in a sync folder ending with _server.ts
        if (/\/sync\/.*\/.*_server\.ts$/.test(id) || /\/sync\/.*_server\.ts$/.test(id)) return true;

        return false;
      },
    },
    target: 'esnext', // This makes sure the server redirects all 404s to index.html
  },
  resolve: {
    alias: {
      'src': path.resolve(__dirname, './src'),
      'config': path.resolve(__dirname, './config'),
    },
  },
  server: {
    watch: {
      usePolling: true,
      ignored: [
        "**/src/**/**/*{api,sync}/**"
      ]
    },
  }
})
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

.env
node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

config.ts
config

uploads/**

# Auto-generated types (regenerated on dev server start)
apiTypes.generated.ts
</file>

<file path="configTemplate.txt">
import { PrismaClient } from "@prisma/client";

const config = {
  // backendUrl: 'https://your.domain.com', //* the url of the backend server
  backendUrl: 'http://localhost:80', //* the url of the backend server

  dev: true, //* if true then we get extra console logs
  loginPageUrl: '/login', //* url the client is redirected to when the user is not authenticate
  loginRedirectUrl: '/test', //* url the client is redirected to after logging in
  defaultLanguage: 'en', //* default language if the session data doesnt include it, this is used with the notify system with the json files in the localed folder
  defaultTheme: 'dark', //* the default theme the client uses when the user hasnt set a theme yet
  mobileConsole: false, //* if true then there is a extra console you can open on any device (including mobile)
  sessionExpiryDays: 7, //* the number of days a session is valid

  //? if true than we store the token in session (unsecure but nice for development)
  //? when true you can open multiple windows and login into different user accounts so you can test certain features
  allowMultipleSessions: false,
  
  //? if false syncing works to users in your room but they wont know who they are sycning to
  //? if true on the client we know the activity status of all users in the same room
  //? this is usefull for multiplayer games to e.g. pause the game when a user is afk
  //? this data is stored in socketStatus (context provider)
  socketActivityBroadcaster: false
}
//* these values are optional to have in the session object, used for type declartion after an apiRequest on the client
export interface SessionLayout {
  id: string;
  name: string;
  email: string;
  provider: string;
  admin: boolean;
  avatar: string;
  avatarFallback: string;
  language: string;
  theme: 'light' | 'dark';
  createdAt: Date;
  updatedAt: Date;
  token: string;
  location?: {
    pathName: string;
    searchParams: {
      [key: string]: string;
    };
  };
};

export interface AuthProps {
  login: boolean; //* if true then the user needs to have an id in the session object
  additional?: { //* if true then the user needs to have the additional keys in the session object with the condition
    key: keyof SessionLayout; //* the key of the session object
    value?: any //* the exact value the key needs to have. this is a strict comparison
    type?: 'string' | 'number' | 'boolean'; //* the type of the key. this is a strict comparison
    nullish?: boolean; //* if true then the key needs to be null or undefined, if false then the key needs to be not null and not undefined
    mustBeFalsy?: boolean; //* if true than the passes key needs to be a false value such as false, 0, -0, 0n, "", null, undefined or NaN, if false then the key needs to be a true value such as true, 1, 'a' or any other value
  }[]
}

interface ServerFunctions {
  prisma: PrismaClient;

  saveSession: (token: string, data: any) => Promise<boolean>;
  getSession: (token: string) => Promise<any | null>;
  deleteSession: (token: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;
  sleep: (ms: number) => Promise<void>;

  [key: string]: any; // allows you to call functions you made yourself, autocomplete wont work for your own functions if you dont add them here
};


export interface ServerSyncProps {
  clientData: any;
  functions: ServerFunctions;
  user: SessionLayout;
}

export interface ClientSyncProps extends ServerSyncProps {
  serverOutput: any;
}

export const providers = ['credentials', 'google', 'github', 'facebook', 'discord'];

export default config;
export const { backendUrl, dev, loginPageUrl, loginRedirectUrl, defaultLanguage, mobileConsole } = config;
</file>

<file path="docs/ARCHITECTURE_API.md">
# API Architecture

> Type-safe API request system with WebSocket-first architecture and HTTP fallback.

---

## Quick Reference

```typescript
// Client-side API call
const result = await apiRequest({
  name: "getUserData",
  data: { userId: "123" },
  abortable: true, // Optional: auto-cancels if called again before response
});

// HTTP fallback (same API, no WebSocket needed)
// GET /api/examples/getUserData?userId=123
// POST /api  with { name: 'api/examples/getUserData', data: { userId: '123' } }
```

---

## File Structure

```
src/
├── {page}/_api/
│   ├── {apiName}.ts          # Your API handler
│   └── ...
└── _sockets/
    ├── apiRequest.ts         # Client-side API caller
    └── apiTypes.generated.ts # Auto-generated types
```

---

## Creating an API

### 1. Create the file

template is injected

```typescript
// src/examples/_api/getUserData.ts
import { AuthProps, SessionLayout } from "config";
import { Functions, ApiResponse } from "src/_sockets/apiTypes.generated";

// Rate limit: requests per minute (false = use global config)
export const rateLimit: number | false = 60;

// HTTP method (optional - inferred from name if not set)
// export const httpMethod: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET';

export const auth: AuthProps = {
  login: true, // Require authentication
  additional: [], // Extra requirements: 'admin', etc.
};

export interface ApiParams {
  data: {
    userId: string; // Input from client
  };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({
  data,
  user,
  functions,
}: ApiParams): Promise<ApiResponse> => {
  const userData = await functions.prisma.user.findUnique({
    where: { id: data.userId },
  });

  return {
    status: "success",
    result: userData,
  };
};
```

### 2. Use from client

```typescript
// Types are auto-generated - full autocomplete!
const result = await apiRequest({
  name: "getUserData",
  data: { userId: "123" },
});

if (result.status === "success") {
  console.log(result.result); // Typed correctly
}
```

---

## HTTP API Access

APIs are accessible via HTTP for testing, webhooks, or non-socket clients.

### RESTful Routes

Examples:

- `GET /api/examples/getUserData?userId=123`
- `POST /api/examples/createUser`
- `PUT /api/settings/updateProfile`
- `DELETE /api/examples/deleteUser`

### Method Inference

If `httpMethod` is not exported, it's inferred from the API name:

| Name Prefix                  | Inferred Method |
| ---------------------------- | --------------- |
| `get*`, `fetch*`, `list*`    | GET             |
| `delete*`, `remove*`         | DELETE          |
| `update*`, `edit*`, `patch*` | PUT             |
| Everything else              | POST            |

### Authentication

Include token via:

- **Cookie**: `token=your-token` (set automatically on login)
- **Header**: `Authorization: Bearer your-token`

---

## Abort Controller

GET-style APIs automatically use abort controllers to cancel in-flight requests.

```typescript
// These automatically cancel previous calls if called again:
await apiRequest({ name: 'getUserData', data: {...} });

// Explicit control:
await apiRequest({ name: 'createUser', data: {...}, abortable: true });  // Force
await apiRequest({ name: 'getUser', data: {...}, abortable: false });    // Disable
```

## Offline Request Queue

When the socket is disconnected or the browser is offline, `apiRequest` automatically queues requests in memory. The queue flushes on reconnect or when the browser comes back online. Aborted requests are removed from the queue.

## Rate Limiting

Configure globally in `config.ts`:

```typescript
rateLimiting: {
  defaultApiLimit: 60,   // Requests per minute per user
  defaultIpLimit: 100,   // Per-IP limit (unauthenticated)
  windowMs: 60000,       // 1 minute window
}
```

Or per-API:

```typescript
// In any _api/*.ts file
export const rateLimit = 30; // Override global
export const rateLimit = false; // Disable for this API
```
</file>

<file path="docs/ARCHITECTURE_SYNC.md">
# Sync Architecture

> Real-time event broadcasting between clients using rooms.

---

## Quick Reference

```typescript
// Client A sends sync event
await syncRequest({
  name: "updateCounter",
  data: { amount: 5 },
  roomCode: "game-room-123",
});

// Client B receives (via callback)
upsertSyncEventCallback("updateCounter", ({ clientOutput, serverOutput }) => {
  console.log("Counter updated:", serverOutput.newValue);
});
```

---

## File Structure

```
src/
├── {page}/_sync/
│   ├── {syncName}_server.ts    # Runs on the server just once
│   ├── {syncName}_client.ts    # Runs on the server for each client
│   └── ...
└── _sockets/
    ├── syncRequest.ts          # Client-side sync caller
    └── apiTypes.generated.ts   # Auto-generated types
```

---

## Creating a Sync Event

### 1. Server handler (optional)

```typescript
// src/examples/_sync/updateCounter_server.ts
import { AuthProps, SessionLayout } from "../../../config";
import {
  Functions,
  SyncServerResponse,
} from "../../../src/_sockets/apiTypes.generated";

export const auth: AuthProps = {
  login: true,
  additional: [],
};

export interface SyncParams {
  clientInput: {
    // Define the data shape sent from the client e.g.
    amount: number;
  };
  user: SessionLayout; // session data of the user who called the sync event
  functions: Functions; // functions object
  roomCode: string; // room code
}

export const main = async ({
  clientInput,
  user,
  functions,
  roomCode,
}: SyncParams): Promise<SyncServerResponse> => {
  // THIS FILE RUNS JUST ONCE ON THE SERVER

  // Please validate clientInput here and dont just send the data back to the other clients
  // optional: database action or something else

  return {
    status: "success",
    newValue: clientInput.amount + 1,
    // Add any data you want to broadcast to clients
  };
};
```

### 2. Client handler (optional)

```typescript
import { SessionLayout } from "../../../config";
import {
  Functions,
  SyncClientResponse,
  SyncClientInput,
  SyncServerOutput,
} from "../../../src/_sockets/apiTypes.generated";

// Types are imported from the generated file based on the _server.ts definition
type PagePath = "examples";
type SyncName = "test1";
export interface SyncParams {
  clientInput: SyncClientInput<PagePath, SyncName>;

  serverOutput: SyncServerOutput<PagePath, SyncName>;
  // Note: No serverOutput in client-only syncs (no _server.ts file)
  user: SessionLayout; // session data from any user that is in the room
  functions: Functions; // contains all functions that are available on the server in the functions folder
  roomCode: string; // room code
}

export const main = async ({
  user,
  clientInput,
  serverOutput,
  functions,
  roomCode,
}: SyncParams): Promise<SyncClientResponse> => {
  // CLIENT-ONLY SYNC: No server processing, runs for each client in the room

  // Example: Only allow users on set page to receive the event
  // if (user?.location?.pathName === '/your-page') {
  //   return { status: 'success' };
  // }

  return {
    status: "success",
    // Add any additional data to pass to the client
  };
};
```

## Receiving Sync Events

```typescript
import { upsertSyncEventCallback } from "src/_sockets/syncRequest";

// Register a callback (upsert = updates if exists)
upsertSyncEventCallback("updateCounter", ({ clientOutput, serverOutput }) => {
  // clientOutput = result from _client.ts
  // serverOutput = result from _server.ts
  updateUI(serverOutput.newValue);
});
```

## Offline Request Queue

When the socket is disconnected or the browser is offline, `syncRequest` queues requests in memory and flushes on reconnect or when the browser comes back online.

---

### Room-specific sync

```typescript
// Only users in 'game-room-123' receive this
await syncRequest({
  name: "moveChessPiece",
  data: { from: "e2", to: "e4" },
  roomCode: "game-room-123",
});
```

---

---

## Type System

| Property       | Source                         | Description              |
| -------------- | ------------------------------ | ------------------------ |
| `clientInput`  | `data` param in syncRequest    | What client sends        |
| `serverOutput` | `_server.ts` return            | Server processing result |
| `clientOutput` | `_client.ts` clientMain return | Client processing result |
</file>

<file path="envTemplate.txt">
# NODE_ENV=production # development | production
NODE_ENV=development # development | production
# VITE_SESSION_BASED_TOKEN=false # when true we store the token in the sessionStorage wich allows you to upen multiple tabs at the same time and have different session data on there, if false we use cookies
VITE_SESSION_BASED_TOKEN=true # when true we store the token in the sessionStorage wich allows you to upen multiple tabs at the same time and have different session data on there, if false we use cookies
# SECURE=true # when true we use https else http, make sure your nginx server is configured to use https if this is set to true
SECURE=false # when true we use https else http, make sure your nginx server is configured to use https if this is set to true
PROJECT_NAME=YOUR_PROJECT_NAME # used for the redis cache so that when using the same template other session data will not collide with this one
# example would be that if you login here with a certain email that on a different project you will not be logged out automaticly cause it is a different project (on the same project you will be logged out)

SERVER_IP=localhost # this should either be localhost if using a reverse proxy or 0.0.0.0 if you want other devices on your network to access the server to test mobile support for example or networking between devices. have it set to the ip when calling the node server directly
# SERVER_PORT=3000 # 80 for localhost and for production any port you like e.g 3000
SERVER_PORT=80 # 80 for localhost and for production any port you like e.g 3000

# DNS is used to redirect the user to the server when they login with oauth
# so when NODE_ENV is set to development it should be someting like http://localhost:5173
# and when NODE_ENV is set to production it should be someting like https://random.dns.com
# DNS=https://random.dns.com
DNS=http://localhost:5173

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=
REDIS_PORT=6379

#here you can add urls that are allowed to communicate with the server, such as oauth urls
#when adding new urls make sure to saperate them with a ','
EXTERNAL_ORIGINS=https://accounts.google.com,https://github.com,https://www.facebook.com,https://discord.com

#https://console.cloud.google.com/apis/credentials
# create a new project, go to credentials, create OAuth clientId
# scroll down to Authorized redirect URIs and add the server ip port and than /auth/callback/google
# so for dev it should be http://localhost:80/auth/callback/google
# copy the google client id and secret.

#USED FOR PRODUCTION
GOOGLE_CLIENT_ID=xxxxx
GOOGLE_CLIENT_SECRET=xxxxx
#USED FOR DEVELOPMENT
DEV_GOOGLE_CLIENT_ID=xxxxx
DEV_GOOGLE_CLIENT_SECRET=xxxxx



#https://github.com/settings/developers
# create a new OAuth app, homepage url can be http://localhost:80/auth/callback/github
# callback url should be ip port and than /auth/callback/github, so for dev it should be http://localhost:80/auth/callback/github
# than just copy the client id and secret

#USED FOR PRODUCTION
GITHUB_CLIENT_ID=xxxxxxx
GITHUB_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_GITHUB_CLIENT_ID=xxxxxxx
DEV_GITHUB_CLIENT_SECRET=xxxxxxx



#https://developers.facebook.com/async/registration/dialog/?src=default
# go to my apps and it want you to create an account, after creating an account you should be able to create a new app
# go to use cases and click customize on 'authenticate and request data from users with facebook login' and then click on quickstart
# after quick setup go to apps ettings - basics and copy the app id and app secret, the callback url for localhost is automaticly handeld but for production you need to change this
# you can change this on use cases and click on 'authenticate and request data from users with facebook login' and then click on 'settings' and go down to valid oauth redirect urls

#USED FOR PRODUCTION
FACEBOOK_CLIENT_ID=xxxxxxx
FACEBOOK_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_FACEBOOK_CLIENT_ID=xxxxxxx
DEV_FACEBOOK_CLIENT_SECRET=xxxxxxx



#https://discord.com/developers/applications
# create a new application, navigate to OAuth2, copy the client id and secret
# add a redirects url, for dev it should be http://localhost:80/auth/callback/discord

#USED FOR PRODUCTION
DISCORD_CLIENT_ID=xxxxxxx
DISCORD_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_DISCORD_CLIENT_ID=xxxxxxx
DEV_DISCORD_CLIENT_SECRET=xxxxxxx



# https://www.linkedin.com/developers/apps/new
# requires you to have an company page wich requires id verification
# LINKEDIN_CLIENT_ID=aaaaaaaaaaa
# LINKEDIN_CLIENT_SECRET=aaaaaaaaaaa



# requires a $99 subscription to create a App id
# APPLE_CLIENT_ID=a
# APPLE_CLIENT_SECRET=a



# only supports businness accounts so you can add it yourself if you want but not worth my time right now
# INSTAGRAM_CLIENT_ID=a
# INSTAGRAM_CLIENT_SECRET=a



# currently switching from twitter to X and no clear documentation in my opinion 
# X_CLIENT_ID=a
# X_CLIENT_SECRET=a

# ============================================
# DATABASE CONFIGURATION
# ============================================
# Set the DATABASE_URL based on your chosen database provider.
# This must match the datasource in prisma/schema.prisma
# 
# After changing providers:
# 1. Update prisma/schema.prisma datasource
# 2. Update DATABASE_URL below
# 3. Run: npx prisma generate && npx prisma db push
# ============================================

# --- MYSQL (Default) ---
DATABASE_URL="mysql://root:password@localhost:3306/luckystack"

# --- POSTGRESQL ---
# DATABASE_URL="postgresql://postgres:password@localhost:5432/luckystack"

# --- MONGODB ---
# DATABASE_URL="mongodb://localhost:27017/luckystack"
# With some query parameters DATABASE_URL="mongodb://localhost:27017/luckystack?authSource=admin&replicaSet=rs0"

# --- SQLITE (No server needed - great for development) ---
# DATABASE_URL="file:./dev.db"

# ============================================
# SENTRY ERROR MONITORING (Optional)
# ============================================
# Get your DSN from https://sentry.io
# Create a project for Node.js (server) and React (client)

# Server-side Sentry DSN
SENTRY_DSN=
# Set to 'true' to enable Sentry in development
SENTRY_ENABLED=false

# Client-side Sentry DSN (must be prefixed with VITE_)
VITE_SENTRY_DSN=
# Set to 'true' to enable Sentry in development
VITE_SENTRY_ENABLED=false
</file>

<file path="package.json">
{
  "name": "lucky-stack-v2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "client": "tsx scripts/clearServerRequests.ts && vite --host",
    "server": "npx tsx server/server.ts",
    "liveServer": "npx tsx --watch server/server.ts",
    "lint": "eslint src/**/*.tsx",
    "buildClient": "tsc -b && vite build",
    "buildServer": "tsx scripts/generateServerRequests.ts && tsx scripts/bundleServer.ts",
    "build": "tsx scripts/generateServerRequests.ts && npm run buildClient && tsx scripts/bundleServer.ts",
    "prod": "node dist/server.js",
    "production": "node dist/server.js"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^7.0.1",
    "@fortawesome/free-brands-svg-icons": "^7.0.1",
    "@fortawesome/free-regular-svg-icons": "^7.0.1",
    "@fortawesome/free-solid-svg-icons": "^7.0.1",
    "@fortawesome/react-fontawesome": "^3.0.2",
    "@prisma/client": "^6.5.0",
    "@sentry/node": "^10.35.0",
    "@sentry/react": "^10.35.0",
    "@tailwindcss/postcss": "^4.0.17",
    "bcrypt": "^5.1.1",
    "chokidar": "^4.0.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "eslint-plugin-import-x": "^4.16.1",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-unicorn": "^62.0.0",
    "fs": "^0.0.1-security",
    "ioredis": "^5.6.0",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.540.0",
    "path": "^0.12.7",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.4.0",
    "repl": "^0.1.3",
    "sharp": "^0.34.3",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.2",
    "url": "^0.11.4",
    "uuid": "^11.1.0",
    "validator": "^13.15.0",
    "vconsole": "^3.15.1",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@rollup/plugin-alias": "^5.1.1",
    "@types/bcrypt": "^5.0.2",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@types/validator": "^13.15.1",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.21.0",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-react-dom": "^1.48.4",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "eslint-plugin-react-x": "^1.48.4",
    "globals": "^15.15.0",
    "postcss": "^8.5.6",
    "prisma": "^6.5.0",
    "tailwindcss": "^4.1.11",
    "tsx": "^4.19.3",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^4.0.17"
  }
}
</file>

<file path="prisma/schema.prisma">
// ============================================
// LUCKYSTACK DATABASE CONFIGURATION
// ============================================
// Prisma supports multiple database providers. 
// Uncomment ONE datasource block below based on your choice.
// After changing, run: npx prisma generate && npx prisma db push
// ============================================

generator client {
  provider = "prisma-client-js"
}

// ============================================
// DATABASE PROVIDER OPTIONS
// ============================================
// Uncomment the datasource for your database. Only ONE should be active!
// ============================================

// --- MYSQL (Default) ---
// datasource db {
//   provider = "mysql"
//   url      = env("DATABASE_URL")
// }

// --- POSTGRESQL ---
// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// --- MONGODB ---
// Note: MongoDB requires different schema syntax (see model comments below)
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// --- SQLITE (Development only - no server needed) ---
// datasource db {
//   provider = "sqlite"
//   url      = "file:./dev.db"
// }

// ============================================
// USER MODEL
// ============================================
// This is the default user model. Extend as needed.
// 
// Database-specific syntax differences:
// 
// MySQL/PostgreSQL:
//   id        String  @id @default(uuid())
//   avatar    String  @db.VarChar(512)
// 
// MongoDB:
//   id        String  @id @default(auto()) @map("_id") @db.ObjectId
//   avatar    String
// 
// SQLite:  
//   id        String  @id @default(uuid())
//   avatar    String  // No @db.VarChar for SQLite
// ============================================

model user {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  email     String
  name      String
  password  String?
  admin     Boolean   @default(false)
  avatar    String    @default("")
  language  String    @default("en")
  theme     THEME     @default(dark)
  provider  PROVIDERS
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum THEME {
  dark
  light
}

enum PROVIDERS {
  credentials
  google
  github
  x
  facebook
  linkedIn
  apple
  discord
  instagram
}

// ============================================
// PRISMA CLI COMMANDS REFERENCE
// ============================================
// npx prisma format       - Auto-format schema file
// npx prisma validate     - Validate schema syntax
// npx prisma generate     - Generate Prisma Client
// npx prisma db pull      - Sync schema from existing database
// npx prisma db push      - Push schema to database (dev only)
// npx prisma migrate dev  - Create and apply migration
// npx prisma migrate reset- Reset database and reapply migrations
// npx prisma studio       - Open database GUI
// ============================================
</file>

<file path="server/dev/templateInjector.ts">
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

/**
 * Template Injector
 * 
 * Injects default templates into new empty files in _api and _sync folders.
 * Handles sync file pairing with context-aware template selection.
 */


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const templatesDir = path.join(__dirname, 'templates');

export const isEmptyFile = (filePath: string): boolean => {
  try {
    const stats = fs.statSync(filePath);
    return stats.size === 0;
  } catch {
    return false;
  }
};

export const isInApiFolder = (filePath: string): boolean => {
  const normalized = filePath.replace(/\\/g, '/');
  return normalized.includes('/_api/') && filePath.endsWith('.ts');
};

export const isInSyncFolder = (filePath: string): boolean => {
  const normalized = filePath.replace(/\\/g, '/');
  return normalized.includes('/_sync/') && filePath.endsWith('.ts');
};

export const isSyncServerFile = (filePath: string): boolean => {
  return filePath.endsWith('_server.ts');
};

export const isSyncClientFile = (filePath: string): boolean => {
  return filePath.endsWith('_client.ts');
};

/**
 * Get the paired sync file path (server -> client or client -> server)
 */
export const getPairedSyncFile = (filePath: string): string | null => {
  const normalized = filePath.replace(/\\/g, '/');
  if (isSyncServerFile(normalized)) {
    return normalized.replace('_server.ts', '_client.ts');
  }
  if (isSyncClientFile(normalized)) {
    return normalized.replace('_client.ts', '_server.ts');
  }
  return null;
};

/**
 * Check if a paired sync file exists
 */
export const hasPairedFile = (filePath: string): boolean => {
  const pairedPath = getPairedSyncFile(filePath);
  if (!pairedPath) return false;
  return fs.existsSync(pairedPath);
};

/**
 * Extract page path from a sync file path (e.g., "examples" from "src/examples/_sync/test_server.ts")
 */
export const extractSyncPagePath = (filePath: string): string => {
  const normalized = filePath.replace(/\\/g, '/');
  const match = normalized.match(/src\/(.+?)\/_sync\//);
  return match ? match[1] : '';
};

/**
 * Extract sync name from a sync file path (e.g., "test" from "src/examples/_sync/test_server.ts")
 */
export const extractSyncName = (filePath: string): string => {
  const basename = path.basename(filePath, '.ts');
  return basename.replace(/_server$/, '').replace(/_client$/, '');
};

/**
 * Extract clientInput type body from a sync file's SyncParams interface
 * Returns the content between the braces of clientInput: { ... }
 */
export const extractClientInputFromFile = (filePath: string): string | null => {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Find interface SyncParams
    const syncParamsMatch = content.match(/interface\s+SyncParams\s*\{/);
    if (!syncParamsMatch) return null;

    // Find clientInput property
    const clientInputMatch = content.match(/clientInput\s*:\s*\{/);
    if (!clientInputMatch) return null;

    // Extract balanced braces
    const startIndex = content.indexOf('{', clientInputMatch.index!);
    let depth = 0;
    let endIndex = startIndex;

    for (let i = startIndex; i < content.length; i++) {
      if (content[i] === '{') depth++;
      else if (content[i] === '}') depth--;

      if (depth === 0) {
        endIndex = i;
        break;
      }
    }

    return content.substring(startIndex, endIndex + 1);
  } catch (error) {
    console.error(`[TemplateInjector] Error extracting clientInput from ${filePath}:`, error);
    return null;
  }
};

/**
 * Extract clientInput type from the generated apiTypes.generated.ts file
 * Used when the server file is already deleted but we need to migrate types to client
 */
export const extractClientInputFromGeneratedTypes = (pagePath: string, syncName: string): string | null => {
  try {
    const generatedTypesPath = path.join(process.cwd(), 'src', '_sockets', 'apiTypes.generated.ts');
    const content = fs.readFileSync(generatedTypesPath, 'utf-8');

    // Find the sync entry pattern: 'syncName': { clientInput: ...
    const syncEntryPattern = new RegExp(`'${syncName}':\\s*\\{\\s*clientInput:\\s*`);
    const match = content.match(syncEntryPattern);

    if (!match || match.index === undefined) {
      console.log(`[TemplateInjector] Could not find sync entry for ${pagePath}/${syncName}`);
      return null;
    }

    // Find the start of clientInput value (the opening brace)
    const searchStart = match.index + match[0].length;
    const braceStart = content.indexOf('{', searchStart - 1);

    if (braceStart === -1) return null;

    // Extract balanced braces
    let depth = 0;
    let endIndex = braceStart;

    for (let i = braceStart; i < content.length; i++) {
      if (content[i] === '{') depth++;
      else if (content[i] === '}') depth--;

      if (depth === 0) {
        endIndex = i;
        break;
      }
    }

    const extracted = content.substring(braceStart, endIndex + 1);
    console.log(`[TemplateInjector] Extracted clientInput types: ${extracted}`);
    return extracted;
  } catch (error) {
    console.error(`[TemplateInjector] Error extracting clientInput from generated types:`, error);
    return null;
  }
};

/**
 * Calculate the relative path prefix (e.g., '../../../') to reach project root from a file
 * @param filePath - Absolute or relative path to the file
 * @returns The relative path prefix to reach project root
 */
export const calculateRelativePath = (filePath: string): string => {
  const normalized = filePath.replace(/\\/g, '/');

  // Find the 'src/' part of the path
  const srcIndex = normalized.indexOf('src/');
  if (srcIndex === -1) {
    // Fallback: count from beginning if src not found
    console.warn(`[TemplateInjector] Could not find /src/ in path: ${filePath}`);
    return '../../../'; // default fallback
  }

  // Get path after 'src/' (e.g., 'examples/examples2/_api/file.ts')
  const relativePath = normalized.substring(srcIndex + 4); // +4 to skip 'src/'

  // Count segments (directories + filename)
  const segments = relativePath.split('/').filter(s => s.length > 0).length;

  // We need to go up `segments` levels to reach project root
  // e.g., 'examples/_api/file.ts' = 3 segments -> '../../../'
  return '../'.repeat(segments);
};

const getTemplate = (filePath: string): string | null => {
  let templateFile: string;
  let pagePath = '';
  let syncName = '';

  if (isInApiFolder(filePath)) {
    templateFile = path.join(templatesDir, 'api.template.ts');
  } else if (isInSyncFolder(filePath)) {
    if (isSyncServerFile(filePath)) {
      templateFile = path.join(templatesDir, 'sync_server.template.ts');
    } else if (isSyncClientFile(filePath)) {
      // Check if _server.ts exists - use paired template if so
      if (hasPairedFile(filePath)) {
        templateFile = path.join(templatesDir, 'sync_client_paired.template.ts');
        pagePath = extractSyncPagePath(filePath);
        syncName = extractSyncName(filePath);
      } else {
        templateFile = path.join(templatesDir, 'sync_client_standalone.template.ts');
      }
    } else {
      console.log(`[TemplateInjector] Unknown sync file type: ${filePath}`);
      return null;
    }
  } else {
    return null;
  }

  try {
    let content = fs.readFileSync(templateFile, 'utf-8');

    // Replace path placeholders with computed relative paths
    const relPath = calculateRelativePath(filePath);
    const pattern = /\/\/\s*@ts-expect-error.*(?:\r?\n)(.*)(?:\{\{REL_PATH\}\})/g;

    content = content.replace(pattern, (_, prefix) => {
      return `${prefix}${relPath}`;
    });

    // Replace page path and sync name placeholders for paired templates
    if (pagePath && syncName) {
      content = content.replace(/\{\{PAGE_PATH\}\}/g, pagePath);
      content = content.replace(/\{\{SYNC_NAME\}\}/g, syncName);
    }

    return content;
  } catch (error) {
    console.error(`[TemplateInjector] Could not read template: ${templateFile}`, error);
    return null;
  }
};

export const injectTemplate = async (filePath: string): Promise<boolean> => {
  const template = getTemplate(filePath);

  if (!template) {
    return false;
  }

  try {
    fs.writeFileSync(filePath, template, 'utf-8');
    console.log(`[TemplateInjector] Injected template into: ${filePath}`);
    return true;
  } catch (error) {
    console.error(`[TemplateInjector] Failed to inject template: ${filePath}`, error);
    return false;
  }
};

export const shouldInjectTemplate = (filePath: string): boolean => {
  return (isInApiFolder(filePath) || isInSyncFolder(filePath)) && isEmptyFile(filePath);
};

/**
 * Update a client file to use the paired template (imports types from generated file)
 * Called when a _server.ts is created and _client.ts already exists
 * PRESERVES user's main function code!
 */
export const updateClientFileForPairedServer = async (clientFilePath: string): Promise<boolean> => {
  try {
    const pagePath = extractSyncPagePath(clientFilePath);
    const syncName = extractSyncName(clientFilePath);

    // Read the existing client file (preserve user's code)
    let content = fs.readFileSync(clientFilePath, 'utf-8');

    // Update imports: add SyncClientInput, SyncServerOutput if not present
    if (!content.includes('SyncClientInput')) {
      content = content.replace(
        /import \{([^}]+)\} from ['"]([^'"]*apiTypes\.generated)['"]/,
        (match, imports, path) => {
          return `import {${imports}, SyncClientInput, SyncServerOutput } from '${path}'`;
        }
      );
    }

    // Add type aliases after imports if not present
    if (!content.includes('type PagePath')) {
      const importEndMatch = content.match(/import .+?;[\r\n]+/g);
      if (importEndMatch) {
        const lastImportEnd = content.lastIndexOf(importEndMatch[importEndMatch.length - 1]) +
          importEndMatch[importEndMatch.length - 1].length;
        const typeAliases = `\n// Types are imported from the generated file based on the _server.ts definition\ntype PagePath = '${pagePath}';\ntype SyncName = '${syncName}';\n`;
        content = content.slice(0, lastImportEnd) + typeAliases + content.slice(lastImportEnd);
      }
    }

    // Replace clientInput type with imported type (preserve indentation)
    content = content.replace(
      /^(\s*)clientInput:\s*\{[^}]*\}/m,
      '$1clientInput: SyncClientInput<PagePath, SyncName>'
    );

    // Add serverOutput if not present (after clientInput in SyncParams, with matching indentation)
    if (!content.includes('serverOutput:')) {
      content = content.replace(
        /^(\s*)(clientInput:\s*SyncClientInput<PagePath, SyncName>);?\s*$/m,
        '$1$2;\n$1serverOutput: SyncServerOutput<PagePath, SyncName>;'
      );
    }

    // Add serverOutput to main function destructuring if not present
    if (content.includes('main') && !content.match(/\{\s*[^}]*serverOutput[^}]*\}\s*:\s*SyncParams/)) {
      content = content.replace(
        /\{\s*([^}]*?clientInput)([^}]*)\}\s*:\s*SyncParams/,
        '{ $1, serverOutput$2 }: SyncParams'
      );
    }

    fs.writeFileSync(clientFilePath, content, 'utf-8');
    console.log(`[TemplateInjector] Updated client file to use paired types (preserved code): ${clientFilePath}`);
    return true;
  } catch (error) {
    console.error(`[TemplateInjector] Failed to update client file: ${clientFilePath}`, error);
    return false;
  }
};

/**
 * Update a client file when the paired server file is deleted
 * Preserves user's main function code while:
 * - Inlining clientInput types
 * - Removing serverOutput from SyncParams and main function params
 */
export const updateClientFileForDeletedServer = async (
  clientFilePath: string,
  clientInputTypes: string
): Promise<boolean> => {
  try {
    // Read the existing client file (preserve user's code)
    let content = fs.readFileSync(clientFilePath, 'utf-8');

    // STEP 1: Replace clientInput type declaration FIRST (before removing imports)
    // Pattern matches: clientInput: SyncClientInput<...> or clientInput: { ... }
    // Preserve leading indentation
    content = content.replace(
      /^(\s*)clientInput:\s*SyncClientInput<[^>]+>/m,
      `$1clientInput: ${clientInputTypes}`
    );
    content = content.replace(
      /^(\s*)clientInput:\s*\{[^}]*\}/m,
      `$1clientInput: ${clientInputTypes}`
    );

    // STEP 2: Remove serverOutput line from SyncParams interface FIRST
    // Pattern: serverOutput: SyncServerOutput<...>; or serverOutput: { ... };
    // Remove entire line including its indentation
    content = content.replace(
      /^[ \t]*serverOutput:\s*SyncServerOutput<[^>]+>;?\s*\r?\n?/m,
      ''
    );
    content = content.replace(
      /^[ \t]*serverOutput:\s*\{[^}]*\};?\s*\r?\n?/m,
      ''
    );

    // STEP 3: Remove serverOutput from main function destructuring
    content = content.replace(/,\s*serverOutput(?=\s*[,}])/g, '');
    content = content.replace(/serverOutput\s*,\s*/g, '');

    // STEP 4: NOW clean up imports (after type declarations are replaced)
    content = content.replace(/,\s*SyncClientInput(?=\s*[,}])/g, '');
    content = content.replace(/,\s*SyncServerOutput(?=\s*[,}])/g, '');

    // STEP 5: Remove type aliases if present
    content = content.replace(/\/\/\s*Types are imported.*\n?/g, '');
    content = content.replace(/type PagePath = '[^']*';\s*\n?/g, '');
    content = content.replace(/type SyncName = '[^']*';\s*\n?/g, '');

    // Clean up any double newlines
    content = content.replace(/\n{3,}/g, '\n\n');

    fs.writeFileSync(clientFilePath, content, 'utf-8');
    console.log(`[TemplateInjector] Updated client file for deleted server (preserved code): ${clientFilePath}`);
    return true;
  } catch (error) {
    console.error(`[TemplateInjector] Failed to update client file: ${clientFilePath}`, error);
    return false;
  }
};

/**
 * Inject server template with pre-filled clientInput types (from existing client file)
 */
export const injectServerTemplateWithClientInput = async (
  serverFilePath: string,
  clientInputTypes: string
): Promise<boolean> => {
  try {
    const relPath = calculateRelativePath(serverFilePath);

    const templateFile = path.join(templatesDir, 'sync_server.template.ts');
    let content = fs.readFileSync(templateFile, 'utf-8');

    // Replace placeholders
    const pattern = /\/\/\s*@ts-expect-error.*(?:\r?\n)(.*)(?:\{\{REL_PATH\}\})/g;
    content = content.replace(pattern, (_, prefix) => {
      return `${prefix}${relPath}`;
    });

    // Replace the empty clientInput with the provided types
    content = content.replace(
      /clientInput:\s*\{[^}]*\}/s,
      `clientInput: ${clientInputTypes}`
    );

    fs.writeFileSync(serverFilePath, content, 'utf-8');
    console.log(`[TemplateInjector] Injected server template with clientInput: ${serverFilePath}`);
    return true;
  } catch (error) {
    console.error(`[TemplateInjector] Failed to inject server template: ${serverFilePath}`, error);
    return false;
  }
};
</file>

<file path="server/dev/templates/api.template.ts">
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { AuthProps, SessionLayout } from '{{REL_PATH}}config';
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { Functions, ApiResponse } from '{{REL_PATH}}src/_sockets/apiTypes.generated';

// Set the request limit per minute. Set to false to use the default config value config.rateLimiting
export const rateLimit: number | false = 20;

// HTTP method for this API. If not set, inferred from name (get* = GET, delete* = DELETE, else POST)
export const httpMethod: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'POST';

export const auth: AuthProps = {
  login: true,
  additional: []
};

export interface ApiParams {
  data: {
    // Define your input data shape here e.g.
    // name: string;
    // email: string;
  };
  user: SessionLayout;
  functions: Functions;
}

export const main = async ({ data, user, functions }: ApiParams): Promise<ApiResponse> => {
  return {
    status: 'success',
    result: {
      // Your response data here
    }
  };
};
</file>

<file path="server/dev/templates/sync_client.template.ts">
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { SessionLayout } from '{{REL_PATH}}config';
//@ts-expect-error We replace {{REL_PATH}} with the relative path to the project root
import { Functions, SyncClientResponse } from '{{REL_PATH}}src/_sockets/apiTypes.generated';


export interface SyncParams {
  clientInput: {
    // Define the data shape sent from the client e.g.
    // message: string;
  };
  serverOutput: {
    // Define the data shape returned from the server e.g.
    // message: string;
  };
  user: SessionLayout; // session data from any user that is in the room
  functions: Functions; // contains all functions that are available on the server in the functions folder
  roomCode: string; // room code
}

export const main = async ({ user, clientInput, serverOutput, functions, roomCode }: SyncParams): Promise<SyncClientResponse> => {
  // THIS FILE RUNS ON THE SERVER AND IT EXECUTES FOR EVERY CLIENT THAT IS IN THE GIVEN ROOM

  // Example: Only allow users on set page to receive the event
  // if (user?.location?.pathName === '/your-page') {
  //   return { status: 'success' };
  // }

  return {
    status: 'success',
    // Add any additional data to pass to the client
  };
};
</file>

<file path="server/functions/session.ts">
/**
 * Session management utilities for Redis-backed user sessions.
 * 
 * Features:
 * - Save/retrieve/delete sessions from Redis
 * - Configurable session expiry (config.sessionExpiryDays)
 * - Optional session enforcement (config.allowMultipleSessions)
 * - Real-time session updates to connected clients
 */

// import type { SessionLayout } from "config";

import config, { SessionLayout } from "../../config";
import redis from "./redis";
import { captureException } from "../utils/sentry";

/** Convert days to seconds for Redis TTL */
const SESSION_TTL = 60 * 60 * 24 * (config.sessionExpiryDays || 7);

/**
 * Save or update a user session in Redis.
 * 
 * @param token - The session token (unique identifier)
 * @param data - The session data to store
 * @param newUser - If true, this is a new login (triggers single-session enforcement)
 */
const saveSession = async (token: string, data: SessionLayout, newUser?: boolean) => {
  try {
    const sessionKey = `${process.env.PROJECT_NAME}-session:${token}`;
    await redis.set(sessionKey, JSON.stringify(data));
    await redis.expire(sessionKey, SESSION_TTL);

    const { ioInstance } = await import('../sockets/socket');
    const io = ioInstance;
    if (!io) { return; }

    // Handle single-session enforcement on new login
    if (newUser && config.allowMultipleSessions === false) {
      const userId = data?.id;
      if (!userId) return;

      const activeUsersKey = `${process.env.PROJECT_NAME}-activeUsers:${userId}`;
      const previousTokens = await redis.smembers(activeUsersKey);

      if (previousTokens.length > 0) {
        const { logout } = await import('../sockets/utils/logout');

        // Kick all previous sessions for this user
        await Promise.all(previousTokens.map(async (previousToken) => {
          const sockets = io.sockets.adapter.rooms.get(previousToken);
          if (sockets) {
            console.log(`Kicking previous session for user ${userId}`, 'yellow');
            for (const socketId of sockets) {
              const socket = io.sockets.sockets.get(socketId);
              if (socket) {
                await logout({ token: previousToken, socket, userId });
              }
            }
          } else {
            // No active sockets, just clean up Redis
            await redis.del(`${process.env.PROJECT_NAME}-session:${previousToken}`);
            await redis.srem(activeUsersKey, previousToken);
          }
        }));
      }

      // Track the new session
      await redis.sadd(activeUsersKey, token);
      await redis.expire(activeUsersKey, SESSION_TTL);
    }

    // Broadcast session updates to connected clients
    if (io.sockets.adapter.rooms.has(token)) {
      io.to(token).emit('updateSession', JSON.stringify(data));
    }
  } catch (error) {
    console.log('Error saving session:', error, 'red');
    captureException(error, { fn: 'saveSession', token });
  }
};

/**
 * Retrieve a user session from Redis.
 * 
 * @param token - The session token
 * @returns The session data or null if not found
 */
const getSession = async (token: string | null): Promise<SessionLayout | null> => {
  if (!token) return null;

  try {
    const session = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);
    if (!session) return null;

    const parsed = JSON.parse(session);
    if (!parsed) return null;

    return { ...parsed, token };
  } catch (error) {
    console.log('Error getting session:', error, 'red');
    captureException(error, { fn: 'getSession', token });
    return null;
  }
};

/**
 * Delete a user session from Redis and notify connected clients.
 * 
 * @param token - The session token to delete
 * @returns true if successful
 */
const deleteSession = async (token: string): Promise<boolean> => {
  try {
    const user = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);

    if (user) {
      const userId = JSON.parse(user)?.id;
      if (userId) {
        const activeUsersKey = `${process.env.PROJECT_NAME}-activeUsers:${userId}`;
        const { ioInstance } = await import('../sockets/socket');

        // Notify connected clients to logout
        if (ioInstance?.sockets.adapter.rooms.has(token)) {
          ioInstance.to(token).emit('forceLogout');
        }

        await redis.srem(activeUsersKey, token);
      }
    }

    await redis.del(`${process.env.PROJECT_NAME}-session:${token}`);
    return true;
  } catch (error) {
    console.log('Error deleting session:', error, 'red');
    captureException(error, { fn: 'deleteSession', token });
    return false;
  }
};

/**
 * Get all active sessions (admin utility).
 * 
 * @returns Array of all session data
 */
const getAllSessions = async (): Promise<SessionLayout[]> => {
  try {
    const keys = await redis.keys(`${process.env.PROJECT_NAME}-session:*`);
    const sessions = await Promise.all(keys.map((key) => redis.get(key)));
    return sessions.map((s) => JSON.parse(s || "{}"));
  } catch (error) {
    console.log('Error getting all sessions:', error, 'red');
    captureException(error, { fn: 'getAllSessions' });
    return [];
  }
};

export { saveSession, getSession, deleteSession, getAllSessions };
</file>

<file path="src/_components/Avatar.tsx">
import { backendUrl, SessionLayout } from "config";

import { useAvatarContext, AvatarStatus } from "./AvatarProvider";

type UserType = SessionLayout | { name: string; avatar?: string; avatarFallback?: string };
type TextSize = "text-sm" | "text-base" | "text-lg" | "text-xl" | "text-2xl" | "text-3xl" | "text-4xl" | "text-5xl" | "text-6xl" | "text-7xl" | "text-8xl" | "text-9xl";

export default function Avatar({
  user,
  textSize,
}: {
  user: UserType;
  textSize?: TextSize;
}) {
  const { avatarStatuses, setAvatarStatus } = useAvatarContext();

  const key = user.avatar ?? user.avatarFallback ?? user.name;
  const avatarStatus = avatarStatuses[key];

  const formattedName = user.name[0].toUpperCase();

  return user.avatar && avatarStatus !== 'fallback' ? (
    <Img user={user} key={key} setAvatarStatus={setAvatarStatus} />
  ) : (
    <FallbackImg user={user} formattedName={formattedName} textSize={textSize} />
  );
}

interface ImgProps {
  user: UserType;
  setAvatarStatus: (key: string, status: AvatarStatus) => void;
}

const Img = ({ user, setAvatarStatus }: ImgProps) => {
  if (!user.avatar) {
    const key = user.avatar ?? user.avatarFallback ?? user.name;
    setAvatarStatus(key, 'fallback');
    return null;
  }

  const key: string = user.avatar;

  return (
    <img
      className="rounded-full w-full h-full select-none object-cover aspect-square"
      src={user.avatar.startsWith('http') ? user.avatar : `${backendUrl}/uploads/${user.avatar}`}
      alt="Avatar"
      onError={() => { setAvatarStatus(key, 'fallback'); }}
      onLoad={() => { setAvatarStatus(key, 'avatar'); }}
    />
  );
};

interface FallbackImgProps {
  user: UserType;
  formattedName: string;
  textSize?: TextSize;
}

const FallbackImg = ({ user, formattedName, textSize }: FallbackImgProps) => {
  return (
    <div
      className={`rounded-full bg-gray-300 text-white flex items-center justify-center w-full h-full select-none ${textSize ?? 'text-lg'}`}
      style={{ backgroundColor: user.avatarFallback }}
    >
      {user.name && user.name !== 'Wachten op speler' ? formattedName : null}
    </div>
  );
};
</file>

<file path="src/_components/AvatarProvider.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
import { createContext, use, useState, useMemo, useCallback, ReactNode } from "react";

export type AvatarStatus = 'avatar' | 'fallback';

interface AvatarContextType {
  avatarStatuses: Record<string, AvatarStatus>;
  setAvatarStatus: (key: string, status: AvatarStatus) => void;
}

const AvatarContext = createContext<AvatarContextType | null>(null);

export const AvatarProvider = ({ children }: { children: ReactNode }) => {
  const [avatarStatuses, setAvatarStatuses] = useState<Record<string, AvatarStatus>>({});

  const setAvatarStatus = useCallback((key: string, status: AvatarStatus) => {
    setAvatarStatuses(prev => ({ ...prev, [key]: status }));
  }, []);

  const contextValue = useMemo(() => ({
    avatarStatuses,
    setAvatarStatus,
  }), [avatarStatuses, setAvatarStatus]);

  return (
    <AvatarContext value={contextValue}>
      {children}
    </AvatarContext>
  );
};

export function useAvatarContext() {
  const ctx = use(AvatarContext);
  if (!ctx) throw new Error("useAvatarContext must be used within AvatarProvider");
  return ctx;
}
</file>

<file path="src/_components/ConfirmMenu.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
import { ReactNode, useState } from 'react';

import { menuHandler } from 'src/_functions/menuHandler';

interface ConfirmMenuProps {
  title: string;
  content?: string | ReactNode;
  input?: string;
  resolve: (val: boolean) => void;
}

export function ConfirmMenu({ title, content, input, resolve }: ConfirmMenuProps) {
  const [inputValue, setInputValue] = useState('');

  const handleConfirm = () => {
    if (input && input !== inputValue) return;
    resolve(true);
    menuHandler.close();
  };

  const handleCancel = () => {
    resolve(false);
    menuHandler.close();
  };

  const inputRequiredAndInvalid = input && input !== inputValue ? true : false;

  return (
    <div className="p-6 flex flex-col gap-4 bg-white w-full max-w-md">
      <h2 className="text-xl font-bold">{title}</h2>

      {typeof content === 'string' ? (
        <p className="text-gray-700">{content}</p>
      ) : (
        content
      )}

      {input && (
        <div className="flex flex-col gap-1">
          <label className="text-sm text-gray-600">
            Type <span className="font-mono bg-gray-100 px-1">{input}</span> to confirm:
          </label>
          <input
            type="text"
            className="border rounded px-2 py-1 focus:border outline-none focus:ring-0"
            value={inputValue}
            onChange={(e) => { setInputValue(e.target.value); }}
          />
        </div>
      )}

      <div className="flex gap-4 justify-end">
        <button
          onClick={handleCancel}
          className="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          disabled={inputRequiredAndInvalid}
          className={`px-4 py-2 rounded text-sm text-white transition font-semibold
            ${inputRequiredAndInvalid
              ? 'bg-blue-300 cursor-not-allowed'
              : 'bg-blue-500 hover:bg-blue-700 cursor-pointer'
            }`}
        >
          Confirm
        </button>
      </div>
    </div>
  );
}

export function confirmDialog(props: Omit<ConfirmMenuProps, 'resolve'>): Promise<boolean> {
  return new Promise((resolve) => {
    void menuHandler.open(
      <ConfirmMenu {...props} resolve={resolve} />,
      { dimBackground: true, background: 'bg-white', size: 'sm' }
    );
  });
}
</file>

<file path="src/_components/Middleware.tsx">
import { ReactNode, useEffect, useState } from "react";
import { useLocation, useNavigate } from "react-router-dom";

import middlewareHandler from "src/_functions/middlewareHandler"

import { useSession } from "../_providers/SessionProvider";

export default function Middleware({ children }: { children: ReactNode }) {
  const [allowed, setAllowed] = useState(false);
  const [checking, setChecking] = useState(true);

  const location = useLocation();
  const navigate = useNavigate();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
    let isMounted = true;
    setAllowed(false);
    setChecking(true);

    void (async () => {
      const params = new URLSearchParams(location.search);
      const queryObject: Record<string, string> = {};

      for (const [key, value] of params.entries()) {
        queryObject[key] = value;
      }

      let count = 0;
      while (!sessionLoaded) { 
        await new Promise(res => setTimeout(res, 10));
        count++;
        if (count > 500) break; // after 5 seconds we stop waiting for the session
      }

      const result = middlewareHandler({ location: location.pathname, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- intentional check prevents navigation race conditions
      if (!isMounted) return;
      if (result?.success) {
        setAllowed(true);
      } else if (result?.redirect) {
        void navigate(result.redirect);
      } else {
        void navigate(-1);
      }

      setChecking(false);
    })();

    //! dont remove isMounted, read below
    //? i dont know why but the isMounted = false will always be false but because of this the navigate(-1) will always redirect to the previous page
    //? if we remove the isMounted variable than it will redirect to the previous page and then to the page before that one and so on wich we dont want
    //? e.g if we are on /test and go to /admin wich is not allowed we come back to /test, if we spam this request we come back to /test but if we remove the isMounted
    //? we first go back to /test but the second time we go back to the route before /test e.g /dashboard wich we dont want
    return () => {
      isMounted = false;
    };
  }, [location.pathname, location.search, navigate, session, sessionLoaded]); // important: rerun on path change

  if (checking || !allowed) return null;
  return <div className="w-full h-full">{children}</div>;
}
</file>

<file path="src/_components/Navbar.tsx">
import { ReactNode, useEffect, useRef, useState } from "react";
import { useLocation } from "react-router-dom";

import { SessionLayout } from "config";
import { apiRequest } from "src/_sockets/apiRequest";

import { useSession } from "../_providers/SessionProvider";

import Avatar from "./Avatar";
import Icon from "./Icon";
import useRouter from "./Router";

interface NavbarItemProps {
  item: {
    init?: (props: {
      item: NavbarItemProps["item"],
      state: NavbarItemProps["state"],
      setState: NavbarItemProps["setState"],
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => ReactNode,
    icon?: string,
    label?: string,
    path?: string,
    action?: (props: { 
      item: NavbarItemProps["item"], 
      state: NavbarItemProps["state"], 
      setState: NavbarItemProps["setState"], 
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => void,
    bottom?: boolean,
    hideOnFolded?: boolean,
    hideOnExpended?: boolean
  },
  state: 'folded' | 'expended',
  setState: (state: 'folded' | 'expended') => void,
  pathname: string,
  session: SessionLayout | null,
  router: (location: string) => Promise<void> | void
}

const navbarItems = [
  {
    init: function InitComponent({ session }: NavbarItemProps) {
      if (!session) { return null }
      return (
        <div className="w-6 h-6">
          <Avatar 
            user={session}
          />
        </div>
      )
    },
  },
  {
    icon: 'close_fullscreen',
    label: 'Close sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('folded')
    },
    hideOnFolded: true
  },
  {
    icon: 'open_in_full',
    label: 'Show sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('expended')
    },
    hideOnExpended: true
  },
  {
    icon: 'home',
    label: 'Test',
    path: '/test'
  },
  {
    icon: 'settings',
    label: 'Settings',
    path: '/settings'
  },
  {
    icon: 'admin_panel_settings',
    label: 'Admin',
    path: '/admin'
  },
  {
    icon: 'logout',
    label: 'Logout',
    bottom: true,
    action: () => {
      void apiRequest({ name: 'logout' });
    }
  },
]

const activePopups: HTMLElement[] = [];
const clearPopups = () => {
  for (const popup of activePopups) {
    popup.remove();
  }
  activePopups.length = 0;
};

const displayPopup = ({ element, text }: { element: HTMLElement, text: string }) => {
  const popup = document.createElement('div');
  popup.className = `
    bg-gray-200 text-gray-700 rounded-md p-2 absolute z-50 shadow-lg whitespace-nowrap pointer-events-none
    transform scale-90 opacity-0 transition-all duration-200
  `;

  popup.innerHTML = text;

  const rect = element.getBoundingClientRect();
  if (rect.width === 0 && rect.height === 0) { return };
  
  popup.style.position = 'absolute';
  popup.style.top = `${String(rect.top + window.scrollY - 10)}px`;
  popup.style.left = `${String(rect.left + window.scrollX + rect.width + 5)}px`;
  document.body.append(popup);

  activePopups.push(popup);
  void popup.offsetHeight;

  popup.classList.remove('scale-90', 'opacity-0');
  popup.classList.add('scale-100', 'opacity-100');

  element.addEventListener('mouseleave', () => { 
    popup.remove(); 
    const index = activePopups.indexOf(popup);
    if (index !== -1) activePopups.splice(index, 1);
  }, { once: true });
};

const NavbarItem = ({ item, state, setState, pathname, session, router }: NavbarItemProps) => {
  const toggleId = useRef<number | null>(null);
  return (
   <div
     role="button"
     tabIndex={0}
     className={`hover:bg-gray-200 hover:text-gray-600 w-full h-10 items-center rounded-sm transition-all duration-100 cursor-pointer gap-2 py-2
      ${state === 'expended' && item.hideOnExpended ? 'hidden' :
        (state === 'folded' && item.hideOnFolded ? 'hidden' : 
        'flex')
      }
      ${state === 'folded' ? 'px-2' : 'px-2'}
      ${item.path === pathname ? 'bg-gray-200' : ''}
      ${item.bottom ? 'mt-auto' : ''}
    `}
    onMouseEnter={(e) => {
      if (state === 'expended') { return }
      const target = e.currentTarget as HTMLElement;
      const randomId = Math.floor(Math.random() * 1_000_000_000_000_000);
      toggleId.current = randomId;
      setTimeout(() => {
        requestAnimationFrame(() => {
          if (item.label === undefined) { return }
          if (toggleId.current !== randomId) { return }
          console.log('toggleId', toggleId.current);
          displayPopup({ element: target, text: item.label });
        })
      }, 100);
    }}
    onMouseLeave={() => {
      if (state === 'expended') { return }
      toggleId.current = null;
    }}
    onKeyDown={(e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (item.action) { item.action({ item, state, setState, pathname, session, router }) }
        else if (item.path) {
          clearPopups();
          void router(item.path);
          setState('folded');
        }
      }
    }}
    onClick={() => {
      if (item.action) { item.action({ item, state, setState, pathname, session, router }) }
      else if (item.path) { 
        clearPopups();
        void router(item.path);
        setState('folded');
      }
    }}>
      {item.init ? 
        item.init({ item, state, setState, pathname, session: session, router })
      :
      <>
        <Icon 
          name={item.icon ?? ''} 
          size={state === 'folded' ? '18px' : '22px'}
          weight={'lighter'}
          customClasses="relative left-0.75"
        />
        {state === 'expended' &&
          <div className="line-clamp-1 select-none">{item.label}</div>
        }
      </>
      }
   </div> 
  ) 
}

export default function Navbar() {

  const [state, setState] = useState<'folded' | 'expended'>('folded');
  const location = useLocation();
  const router = useRouter()
  const { session } = useSession();

  useEffect(() => {
    clearPopups();
  }, [location.pathname]);

  const ref = useRef<HTMLDivElement>(null);
  const [parentWidth, setParentWidth] = useState<number>(0);

  useEffect(() => {
    const parent = ref.current?.parentElement;
    if (!parent) return;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setParentWidth(entry.contentRect.width);
      }
    });

    observer.observe(parent);

    return () => { observer.disconnect(); };
  }, []);

  if (!session) { return null; }

  return (
    <div ref={ref}>
      {parentWidth < 768 &&
        <>
          <div className="w-full py-2 px-4 bg-white text-black flex justify-between items-center">
            <div className="w-8 h-8">
              <Avatar 
                user={session}
              />
            </div>
            <div>
              <Icon
                name={state === 'expended' ? 'close_fullscreen' : 'open_in_full'}
                size={'22px'}
                weight={'lighter'}
                onClick={() => {
                  const value = state === 'expended' ? 'folded' : 'expended';
                  setState(value)
                }}
              />
            </div>
          </div>
        </>
      }
      <div className={`h-full bg-white text-gray-500 flex flex-col items-center @md:py-4 transition-all duration-200 @md:px-2 absolute z-20 @md:z-0 @md:relative
        ${state === 'folded' ? 
          '@md:w-14 w-0 gap-3' : 
          'w-64 gap-1 px-2'
        }`}>

          {(parentWidth >= 768 || state === 'expended') && (
            <>
              {/* Top items */}
              {navbarItems.filter((item) => item.bottom !== true).map((item, index) => {
                const shouldRender = item.init !== undefined || (item.icon && item.label);
                if (!shouldRender) return null;

                return (
                  <NavbarItem
                    key={`top-${String(index)}`}
                    pathname={location.pathname}
                    item={item}
                    state={state}
                    setState={setState}
                    session={session}
                    router={router}
                  />
                );
              })}

              {/* Bottom items, inside a mt-auto wrapper */}
              <div className="mt-auto w-full flex flex-col gap-2 items-center">
                {navbarItems.filter((item) => item.bottom === true).map((item, index) => {
                  const shouldRender = item.init !== undefined || (item.icon && item.label);
                  if (!shouldRender) return null;

                  return (
                    <NavbarItem
                      key={`bottom-${String(index)}`}
                      pathname={location.pathname}
                      item={item}
                      state={state}
                      setState={setState}
                      session={session}
                      router={router}
                    />
                  );
                })}
              </div>
            </>
          )}

      </div>
      <div
        role="button"
        tabIndex={0}
        className={`@md:hidden flex absolute top-0 left-0 z-10 bg-black ${state === 'folded' ? 'opacity-0 pointer-events-none' : 'opacity-80'} transition-all duration-300 w-full h-full`}
        onClick={() => { setState('folded') }}
        onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') setState('folded'); }}>
      </div>
    </div>
  )
}
</file>

<file path="src/_components/Router.tsx">
import { useLocation, useNavigate } from "react-router-dom";

import middlewareHandler from "src/_functions/middlewareHandler";

import { useSession } from "../_providers/SessionProvider";

const getParams = (locationSearch: string) => {
  const params = new URLSearchParams(locationSearch);
  const queryObject: Record<string, string> = {};

  for (const [key, value] of params.entries()) {
    queryObject[key] = value;
  }

  return queryObject;
}

// Custom hook for router initialization - renamed to use "use" prefix
export default function useRouter() {
  const navigateHandler = useNavigate();
  const location = useLocation();
  const { session } = useSession();

  const navigate = async (path: string) => {
    const queryObject = getParams(location.search);
    const result = middlewareHandler({ location: path, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

    if (result?.success) {
      return navigateHandler(path);
    } else if (result?.redirect) {
      return navigateHandler(result.redirect);
    } else {
      return
    }
  }

  return navigate
}
</file>

<file path="src/_components/TemplateProvider.tsx">
import { faGear, faHome } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { useCallback, useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';

import config, { dev } from "config";
import Middleware from 'src/_components/Middleware';
import Navbar from "src/_components/Navbar";
import { useSocketStatus } from 'src/_providers/socketStatusProvider';
import { apiRequest } from 'src/_sockets/apiRequest';

import { useSession } from '../_providers/SessionProvider';

import Avatar from './Avatar';
import { ConfirmMenu } from './ConfirmMenu';
import { useMenuHandler } from './MenuHandler';
import useRouter from './Router';
import ThemeToggler from './ThemeToggler';



const Templates = {
  dashboard: DashboardTemplate,
  home: HomeTemplate,
  plain: PlainTemplate,
}
export type Template = 'dashboard' | 'plain' | 'home';

function DashboardTemplate({ children }: { children: React.ReactNode }) {
  return (
    <div className="w-full h-full flex flex-row bg-white">
      <div className="w-full h-full flex flex-col md:flex-row">
        <Navbar />
        <div className="md:flex-grow h-full text-black bg-blue-50">
          <Middleware>
            {children}
          </Middleware>
        </div>
      </div>
    </div>
  )
}

function HomeTemplate({ children }: { children: React.ReactNode }) {

  const router = useRouter();
  const location = useLocation();
  const { session } = useSession();
  const ref = useMenuHandler();

  const handleNavigate = useCallback((path: string) => {
    void router(path);
  }, [router]);

  const handleConfirmNavigate = useCallback(() => {
    ref.close();
    handleNavigate(location.pathname === '/settings' ? '/home' : '/settings');
  }, [ref, handleNavigate, location.pathname]);

  const handleLogout = useCallback(() => {
    void apiRequest<"", "logout">({ name: 'logout' });
  }, []);

  return (
    <div className="w-full h-full overflow-hidden flex flex-col text-title text-sm md:text-lg">

      <div className='w-full flex items-center p-2 bg-container gap-4'>
        <div className='h-full flex-1 flex gap-2 items-center'>
          <div className='min-w-8 max-w-8 h-8'>
            {session && (
              <Avatar user={session} />
            )}
          </div>
          <h1 className='font-semibold text-base line-clamp-1'>{session?.name}</h1>
        </div>

        <button
          className='p-2 bg-container2 border border-container2-border rounded-md cursor-pointer'
          onClick={() => {
            if (location.pathname.startsWith('/games')) {
              void ref.open(
                <ConfirmMenu
                  title="Spel verlaten?"
                  content="Weet je zeker dat je het spel wilt verlaten?"
                  resolve={(status: boolean) => {
                    if (!status) { return; }
                    handleConfirmNavigate();
                  }}
                />
              )
            } else {
              handleNavigate(location.pathname === '/settings' ? '/home' : '/settings');
            }
          }}
        >
          <FontAwesomeIcon icon={location.pathname === '/settings' ? faHome : faGear} size='lg' />
        </button>

        <button
          className='bg-container2 border border-container2-border rounded-md py-2 px-6 cursor-pointer font-semibold'
          onClick={handleLogout}
        >
          Uitloggen
        </button>
      </div>

      <div className='overflow-hidden w-full flex-grow'>
        <Middleware>
          {children}
        </Middleware>
      </div>

    </div>
  )
}

function PlainTemplate({ children }: { children: React.ReactNode }) {
  const { updateTheme } = ThemeToggler();
  const reactLocation = useLocation();

  useEffect(() => {
    updateTheme(config.defaultTheme);
    document.documentElement.classList.toggle("dark", config.defaultTheme === "dark");
  }, [updateTheme, reactLocation]);

  return (
    <div className="w-full h-full">
      {children}
    </div>
  )
}

export default function TemplateProvider({
  children,
  initialTemplate,
}: {
  children: React.ReactNode;
  initialTemplate: Template;
}) {
  const [template] = useState<Template>(initialTemplate);

  const TemplateComponent = Templates[template];

  const { session } = useSession();
  const reactLocation = useLocation();
  const { updateTheme } = ThemeToggler();
  const { socketStatus } = useSocketStatus();

  useEffect(() => {
    if (session?.theme) {
      updateTheme(session.theme);
      document.documentElement.classList.toggle("dark", session.theme === "dark");
    }
  }, [session, updateTheme, reactLocation]);

  if (dev) {
    return (
      <div className='w-full h-full relative'>
        <div className='absolute top-2 right-2 z-50 bg-red-500 text-white px-2 py-1 rounded-md text-xs font-bold'>
          Socket status: {socketStatus.self.status}
          {socketStatus.self.status === "RECONNECTING" && socketStatus.self.reconnectAttempt !== undefined ? ` (attempt ${String(socketStatus.self.reconnectAttempt)})` : ''}
        </div>
        <TemplateComponent>{children}</TemplateComponent>
      </div>
    );
  }

  return (
    <TemplateComponent>{children}</TemplateComponent>
  );
}
</file>

<file path="src/_components/TranslationProvider.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
// src/_components/translationProvider.tsx
import { createContext, Dispatch, ReactNode, SetStateAction, use, useEffect, useMemo, useState } from "react";

import { defaultLanguage } from "config";
import deJson from "src/_locales/de.json";
import enJson from "src/_locales/en.json";
import frJson from "src/_locales/fr.json";
import nlJson from "src/_locales/nl.json";

import { useSession } from "../_providers/SessionProvider";

type LanguageCode = 'nl' | 'en' | 'de' | 'fr';
type TranslationRecord = Record<string, string | Record<string, unknown>>;

const TranslationContext = createContext<{
  translations: TranslationRecord,
  setLanguage: Dispatch<SetStateAction<LanguageCode>>;
} | null>(null);

const getLanguage = (language: string): TranslationRecord => {
  switch (language) {
    case "nl": { return nlJson as TranslationRecord;
    }
    case "en": { return enJson as TranslationRecord;
    }
    case "de": { return deJson as TranslationRecord;
    }
    case "fr": { return frJson as TranslationRecord;
    }
    default: { return enJson as TranslationRecord;
    }
  }
};

export function TranslationProvider({ children }: { children: ReactNode }) {
  const { session } = useSession();
  const [language, setLanguage] = useState<LanguageCode>((session?.language ?? defaultLanguage) as LanguageCode);
  const translations = useMemo(() => getLanguage(language), [language]);

  useEffect(() => {
    if (session?.language) {
      setLanguage(session.language as LanguageCode);
    }
  }, [session]);

  const contextValue = useMemo(() => ({
    translations, setLanguage
  }), [translations, setLanguage]);

  return (
    <TranslationContext value={contextValue}>
      {children}
    </TranslationContext>
  );
}

export function useTranslation() {
  const context = use(TranslationContext);
  if (!context) {
    throw new Error("useTranslation must be used within a TranslationProvider");
  }
  return context.translations;
}

export function useUpdateLanguage() {
  const context = use(TranslationContext);
  if (!context) {
    throw new Error("setLanguage must be used within a TranslationProvider");
  }
  return context.setLanguage;
}

// helper function for dynamic translation
export function translate({ translationList, key, params }: {
  translationList: TranslationRecord,
  key: string,
  params?: { key: string, value: string | number | boolean }[]
}): string {
  const parts = key.split(".");
  let result: unknown = translationList;
  
  for (const part of parts) {
    if (result && typeof result === 'object' && part in result) {
      result = (result as Record<string, unknown>)[part];
    } else {
      return key;
    }
  }
  
  if (typeof result !== "string") return key;
  if (!params) return result;

  let finalResult = result;
  for (const param of params) {
    if (!param.key) continue;
    const regex = new RegExp(`{{${param.key}}}`, "g");
    finalResult = finalResult.replace(regex, String(param.value));
  }
  return finalResult;
}
</file>

<file path="src/_providers/SessionProvider.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
import { createContext, use, useState, ReactNode, useEffect, useMemo } from 'react';

import { apiRequest } from 'src/_sockets/apiRequest';
import { socket, useSocket } from 'src/_sockets/socketInitializer';

import { dev, SessionLayout } from '../../config';

interface UserContextType {
  session: SessionLayout | null;
  sessionLoaded: boolean;
}

let latestSession: SessionLayout | null = null;

const UserContext = createContext<UserContextType | undefined>(undefined);

export function SessionProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<SessionLayout | null>(null);
  const [sessionLoaded, setSessionLoaded] = useState(false);
  useSocket(session); //? starts the socket connection

  useEffect(() => {
    console.log('jowjowjowj');
    latestSession = session;
  }, [session])

  useEffect(() => {
    void (async () => {
      const response = await apiRequest({ name: 'session' });
      setSession(response as unknown as SessionLayout | null);
      setSessionLoaded(true);
    })()
  }, [])

  useEffect(() => {
    if (!socket) return;

    const handler = (data: string) => {
      if (dev) { console.log('updateSession', JSON.parse(data)); }
      const parsed = JSON.parse(data) as SessionLayout;
      setSession(prev => {
        if (!prev) return parsed;
        return {
          ...prev,
          ...parsed,
          avatar: `${parsed.avatar}?v=${String(Date.now())}`
        };
      });
    }

    socket.on('updateSession', handler)

    return () => {
      if (!socket) return;
      socket.off('updateSession', handler);
    }
    
  }, [])

  const contextValue = useMemo(() => ({
    session, sessionLoaded
  }), [session, sessionLoaded]);

  return (
    <UserContext value={contextValue}>
      {children}
    </UserContext>
  );
}

// 5. Create a custom hook for easier usage
export function useSession() {
  const context = use(UserContext);
  if (!context) {
    throw new Error('useSession must be used within a SessionProvider');
  }
  return context;
}

export function getCurrentSession() {
  return latestSession;
}
</file>

<file path="src/_providers/socketStatusProvider.tsx">
/* eslint-disable react-refresh/only-export-components -- hooks colocated with provider */
import {
  createContext,
  use,
  useState,
  ReactNode,
  Dispatch,
  SetStateAction,
  useMemo,
} from "react";

export type SOCKETSTATUS =
  | "CONNECTED"
  | "DISCONNECTED"
  | "RECONNECTING"
  | "STARTUP";

export interface statusContent {
  status: SOCKETSTATUS;
  reconnectAttempt?: number;
  endTime?: number;
}

interface SocketStatusContextType {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
}

const SocketStatusContext = createContext<SocketStatusContextType | undefined>(
  undefined
);

export function SocketStatusProvider({ children }: { children: ReactNode }) {
  const [socketStatus, setSocketStatus] = useState({
    self: {
      status: "STARTUP" as SOCKETSTATUS,
    },
  });

  const contextValue = useMemo(() => ({
    socketStatus, setSocketStatus
  }), [socketStatus]);

  return (
    <SocketStatusContext value={contextValue}>
      {children}
    </SocketStatusContext>
  );
}

export function useSocketStatus() {
  const context = use(SocketStatusContext);
  if (!context) {
    throw new Error("useSocketStatus must be used within a SocketStatusProvider");
  }
  return context;
}
</file>

<file path="src/examples/_sync/updateCounter_server.ts">
import { AuthProps, SessionLayout } from '../../../config';
import { Functions, SyncServerResponse } from '../../../src/_sockets/apiTypes.generated';

export const auth: AuthProps = {
  login: true,
  additional: []
};

export interface SyncParams {
  clientInput: { increase: boolean; };
  user: SessionLayout; // session data of the user who called the sync event
  functions: Functions; // functions object
  roomCode: string; // room code
}

export const main = async ({ clientInput, user, functions, roomCode }: SyncParams): Promise<SyncServerResponse> => {
  console.log(clientInput);
  // here you can maybe update a counter in your server memory with redis or update your database cause this file only runs once

  return {
    status: 'success',
    increase: clientInput.increase
  }
};
</file>

<file path="src/index.css">
@import "tailwindcss";

@theme {
  --color-background: #EFF6FF;

  --color-container: #FFFFFF;
  --color-container-border: #E5E7EB;
  --color-container-hover: #F3F4F6;

  --color-container2: #F8FAFC;
  --color-container2-border: #E2E8F0;
  --color-container2-hover: #F1F5F9;

  --color-container3: #E5E7EB;
  --color-container3-border: #CBD5E1;
  --color-container3-hover: #D1D5DB;

  --color-container4: #F1F5F9;
  --color-container4-border: #E2E8F0;
  --color-container4-hover: #E2E8F0;

  --color-title: #000000;
  --color-common: #1E293B;
  --color-muted: #64748B;

  --color-correct: #22C55E;
  --color-correct-hover: #16A34A;

  --color-wrong: #EF4444;
  --color-wrong-hover: #DC2626;
}

.dark {
  --color-background: #111827;

  --color-container: #1F2937;
  --color-container-border: #374151;
  --color-container-hover: #3F4B63;

  --color-container2: #374151;
  --color-container2-border: #4B5563;
  --color-container2-hover: #565E72;

  --color-container3: #4B5563;
  --color-container3-border: #6B7280;
  --color-container3-hover: #272F41;

  --color-container4: #1F2937;
  --color-container4-border: #374151;
  --color-container4-hover: #CBD5E1;

  --color-title: #FFFFFF;
  --color-common: #E5E7EB;
  --color-muted: #9CA3AF;

  --color-correct: #22C55E;
  --color-correct-hover: #16A34A;

  --color-wrong: #EF4444;
  --color-wrong-hover: #DC2626;
}

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: white;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body {
  margin: 0;
  width: 100%;
  height: 100%;
}

@layer utilities {
  .h-safe {
    height: calc(var(--vh, 1vh) * 100);
  }
}
</file>

<file path="src/page.tsx">
import { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";

import { loginRedirectUrl, loginPageUrl } from "config";

import { useSession } from "./_providers/SessionProvider";
const env = import.meta.env;

export const template = 'plain'
export default function App() {
  const navigate = useNavigate();
  const location = useLocation();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
 
    const params = new URLSearchParams(location.search);
    const token = params.get('token');
    if (token && env.VITE_SESSION_BASED_TOKEN === 'true') {
      sessionStorage.setItem('token', token);
      globalThis.location.href = globalThis.location.pathname;
      return;
    }

    if (sessionLoaded) {
      if (session?.id) {
        void navigate(loginRedirectUrl);
      } else {
        void navigate(loginPageUrl);
      }
    }

  }, [navigate, location, session, sessionLoaded]);

  useEffect(() => {
    const timeout = setTimeout(() => {
      if (!sessionLoaded) {
        void navigate(loginPageUrl)
      }
    }, 1000);
    return () => {
      clearTimeout(timeout)
    }
  }, [sessionLoaded, navigate])


  return null;
}
</file>

<file path="next plan.txt">
Future Work (Not in This Plan)
Auto-generated API docs page - Like FastAPI's /docs
NPM package modularization - Split into @luckystack/*
Session storage abstraction - Support PostgreSQL/JWT
Offline request queue - Queue failed requests for retry
ServerFunctions interface - Fetch them automatically from server/functions folder and auto gen type
Routing - check if we support slugs/ids in routes for pages and nested routes for
1. pages
2. api, syncs
3. server functions


✅ Completed
i18n error codes - Return error codes instead of messages
HTTP API Routing - RESTful /api/{name} routes with method validation
HTTP Method Types - httpMethod in generated types + 
getApiMethod()
 runtime lookup
Simplified httpApiUtils - User reverted to include more prefixes (get/fetch/list, delete/remove, update/edit/patch)
Cleaned up server.ts - Removed legacy POST /api route, now uses 
getParams
 for parsing
Updated Documentation - 
docs/ARCHITECTURE_API.md
 reflects new routes
Fixed TypeScript errors - createPageApi removed, function overload order fixed
</file>

<file path="README.md">
# LuckyStack v2

A **socket-first full-stack framework** for building real-time web applications with React and Node.js.

[![TypeScript](https://img.shields.io/badge/TypeScript-5.7-blue)](https://www.typescriptlang.org/)
[![React](https://img.shields.io/badge/React-19-61DAFB)](https://react.dev/)
[![Socket.io](https://img.shields.io/badge/Socket.io-4.8-black)](https://socket.io/)
[![Tailwind](https://img.shields.io/badge/Tailwind-4.0-38B2AC)](https://tailwindcss.com/)
[![Prisma](https://img.shields.io/badge/Prisma-6.5-2D3748)](https://www.prisma.io/)

---

## What is LuckyStack?

LuckyStack is a custom full-stack framework that takes a **socket-first approach** to client-server communication. Instead of traditional REST APIs, all communication happens over WebSockets, enabling:

- **Real-time sync** between clients in the same room
- **Multiplayer awareness** (AFK detection, user presence)
- **Unified RPC-style API calls** with automatic session handling
- **Built-in authentication** (credentials + OAuth providers)

## Key Features

| Feature                | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Socket-First**       | All client-server communication via Socket.io         |
| **Authentication**     | Credentials + Google, GitHub, Discord, Facebook OAuth |
| **Room System**        | Join rooms for targeted real-time sync                |
| **Activity Awareness** | Track user AFK status and presence                    |
| **File-Based Routing** | Next.js-style page and API routing                    |
| **Tailwind v4**        | Modern CSS with custom theming                        |
| **Redis Sessions**     | Scalable session storage                              |
| **Prisma + MongoDB**   | Type-safe database access                             |
| **Sentry Integration** | Error monitoring for client and server                |

---

## Quick Start

### Prerequisites

- Node.js 18+
- Redis 6+
- MongoDB (local or Atlas)

### Installation

```bash
# Clone the repository
git clone https://github.com/ItsLucky23/LuckyStack-v2 PROJECT_NAME
cd PROJECT_NAME

# Install dependencies
npm install

# Install Sentry packages (optional but recommended)
npm install @sentry/node @sentry/react

# Copy environment template
cp envTemplate.txt .env
cp configTemplate.txt config.ts

# Initialize database
npx prisma generate
npx prisma db push

# Start development servers
npm run server   # Backend (Terminal 1)
npm run client   # Frontend (Terminal 2)
```

### Access the App

You can change the ports in the `.env` file.

- **Frontend:** http://localhost:5173
- **Backend:** http://localhost:80

---

## Documentation

| Document                                                   | Description                                |
| ---------------------------------------------------------- | ------------------------------------------ |
| [Routing architecture](./docs/ARCHITECTURE_ROUTING.md)     | File-based routing (pages, APIs, syncs)    |
| [API architecture](./docs/ARCHITECTURE_API.md)             | API architecture overview                  |
| [Authentication architecture](./docs/ARCHITECTURE_AUTH.md) | Authentication architecture overview       |
| [Session architecture](./docs/ARCHITECTURE_SESSION.md)     | Session architecture overview              |
| [Socket architecture](./docs/ARCHITECTURE_SOCKET.md)       | Socket architecture overview               |
| [Sync architecture](./docs/ARCHITECTURE_SYNC.md)           | Sync architecture overview                 |
| [Developer guide](./docs/DEVELOPER_GUIDE.md)               | Developer guide                            |
| [Hosting guide](./docs/HOSTING.md)                         | Deployment and hosting guide               |

---

## Project Structure

```
LuckyStack-v2/
├── server/                 # Backend (Node.js)
│   ├── auth/               # Authentication (OAuth + credentials)
│   ├── sockets/            # Socket.io handlers
│   │   ├── socket.ts       # Main socket server
│   │   ├── handleApiRequest.ts
│   │   └── handleSyncRequest.ts
│   ├── functions/          # Server utilities (session, db, redis)
│   └── utils/              # Shared utilities
│
├── src/                    # Frontend (React)
│   ├── _components/        # Shared UI components
│   ├── _sockets/           # Socket client utilities
│   ├── _providers/         # React context providers
│   ├── _functions/         # Client utilities
│   └── {page}/             # Page routes
│       ├── page.tsx        # Page component
│       ├── _api/           # Server-only API endpoints
│       └── _sync/          # Real-time sync handlers
│
├── scripts/                # Build scripts
├── prisma/                 # Database schema
└── config.ts               # Application configuration
```

---

## API vs Sync

LuckyStack distinguishes between two types of server communication:

### API Requests

Server-only operations (database queries, external APIs):

```typescript
// Client
const result = await apiRequest({
  name: "getUserData",
  data: { userId: "123" },
});

// Server: src/settings/_api/getUserData.ts
export const auth = { login: true };
export const main = async ({ data, user, functions }) => {
  return await functions.prisma.user.findUnique({ where: { id: data.userId } });
};
```

### Sync Requests

Real-time events between clients:

```typescript
// Client: Send to all users in room
await syncRequest({
  name: "cursorMove",
  data: { x: 100, y: 200 },
  receiver: "room-abc123",
  ignoreSelf: true,
});

// All other clients in the room receive the event
```

---

## Scripts

| Command          | Description           |
| ---------------- | --------------------- |
| `npm run client` | Start Vite dev server |
| `npm run server` | Start Node.js server  |
| `npm run build`  | Build for production  |
| `npm run prod`   | Run production server |

---

## Configuration

### Environment Variables

See [`envTemplate.txt`](./envTemplate.txt) for all available options:

- `NODE_ENV` - development or production
- `DNS` - Public URL for OAuth redirects
- `REDIS_HOST` / `REDIS_PASSWORD` / `REDIS_PORT` - Redis connection
- `DATABASE_URL` - MongoDB connection string
- `SENTRY_DSN` / `VITE_SENTRY_DSN` - Error monitoring

### OAuth Setup

1. Create OAuth apps at each provider
2. Set callback URLs to `https://your-domain.com/auth/callback/{provider}`
3. Add client ID/secret to `.env`

Supported: Google, GitHub, Discord, Facebook

---

## Tech Stack

| Layer          | Technology                              |
| -------------- | --------------------------------------- |
| **Frontend**   | React 19, React Router 7, TailwindCSS 4 |
| **Backend**    | Node.js (raw HTTP), Socket.io           |
| **Database**   | MongoDB with Prisma 6.5 ORM             |
| **Sessions**   | Redis                                   |
| **Auth**       | Custom OAuth + bcrypt                   |
| **Icons**      | Lucide React, Font Awesome              |
| **Monitoring** | Sentry                                  |
| **Build**      | Vite, TypeScript, tsx                   |

---

## License

MIT

---

## Links

- 📖 [GitBook Documentation](https://lucky23.gitbook.io/luckystack/)
</file>

<file path="server/server.ts">
import dotenv from 'dotenv';
import { initializeSentry, captureException } from './utils/sentry';

dotenv.config();
initializeSentry();

import http from 'http';
import getParams from './utils/getParams';
import { loginWithCredentials, loginCallback } from './auth/login';
import { serveFavicon, serveFile } from './prod/serveFile';
import loadSocket from './sockets/socket';
import z from 'zod';
import oauthProviders from "./auth/loginConfig";
import { deleteSession } from './functions/session';
import allowedOrigin from './auth/checkOrigin';
import { SessionLayout } from '../config';
import { initializeAll } from './dev/loader';
import { setupWatchers } from './dev/hotReload';
import { initConsolelog } from './utils/console.log';
import { initRepl } from './utils/repl';
import { serveAvatar } from './utils/serveAvatars';
import { extractTokenFromRequest } from './utils/extractTokenFromRequest';
import { handleHttpApiRequest } from './sockets/handleHttpApiRequest';

const ServerRequest = async (req: http.IncomingMessage, res: http.ServerResponse) => {

  const origin = req.headers.origin ?? req.headers.referer ?? req.headers.host ?? '';

  if (!allowedOrigin(origin)) {
    res.statusCode = 403;
    res.setHeader('Content-Type', 'text/plain');
    return res.end('Forbidden');
  }

  res.setHeader("Access-Control-Allow-Origin", origin);
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader('Referrer-Policy', 'no-referrer'); // prevents the browser from leaking sensative urls
  res.setHeader('X-Frame-Options', 'SAMEORIGIN'); // only allows iframes to use this pages content if on the same domain
  res.setHeader('X-XSS-Protection', '1; mode=block'); // prevents some xss attacks
  res.setHeader('X-Content-Type-Options', 'nosniff'); // prevents mimetype sniffing, this means that when sending a txt file it will not try to execute it as ddl if the user requested this

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    return res.end();
  }

  const method = req.method;
  const url = req.url || '/';
  const [routePath, queryString] = url.split('?');

  if (method !== 'GET' && method != 'POST' && method != 'PUT' && method != 'DELETE') {
    res.statusCode = 404;
    res.setHeader('Content-Type', 'text/plain');
    return res.end(`method: ${method} not supported, use one of the following methods: GET, POST, PUT, DELETE`);
  }

  const cookieHeader = req.headers.cookie || '';
  const token = cookieHeader
    .split('; ')
    .find(row => row.startsWith('token='))
    ?.split('=')[1];


  //? here we load the application icon
  if (z.literal('/favicon.ico').safeParse(routePath).success) {
    return serveFavicon(res);
  }

  //? here we get the params from the request
  let params: object | null;
  params = await getParams({ method, req, res, queryString });

  //? we log the request and if there are any params we log them with the request
  if (params && typeof params == 'object' && Object.keys(params).length !== 0) {
    console.log(`method: ${method}, url: ${routePath}, params: ${JSON.stringify(params)}`, 'magenta')
  } else {
    console.log(`method: ${method}, url: ${routePath}`, 'magenta');
    params = {};
  }

  //? we dont use zod cause it doesnt allow you to pass in a id in the url
  if (routePath.startsWith('/uploads/')) {
    await serveAvatar({ routePath, res });
    return;
  }

  //? triggers when logging in
  //? when using the credentials provider all the logic happends here else we redirect to the oauth provider and all the logic happends in the auth/callback api
  if (z.string().startsWith('/auth/api').safeParse(routePath).success) {
    const providerName = routePath.split('/')[3]; // Extract the provider (google/github)
    const provider = oauthProviders.find(p => p.name === providerName);
    if (!provider || !provider.name) { return { provider, status: false, reason: 'login.providerNotFound' }; }

    if (provider?.name != 'credentials' && 'scope' in provider) {
      res.writeHead(302, {
        'Location': `${provider.authorizationURL}?client_id=${provider.clientID}&redirect_uri=${provider.callbackURL}&scope=${provider.scope.join('%20')}&response_type=code&prompt=select_account`,
      });
      return res.end();
    }

    //? here all the logic happends for login or creating an account with credentials
    const { status, reason, newToken, session } = await loginWithCredentials(params) as {
      status: boolean,
      reason: string,
      newToken: string | null,
      session: SessionLayout | undefined
    }

    //? if it failed to either login or creating an account then we return
    if (!status) {
      res.setHeader("content-type", "application/json; charset=utf-8");
      return res.end(JSON.stringify({ status, reason: reason || 'internal server error' }));
    }

    //? if it was successful then we apply the cookie and return the user id and reason for the login or account creation
    if (newToken) {
      if (token) { await deleteSession(token); }

      console.log('setting cookie with newToken: ', newToken, 'green');
      // const cookieOptions = process.env.NODE_ENV == "development" ? 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800;": 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; Secure;";
      const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`

      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      // return res.end(JSON.stringify({ status, reason, session })) 
      // } else { 
    }
    return res.end(JSON.stringify({ status, reason, session, newToken }))

  } else if (z.string().startsWith('/auth/callback').safeParse(routePath).success) {
    //? this endpoint is triggerd by the oauth provider after the user has logged in
    const newToken = await loginCallback(routePath, req, res);

    //? if it failed to either login or creating an account then we return
    if (!newToken) {
      res.writeHead(401, { "Content-Type": "text/plain" });
      return res.end('Login failed');
    }

    //? we successfully logged in or created an acocunt

    //? if the user already had a token then we delete the previous session data
    if (token) { await deleteSession(token); }

    //? we set the cookie with the new token and redirect the user to the frontend
    console.log('setting cookie with newToken: ', newToken, 'green');
    const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`

    const location = process.env.DNS

    if (process.env.VITE_SESSION_BASED_TOKEN == 'true') {
      res.writeHead(302, {
        Location: `${process.env.DNS}?token=${newToken}`,
      });
    } else {
      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      res.writeHead(302, { Location: location }); // Redirect without exposing token in URL
    }
    return res.end();

    //? HTTP API route - allows calling APIs via HTTP instead of WebSocket
    //? Supports: GET/POST/PUT/DELETE /api/{name}
  } else if (routePath.startsWith('/api/')) {
    try {
      const httpToken = extractTokenFromRequest(req);

      // Extract API name from path: /api/examples/getUserData → examples/getUserData
      const apiName = routePath.slice(5); // Remove "/api/" prefix (5 chars)

      if (!apiName) {
        res.setHeader('Content-Type', 'application/json');
        res.writeHead(400);
        return res.end(JSON.stringify({
          status: 'error',
          message: 'API name is required. Use /api/{name}'
        }));
      }

      // Use getParams to parse request data (handles GET query params, POST/PUT/DELETE body)
      const apiData = await getParams({
        method: method || 'POST',
        req,
        res,
        queryString
      }) || {};

      const result = await handleHttpApiRequest({
        name: apiName,
        data: apiData,
        token: httpToken,
        method: (method as 'GET' | 'POST' | 'PUT' | 'DELETE') || 'POST'
      });

      res.setHeader('Content-Type', 'application/json');
      res.writeHead(result.status === 'success' ? 200 : result.httpStatus || 400);
      return res.end(JSON.stringify(result));
    } catch (error) {
      console.log('HTTP API error:', error, 'red');
      res.setHeader('Content-Type', 'application/json');
      res.writeHead(400);
      return res.end(JSON.stringify({
        status: 'error',
        message: 'Invalid request format'
      }));
    }

  } else if (routePath.includes("/assets/")) {
    const assetPath = routePath.slice(routePath.indexOf("/assets/"));
    req.url = assetPath;
    return serveFile(req, res);

  } else if (z.string()
    .regex(/^\/(assets\/[a-zA-Z0-9_\-/]+|[a-zA-Z0-9_\-]+)\.(png|jpg|jpeg|gif|svg|html|css|js)$/)
    .safeParse(routePath).success) {
    //? if the request is a file with one of the following extensions then we serve it
    //? png|jpg|jpeg|gif|svg|html|css|js
    return serveFile(req, res);

  } else { // for the index.html
    //? if the request doesnt fit any of the above then we serve the index.html file
    return serveFile({ url: '/' }, res);
  }
}

const ip: string = process.env.SERVER_IP || '127.0.0.1';
const port: string = process.env.SERVER_PORT || '80';

(async () => {
  if (process.env.NODE_ENV == 'development') {
    initConsolelog();
    await initializeAll();
    setupWatchers();
    initRepl();
  }

  const httpServer = http.createServer(async (req, res) => { ServerRequest(req, res) });
  loadSocket(httpServer);
  // @ts-ignore // typescript thinks ip needs to be a number
  httpServer.listen(port, ip, () => {
    console.log(`Server is running on http://${ip}:${port}/`, 'green');
  });


})()
</file>

<file path="server/sockets/handleSyncRequest.ts">
import { tryCatch } from "../functions/tryCatch";
import { devSyncs, devFunctions } from "../dev/loader"
import { syncs, functions } from '../prod/generatedApis'
import { ioInstance, syncMessage } from "./socket";
import { Socket } from "socket.io";
import { getSession } from "../functions/session";
import { SessionLayout } from "../../config";
import { validateRequest } from "../utils/validateRequest";
import { extractTokenFromSocket } from "../utils/extractToken";

const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;


// export default async function handleSyncRequest({ name, clientData, user, serverOutput, roomCode }: syncMessage) {
export default async function handleSyncRequest({ msg, socket, token }: {
  msg: syncMessage,
  socket: Socket,
  token: string | null,
}) {

  if (!ioInstance) { return; }

  //? first we validate the data
  if (typeof msg != 'object') {
    console.log('message', 'socket message was not a json object', 'red')
    return socket.emit('sync', 'socket message was not a json object');
  }

  const { name, data, cb, receiver, responseIndex, ignoreSelf } = msg;

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, syncName: ${name}, syncData: ${JSON.stringify(data)}` })
  }

  if (!cb || typeof cb != 'string') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, cb: ${cb}` });
  }

  if (!receiver) {
    console.log('receiver / roomCode: ', receiver, 'red')
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, needs a receiver / roomCode: ${receiver}` });
  }

  console.log(' ', 'blue')
  console.log(' ', 'blue')
  console.log(`sync: ${name} called`, 'blue');

  const user = await getSession(token);
  const syncObject = process.env.NODE_ENV == 'development' ? devSyncs : syncs;

  console.log(syncObject)
  //? we check if there is a client file or/and a server file, if they both dont exist we abort
  if (!syncObject[`${name}_client`] && !syncObject[`${name}_server`]) {
    console.log("ERROR!!!, ", `you need ${name}_client or ${name}_server file to sync`, 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `you need ${name}_client or ${name}_server file to sync` });
  }

  let serverOutput = {};
  if (syncObject[`${name}_server`]) {
    const { auth, main: serverMain } = syncObject[`${name}_server`];

    //? if the login key is true we check if the user has an id in the session object
    if (auth.login) {
      if (!user?.id) {
        console.log(`ERROR!!!, not logged in but sync requires login`, 'red');
        return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: 'not logged in but sync requires login' });
      }
    }

    const validationResult = validateRequest({ auth, user: user as SessionLayout });
    if (validationResult.status === 'error') {
      console.log('ERROR!!!, ', validationResult.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, validationResult);
    }

    //? if the user has passed all the checks we call the preload sync function and return the result
    const [serverSyncError, serverSyncResult] = await tryCatch(async () => await serverMain({ clientInput: data, user, functions: functionsObject, roomCode: receiver }));
    if (serverSyncError) {
      console.log('ERROR!!!, ', serverSyncError.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncError.message });
    } else if (serverSyncResult?.status == 'error') {
      console.log('ERROR!!!, ', serverSyncResult.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncResult.message });
    } else if (serverSyncResult?.status !== 'success') {
      //? badReturn means it doesnt include a status key with the value 'success' || 'error'
      console.log('ERROR!!!, ', `sync ${name}_server function didnt return a status key with the value 'success' or 'error'`, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `sync ${name}_server function didnt return a status key with the value 'success' or 'error'` });
    } else if (serverSyncResult?.status == 'success') {
      serverOutput = serverSyncResult;
    }
  }

  //? from here on we can assume that we have either called a server sync and got a proper result of we didnt call a server sync

  //? get the desired sockets based on the receiver key
  const sockets = receiver === 'all'
    ? ioInstance.sockets.sockets //? all connected sockets (Map)
    : ioInstance.sockets.adapter.rooms.get(receiver) //? Set of socket IDs in room

  //? now we check if we found any sockets
  if (!sockets) {
    console.log('data: ', msg, 'red');
    console.log('receiver: ', receiver, 'red');
    console.log('no sockets found', 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `no sockets found for receiver / roomCode: ${receiver}` });
  }

  //? here we loop over all the connected clients
  //? we keep track of an counter and await the loop every 100 iterations to avoid the server running out of memory and crashing
  let tempCount = 1;
  for (const socketEntry of sockets) {
    tempCount++;
    if (tempCount % 100 == 0) { await new Promise(resolve => setTimeout(resolve, 1)); }

    const tempSocket = receiver === 'all'
      ? (socketEntry as [string, Socket])[1] //? Map entry
      : ioInstance.sockets.sockets.get(socketEntry as string); //? socket ID from Set

    if (!tempSocket) { continue; }

    //? check if they have a token stored in their cookie or session based on the settings
    const tempToken = extractTokenFromSocket(tempSocket);

    //? here we get the users session of the client and run the sync function with the data and the users session data
    const user = await getSession(tempToken);

    if (ignoreSelf && typeof ignoreSelf == 'boolean') {
      if (token == tempToken) {
        continue;
      }
    }

    if (syncObject[`${name}_client`]) {
      const [clientSyncError, clientSyncResult] = await tryCatch(async () => await syncObject[`${name}_client`]({ clientInput: data, user, functions: functionsObject, serverOutput, roomCode: receiver }));
      // if (clientSyncError) { socket.emit(`sync-${responseIndex}`, { status: "error", message: clientSyncError }); }
      if (clientSyncError) { tempSocket.emit(`sync`, { status: "error", message: clientSyncError }) }
      //? if we return error we dont want this client to get the event
      else if (clientSyncResult?.status == 'error') { continue; }
      else if (clientSyncResult?.status == 'success') {
        const result = {
          cb,
          serverOutput,
          clientOutput: clientSyncResult,  // Return from _client file (success only)
          message: clientSyncResult.message || `${name} sync success`,
          status: 'success'
        };
        console.log(result, 'blue')
        tempSocket.emit(`sync`, result);
      }
    } else {
      //? if there is no client function we still want to send the server data to the clients
      const result = {
        cb,
        serverOutput,
        clientOutput: {},  // No client file, so empty output
        message: `${name} sync success`,
        status: 'success'
      };
      console.log(result, 'blue')
      tempSocket.emit(`sync`, result);
    }
  }

  return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: 'success', message: `sync ${name} success` });
}
</file>

<file path="src/_components/ErrorPage.tsx">
/**
 * Custom Error Page Component
 * 
 * This is used as the error boundary fallback for React Router.
 * Uses custom Tailwind colors for consistent branding.
 */

import { useRouteError, isRouteErrorResponse, Link } from 'react-router-dom';

export default function ErrorPage() {
  const error = useRouteError();

  // Determine error type and message
  let errorCode = '500';
  let errorTitle = 'Unexpected Error';
  let errorMessage = 'Something went wrong. Please try again later.';

  if (isRouteErrorResponse(error)) {
    errorCode = error.status.toString();
    errorTitle = error.statusText || 'Error';
    errorMessage = (error.data as { message?: string } | undefined)?.message ?? getErrorMessage(error.status);
  } else if (error instanceof Error) {
    errorMessage = error.message;
  }

  return (
    <div className="min-h-screen bg-background flex flex-col items-center justify-center p-4">
      {/* Error Icon */}
      <div className="mb-8 relative">
        <div className="w-32 h-32 rounded-full bg-container border border-container-border flex items-center justify-center">
          <svg
            className="w-16 h-16 text-wrong"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
            />
          </svg>
        </div>
        {/* Floating error code */}
        <div className="absolute -top-2 -right-2 bg-wrong text-white text-2xl font-bold px-3 py-1 rounded-lg shadow-lg">
          {errorCode}
        </div>
      </div>

      {/* Error Content */}
      <div className="text-center max-w-md">
        <h1 className="text-4xl font-bold text-title mb-4">
          {errorTitle}
        </h1>
        <p className="text-muted text-lg mb-8">
          {errorMessage}
        </p>
      </div>

      {/* Action Buttons */}
      <div className="flex gap-4">
        <button
          onClick={() => { globalThis.history.back(); }}
          className="px-6 py-3 bg-container text-common border border-container-border rounded-lg hover:bg-container-hover transition-colors font-medium"
        >
          ← Go Back
        </button>
        <Link
          to="/"
          className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium"
        >
          Home
        </Link>
      </div>

      {/* Dev info (only in development) */}
      {import.meta.env.DEV && error instanceof Error && (
        <div className="mt-12 max-w-2xl w-full">
          <details className="bg-container rounded-lg p-4 border border-container-border">
            <summary className="cursor-pointer text-sm text-muted font-medium">
              Developer Details
            </summary>
            <pre className="mt-4 text-xs text-wrong overflow-auto p-4 bg-container2 rounded border border-container2-border">
              {error.stack}
            </pre>
          </details>
        </div>
      )}
    </div>
  );
}

function getErrorMessage(status: number): string {
  switch (status) {
    case 400: {
      return 'The request was invalid or malformed.';
    }
    case 401: {
      return 'You need to be logged in to access this page.';
    }
    case 403: {
      return "You don't have permission to access this page.";
    }
    case 404: {
      return "The page you're looking for doesn't exist or has been moved.";
    }
    case 500: {
      return 'Our servers encountered an unexpected error.';
    }
    case 502: {
      return 'Our servers are temporarily unavailable.';
    }
    case 503: {
      return 'The service is temporarily unavailable. Please try again later.';
    }
    default: {
      return 'An unexpected error occurred.';
    }
  }
}
</file>

<file path="src/_components/LoginForm.tsx">
import { useRef, useState } from "react";
import { Link } from "react-router-dom";

import { backendUrl, loginRedirectUrl, loginPageUrl, providers, SessionLayout } from "config";
import tryCatch from "src/_functions/tryCatch";

import notify from "../_functions/notify";
const env = import.meta.env;

export default function LoginForm({ formType }: { formType: "login" | "register" }) {
  const isLogin = formType === "login";
  const title = isLogin ? "Sign in to your account" : "Create a new account";
  const subtitleText = isLogin ? "Don't have an account yet? " : "Already have an account? ";
  const subtitleLink = isLogin ? "Create one now" : "Log in";
  const redirectURL = isLogin ? "/register" : "/login";
  const buttonText = isLogin ? "Log in" : "Sign up";

  const buttonRef = useRef<HTMLButtonElement>(null);
  const [loading, setLoading] = useState(false);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      buttonRef.current?.click();
    }
  };

  const handleSubmit = async (e: React.MouseEvent<HTMLButtonElement>, provider: string) => {
    e.preventDefault();
    if (loading) return;
    setLoading(true);

    if (provider !== "credentials") {
      globalThis.location.href = `${backendUrl}/auth/api/${provider}`;
      return;
    }

    const form = (e.target as HTMLElement).closest("form");
    if (!form) {
      setLoading(false);
      console.error("Form not found"); return;
    }

    const getValue = (name: string): string => {
      const input = form.querySelector(`input[name="${name}"]`);
      return (input as HTMLInputElement | null)?.value ?? "";
    };

    const name = getValue("name");
    const email = getValue("email");
    const password = getValue("password");
    const confirmPassword = getValue("confirmPassword");

    const fetchUser = async () => {
      const res = await fetch(`${backendUrl}/auth/api/credentials`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email, password, confirmPassword, provider }),
        credentials: "include",
      });
      return (await res.json()) as { status: boolean; reason: string, newToken: string | null, session: SessionLayout | undefined };
    };

    const [error, response] = await tryCatch(fetchUser);
    if (error || !response) {
      notify.error({ key: 'common/.404' })
      console.error(error ?? "No JSON response");
      setLoading(false); return;
    }

    if (!response.status) {
      notify.error({ key: response.reason });
      setLoading(false); return;
    }

    notify.success({ key: response.reason });
    setTimeout(() => {
      if (response.newToken && env.VITE_SESSION_BASED_TOKEN == 'true') {
          sessionStorage.setItem("token", response.newToken);
        }
      globalThis.location.href = response.newToken ? loginRedirectUrl : loginPageUrl;
    }, 1000);
  };

  return (
    <div className="w-full overflow-y-auto flex items-center justify-center">
      {/* eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions -- form container needs Enter key handling */}
      <form
        tabIndex={-1}
        onKeyDown={handleKeyDown}
        className="p-8 bg-container rounded-md text-title flex flex-col gap-10 max-w-[400px] w-full"
      >
        <div className="flex flex-col gap-2">
          <h1 className="font-semibold text-lg">{title}</h1>
          <p className="font-medium text-sm text-common">
            {subtitleText}
            <Link to={redirectURL} className="text-blue-500 cursor-pointer">
              {subtitleLink}
            </Link>
          </p>
        </div>

        {providers.includes("credentials") && (
          <>
            <div className="flex flex-col gap-4">
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label htmlFor="name" className="font-medium text-sm">Name</label>
                  <input
                    id="name"
                    name="name"
                    type="text"
                    placeholder="John Pork"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}
              <div className="flex flex-col gap-2">
                <label htmlFor="email" className="font-medium text-sm">Email address</label>
                <input
                  id="email"
                  name="email"
                  type="email"
                  placeholder="johnpork@gmail.com"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              <div className="flex flex-col gap-2">
                <label htmlFor="password" className="font-medium text-sm">Password</label>
                <input
                  id="password"
                  name="password"
                  type="password"
                  placeholder="********"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label htmlFor="confirmPassword" className="font-medium text-sm">Confirm password</label>
                  <input
                    id="confirmPassword"
                    name="confirmPassword"
                    type="password"
                    placeholder="********"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}

              <div className="flex items-center justify-center">
                {isLogin && (
                  <button type="button" className="px-8 h-10 cursor-pointer rounded-md text-blue-500 hover:scale-105 transition-all duration-300">
                    Forgot Password?
                  </button>
                )}
              </div>

              <button
                type="button"
                ref={buttonRef}
                className="px-8 h-10 rounded-md bg-blue-500 text-title hover:scale-105 transition-all duration-300 cursor-pointer"
                onClick={(e) => void handleSubmit(e, "credentials")}
              >
                {loading ? "Loading..." : buttonText}
              </button>
            </div>

            <div className="flex items-center w-full text-gray-500 text-sm before:flex-1 before:border-t before:border-container-border before:content-[''] after:flex-1 after:border-t after:border-container-border after:content-['']">
              <span className="px-4 bg-container text-title">Or continue with</span>
            </div>
          </>
        )}

        <div className="grid grid-cols-2 gap-2">
          {providers
            .filter((p) => p !== "credentials")
            .map((provider) => (
              <button
                type="button"
                key={provider}
                onClick={(e) => void handleSubmit(e, provider)}
                className="h-10 rounded-md cursor-pointer bg-container text-title border border-container-border flex gap-2 items-center justify-center hover:scale-105 transition-all duration-300"
              >
                <img src={`/${provider}.png`} alt={provider} className="w-5 h-5" />
                <span className="text-lg">{provider.charAt(0).toUpperCase() + provider.slice(1)}</span>
              </button>
            ))}
        </div>
      </form>
    </div>
  );
}
</file>

<file path="src/_components/MenuHandler.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
import { createContext, use, useState, ReactNode, ReactElement, useEffect, useLayoutEffect, useMemo, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { v4 as uuidv4 } from 'uuid';

// Types
interface MenuEntry {
  id: string;
  element: ReactElement;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
  resolver?: (value: unknown) => void;
}

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

interface MenuHandlerContextType {
  open: (element: ReactElement, options?: MenuOptions) => Promise<unknown>;
  replace: (element: ReactElement, options?: MenuOptions) => Promise<unknown>;
  close: () => void;
  closeAll: () => void;
  logStack: () => void;
}

interface SlideInWrapperProps {
  children: ReactNode;
  isTop: boolean;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
}

const SlideInWrapper = ({ children, options, isTop, isClosing, soonIsTop }: SlideInWrapperProps) => {
  const [location, setLocation] = useState<'left' | 'center' | 'right'>('right');

  useLayoutEffect(() => {
    // Start with off-screen to the right
    setLocation('right');

    const timer = requestAnimationFrame(() => {
      setLocation('center'); // trigger the transition
    });

    return () => { cancelAnimationFrame(timer); };
  }, []);

  useEffect(() => {
    // console.log("isClosing: ", isClosing, 'location: ', location, "top: ", isTop)
    if (!isTop && location === 'center') {
      setLocation('left'); // trigger the transition    
    } else if (isClosing && location === 'center') {
      setLocation('right'); // trigger the transition
    } else if (location === 'left' && soonIsTop) {
      setLocation('center'); // trigger the transition
    }
  }, [isTop, isClosing, soonIsTop, location]);

  const translate =
    location === 'center'
      ? '0 0'
      : (location === 'left'
        ? '-100% 0'
        : '100% 0'); // initial

  return (
    <div
      className={`w-full overflow-hidden absolute flex flex-col text-black transform transition-transform duration-300 
        ${options.background ?? ''}
      `}
      style={{ translate }}
    >
      {children}
    </div>
  );
};


const MenuHandlerContext = createContext<MenuHandlerContextType | null>(null);

export function useMenuHandler() {
  const ctx = use(MenuHandlerContext);
  if (!ctx) throw new Error('useMenuHandler must be used within MenuHandlerProvider');
  return ctx;
}

export function MenuHandlerProvider({ children }: { children: ReactNode }) {
  const [stack, setStack] = useState<MenuEntry[]>([]);

  const open = useCallback((element: ReactElement, options: MenuOptions = {}) => {
    return new Promise<unknown>((resolve) => {
      const id = uuidv4();
      setStack((prev) => [...prev, { id, element, options, resolver: resolve }]);
    });
  }, []);

  const replace = useCallback((element: ReactElement, options: MenuOptions = {}) => {
    return new Promise<unknown>((resolve) => {
      const id = uuidv4();
      setStack((prev) => {
        const newStack = [...prev];
        newStack.pop();
        newStack.push({ id, element, options, resolver: resolve });
        return newStack;
      });
    });
  }, []);

  const close = useCallback(() => {
    setStack((prev) => {
      if (prev.length === 0) return prev;
      const lastitem = prev.length === 1;
      const newStack = [...prev];
      const top = newStack.at(-1);
      const second = newStack.at(-2);

      if (!top) return prev;

      // Prevent double-close
      if (top.isClosing) return prev;

      // Mark top as closing
      if (lastitem) {
        top.resolver?.(null); // Resolve the promise with null
        return [];
      } else {
        newStack[newStack.length - 1] = { ...top, isClosing: true };
        if (second) {
          newStack[newStack.length - 2] = { ...second, soonIsTop: true };
        }
      }

      // Delay removal for animation
      setTimeout(() => {
        setStack((current) => {
          const last = current.at(-1);
          const tempSecond = current.at(-2);
          if (last && last.id === top.id && last.isClosing) {
            if (last.resolver) last.resolver(null);
            if (tempSecond && second && tempSecond.id === second.id && tempSecond.soonIsTop) {
              current[current.length - 2] = { ...tempSecond, soonIsTop: false };
            }
            return current.slice(0, -1);
          }
          return current;
        });
      }, 200); // Match animation duration

      return newStack;
    });
  }, []);


  const closeAll = useCallback(() => {
    setStack((prev) => {
      for (const entry of prev) entry.resolver?.(null);
      return [];
    });
  }, []);

  const logStack = useCallback(() => {
    console.log('Menu stack:', stack.map(s => s.id));
  }, [stack]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') close();
    };
    globalThis.addEventListener('keydown', handleKeyDown);
    return () => { globalThis.removeEventListener('keydown', handleKeyDown); };
  }, [close]);

  const stackTop = stack.at(-1);
  const sizeClass = stackTop?.options.size
    ? { sm: '384px', md: '512px', lg: '768px' }[stackTop.options.size]
    : '384px';

  const [lastChildHeight, setLastChildHeight] = useState<number>(0);

  useEffect(() => {
    const lastChild = document.querySelector('#test123')?.lastElementChild;
    if (lastChild) {
      setLastChildHeight(lastChild.getBoundingClientRect().height);
    } else {
      setLastChildHeight(0);
    }
  }, [stack]);

  let attempToCloseAll = false;

  const contextValue = useMemo(() => ({
    open, replace, close, closeAll, logStack
  }), [open, replace, close, closeAll, logStack]);

  return (
    <MenuHandlerContext value={contextValue}>
      {children}
      {createPortal(
        <div
          role="button"
          tabIndex={0}
          className={`absolute top-0 left-0 w-full h-full flex items-center justify-center z-[1000] overflow-hidden ${stack.length === 0 ? 'pointer-events-none' : ''}`}
          style={{ backgroundColor: stackTop?.options.dimBackground === true ? 'rgba(0, 0, 0, 0.7)' : 'transparent' }}
          onMouseDown={() => { attempToCloseAll = true; }}
          onMouseUp={() => {
            if (!attempToCloseAll) { return }
            closeAll();
          }}
          onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') closeAll(); }}
        >
          <div
            role="presentation"
            id="test123"
            className={`rounded-md overflow-hidden relative h-auto 
              transition-[opacity,transform,height,width] duration-200 origin-bottom-right 
            `}
            style={{ width: sizeClass, height: `${String(lastChildHeight)}px` }}
            onMouseDown={(e) => { e.stopPropagation(); }}
            onMouseUp={(e) => { e.stopPropagation(); }}
          >
            {stack.map((entry, index) => (
              <SlideInWrapper
                key={entry.id}
                isTop={index === stack.length - 1}
                isClosing={entry.isClosing}
                soonIsTop={entry.soonIsTop}
                options={entry.options}
              >
                {entry.element}
              </SlideInWrapper>
            ))}
          </div>
        </div>,
        document.body
      )}
    </MenuHandlerContext>
  );
}
</file>

<file path="src/examples/_sync/updateCounter_client.ts">
import { SessionLayout } from '../../../config';
import { Functions, SyncClientResponse , SyncClientInput, SyncServerOutput } from '../../../src/_sockets/apiTypes.generated';



// Types are imported from the generated file based on the _server.ts definition
type PagePath = 'examples';
type SyncName = 'updateCounter';
export interface SyncParams {
  clientInput: SyncClientInput<PagePath, SyncName>;

  serverOutput: SyncServerOutput<PagePath, SyncName>;
user: SessionLayout; // session data from any user that is in the room
  functions: Functions; // contains all functions that are available on the server in the functions folder
  roomCode: string; // room code
}

export const main = async ({ user, clientInput, serverOutput, functions, roomCode  }: SyncParams): Promise<SyncClientResponse> => {
  console.log('Sync client check:', user?.location?.pathName);

  // Check if user is on the examples page
  if (user?.location?.pathName === '/examples') {
    return {
      status: 'success',
      randomKey: true,
    };
  }

  // Return error to skip other clients
  return { status: 'error' };
};
</file>

<file path="src/main.tsx">
/* eslint-disable react-refresh/only-export-components -- tells linting to not get upset for exporting a non react hook in this file */
import { createRoot } from 'react-dom/client'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import { Toaster } from 'sonner'
import 'src/index.css'
import 'src/scrollbar-dark.css'
import VConsole from 'vconsole';

import { mobileConsole } from 'config'
import LocationProvider from 'src/_components/LocationProvider'

import { AvatarProvider } from './_components/AvatarProvider'
import ErrorPage from './_components/ErrorPage';
import { MenuHandlerProvider } from './_components/MenuHandler'
import TemplateProvider from './_components/TemplateProvider'
import { TranslationProvider } from './_components/TranslationProvider'
import { initializeSentry, SentryErrorBoundary } from './_functions/sentry'
import { SessionProvider } from './_providers/SessionProvider'
import { SocketStatusProvider } from './_providers/socketStatusProvider'

import type { Template } from './_components/TemplateProvider';

initializeSentry();

type PageWithTemplate = React.ComponentType & { template?: Template };
const getRoutes = (pages: Record<string, { default: PageWithTemplate, template?: Template }>) => {
  const routes = [];

  for (const [path, module] of Object.entries(pages)) {
    const pathSegments = path.split('/');
    if (pathSegments.some(segment => segment.startsWith('_'))) continue;

    const routePath = path.replace('./', '').replace('.tsx', '').toLowerCase() || '/';
    const subPath = routePath.endsWith('/page')
      ? routePath.slice(0, -5)
      : (routePath.endsWith('page')
        ? '/'
        : false);
    if (!subPath) continue;

    const template = module.template ?? 'plain';
    const Page = module.default;

    routes.push({
      path: subPath,
      element: (
        <LocationProvider>
          <TemplateProvider key={`${template}-${subPath}`} initialTemplate={template}>
            <Page />
          </TemplateProvider>
        </LocationProvider>
      ),
    });
  }

  return routes;
};

const pages: Record<string, { default: PageWithTemplate; template?: Template }> = import.meta.glob('./**/*.tsx', { eager: true });

// Import error page for router error handling

const router = createBrowserRouter([{
  path: '/',
  errorElement: <ErrorPage />,
  children: getRoutes(pages)
}])

if (mobileConsole) { new VConsole(); }

// Error fallback component for Sentry ErrorBoundary
const ErrorFallback = () => (
  <div className="w-full h-screen flex flex-col items-center justify-center bg-background text-foreground">
    <h1 className="text-2xl font-bold mb-4">Something went wrong</h1>
    <p className="text-muted-foreground mb-4">An unexpected error occurred. Please refresh the page.</p>
    <button
      onClick={() => { globalThis.location.reload(); }}
      className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:opacity-90"
    >
      Refresh Page
    </button>
  </div>
);

const root = document.querySelector("#root");
if (root) {
  createRoot(root).render(
    <SentryErrorBoundary fallback={<ErrorFallback />}>
      <div className='w-full h-safe m-0 p-0 overflow-hidden'>
        <Toaster richColors />
        <SocketStatusProvider>
          <SessionProvider>
            <TranslationProvider>
              <AvatarProvider>
                <MenuHandlerProvider>
                  <RouterProvider router={router} />
                </MenuHandlerProvider>
              </AvatarProvider>
            </TranslationProvider>
          </SessionProvider>
        </SocketStatusProvider>
      </div>
    </SentryErrorBoundary>
  );
}
</file>

<file path="src/settings/page.tsx">
import { useCallback, useEffect, useState } from "react";

import Avatar from "src/_components/Avatar";
import ThemeToggler from "src/_components/ThemeToggler";
import { useUpdateLanguage } from "src/_components/TranslationProvider";
import notify from "src/_functions/notify";
import { useTranslator } from "src/_functions/translator";
import { useSession } from "src/_providers/SessionProvider";
import { apiRequest } from "src/_sockets/apiRequest";

import { backendUrl } from "../../config";

const incrementAvatarVersion = (url: string) => {
  const match = /[?&]v=(\d+)/.exec(url);
  return match ? Number.parseInt(match[1]) + 1 : 1;
}

export const template = 'home';
export default function Home() {

  const { session } = useSession();
  const { updateTheme } = ThemeToggler();
  const setLanguage = useUpdateLanguage();
  const translate = useTranslator();

  const [newLanguage, setNewLanguage] = useState<'nl' | 'en' | 'de' | 'fr'>((session?.language ?? '') as 'nl' | 'en' | 'de' | 'fr');
  const [newAvatar, setNewAvatar] = useState<string>(session?.avatar ?? '');
  const [newName, setNewName] = useState<string>(session?.name ?? '');
  const [newTheme, setNewTheme] = useState<'light' | 'dark'>(session?.theme ?? 'dark');

  const saveUser = useCallback(async () => {
    if (!session) return;

    if (
      newLanguage === session.language
      && newAvatar === session.avatar
      && newName === session.name
      && newTheme === session.theme
    ) {
      notify.info({ key: 'settings.noChangesMade' })
      return;
    }
    const response = await apiRequest({
      name: "updateUser",
      data: {
        language: newLanguage === session.language ? undefined : newLanguage,
        avatar: newAvatar === session.avatar ? undefined : newAvatar,
        name: newName === session.name ? undefined : newName,
        theme: newTheme === session.theme ? undefined : newTheme,
      },
    })
    if (response.status === 'success') {
      notify.success({ key: 'settings.updatedUser' })
    } else {
      notify.error({ key: 'settings.failedUpdateUser' })
    }
  }, [newLanguage, newAvatar, newName, newTheme, session]);


  //? we trigger saveUser when the newAvatar changes so that the avatar is saved immidiatly, we dont call the saveUser in the onchange callback cause than it causes a race codition between the function calling and newAvatar having the new value
  useEffect(() => {
    if (!newAvatar) return;

    void saveUser();
  }, [newAvatar, saveUser])

  if (!session) return null;

  let url;

  if (newAvatar.includes('base64')) {
    url = new URL(newAvatar, globalThis.location.origin);
    url.search = ""; // remove query params
  }

  const displayUrl = newAvatar.includes('base64')
    ? url?.toString()
    : (newAvatar.startsWith("http")
      ? newAvatar
      : `${backendUrl}/uploads/${session.avatar}`)
  console.log(displayUrl)

  return (
    <div className='flex items-center justify-center w-full h-full bg-background'>
      <div className="bg-container border-2 border-container-border flex flex-col p-8 gap-4 rounded-2xl max-w-[360px] w-[90%]">

        <div className="flex gap-4 items-center">
          {newAvatar || session.avatar ? (
            <img src={displayUrl}
              alt="User avatar"
              className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none"></img>
          ) : (
            <div className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none">
              <Avatar
                user={{
                  name: session.name,
                  avatarFallback: session.avatarFallback
                }}
                textSize="text-4xl"
              />
            </div>
          )}
          <div className="space-y-2">
            <input type="file" className="hidden"></input>
            <button
              className="w-full py-1 bg-container2 border-container2-border border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                const input = document.querySelector('input[type="file"]');
                const inputElement = input as HTMLInputElement | null;
                if (inputElement) {
                  inputElement.click();
                  inputElement.addEventListener('change', () => {
                  const file = inputElement.files?.[0];
                  if (!file) return;
                  const maxSize = 4 * 1024 * 1024; // 4 MB
                  if (file.size > maxSize) {
                    notify.error({ key: 'settings.sizeToLarge' })
                    return;
                  }

                  notify.info({ key: 'settings.loadingImg' })
                  const reader = new FileReader();
                  reader.addEventListener('load', () => {
                    const result = reader.result;
                    if (typeof result === 'string') {
                      setNewAvatar(prevUrl => `${result}?v=${String(incrementAvatarVersion(prevUrl || ""))}`)
                    }
                    notify.success({ key: 'settings.imgLoaded' })
                  });
                  reader.readAsDataURL(file);
                  })
                }
              }}
            >
              {/* Change avatar */}
              {translate({ key: 'settings.changeAvatar' })}
            </button>
            {/* <button 
              className="w-full py-1 bg-wrong/50 border-wrong border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                ref.open(
                  <ConfirmMenu
                    title={(translate({ key: 'settings.changeAvatar' }))}
                    content={'asd'}
                    resolve={(success) => {
                      console.log(success)
                    }}
                  />
                )
              }}
            >
              {translate({ key: 'settings.deleteAvatar' })}
            </button> */}
            <div className="text-muted text-sm">
              {/* JPG, GIV or PNG. 1MB max. */}
              {translate({ key: 'settings.changeAvatarDescription' })}
            </div>
          </div>
        </div>

        <div className="space-y-2 w-full">
          <div className="text-lg font-semibold">Name</div>
          <input
            className={`w-full bg-container2 border-container2-border border-2 focus:outline-0 focus:border-container3-border transition-all duration-150 p-2 rounded-md`}
            value={newName}
            onChange={(e) => { setNewName(e.target.value) }}
          ></input>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Language */}
            {translate({ key: 'settings.language.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => {
                setNewLanguage('nl');
                setLanguage('nl');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage === 'nl' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* NL */}
              {translate({ key: 'settings.language.nl' })}
            </button>
            <button
              onClick={() => {
                setNewLanguage('en');
                setLanguage('en');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage === 'en' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* EN */}
              {translate({ key: 'settings.language.en' })}
            </button>
            <button
              onClick={() => {
                setNewLanguage('de');
                setLanguage('de');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage === 'de' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* DE */}
              {translate({ key: 'settings.language.de' })}
            </button>
            <button
              onClick={() => {
                setNewLanguage('fr');
                setLanguage('fr');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage === 'fr' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* FR */}
              {translate({ key: 'settings.language.fr' })}
            </button>
          </div>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Theme */}
            {translate({ key: 'settings.theme.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => {
                setNewTheme('light');
                updateTheme('light');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme === 'light' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Light mode */}
              {translate({ key: 'settings.theme.light' })}
            </button>
            <button
              onClick={() => {
                setNewTheme('dark');
                updateTheme('dark');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme === 'dark' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Dark mode */}
              {translate({ key: 'settings.theme.dark' })}
            </button>
          </div>
        </div>

        <button
          className="w-full bg-blue-500 text-white py-2 rounded-lg"
          onClick={() => void saveUser()}
        >
          {/* Save data */}
          {translate({ key: 'settings.saveChanges' })}
        </button>

      </div>
    </div>
  )
}
</file>

<file path="server/dev/hotReload.ts">
import chokidar from "chokidar";
import fs from "fs";
import { initializeApis, initializeFunctions, initializeSyncs } from "./loader";
import {
  shouldInjectTemplate,
  injectTemplate,
  isSyncServerFile,
  isSyncClientFile,
  getPairedSyncFile,
  extractClientInputFromFile,
  extractClientInputFromGeneratedTypes,
  extractSyncPagePath,
  extractSyncName,
  injectServerTemplateWithClientInput,
  updateClientFileForPairedServer,
  updateClientFileForDeletedServer,
  isEmptyFile
} from "./templateInjector";
import { generateTypeMapFile } from "./typeMapGenerator";
import { tryCatch } from "../functions/tryCatch";

// ----------------------------
// Watcher for Hot Reload + Type Generation
// ----------------------------

export const setupWatchers = () => {
  if (process.env.NODE_ENV !== "development") return;

  const handleAdd = async (path: string) => {
    console.log(path)
    const normalizedPath = path.replace(/\\/g, '/');

    // Check if this is a new empty file that needs a template
    if (shouldInjectTemplate(path)) {
      console.log(`[Watcher] New empty file detected: ${normalizedPath}`);

      // Special handling for sync server files when client already exists
      if (isSyncServerFile(normalizedPath)) {
        const clientPath = getPairedSyncFile(normalizedPath);
        if (clientPath && fs.existsSync(clientPath) && !isEmptyFile(clientPath)) {
          // Extract clientInput types from existing client file
          const clientInputTypes = extractClientInputFromFile(clientPath);
          if (clientInputTypes) {
            console.log(`[Watcher] Found existing client file, migrating types to server: ${clientPath}`);
            // Inject server template with pre-filled clientInput from client
            await injectServerTemplateWithClientInput(path, clientInputTypes);
            // Regenerate types
            await tryCatch(generateTypeMapFile);
            // Update client file to use imported types + add serverOutput
            await updateClientFileForPairedServer(clientPath);
            initializeSyncs();
            return;
          }
        }
      }

      // Default template injection
      const injected = await injectTemplate(path);
      if (injected) {
        // Don't continue processing - the template was just injected
        // The next 'change' event will handle it
        return;
      }
    }

    // Handle normal file additions
    handleChange(path);
  };

  const handleChange = async (path: string) => {
    console.log(path)
    const normalizedPath = path.replace(/\\/g, '/');

    // Skip if this is the generated type map file
    if (normalizedPath.includes('apiTypes.generated.ts')) {
      return;
    }

    if (normalizedPath.includes('_api/')) {
      // Reload the API handlers
      console.log(`[Watcher] Reloading API due to change in: ${normalizedPath}`);
      tryCatch(generateTypeMapFile);
      initializeApis();
    } else if (normalizedPath.includes('_sync/')) {
      console.log(`[Watcher] Reloading Sync due to change in: ${normalizedPath}`);
      tryCatch(generateTypeMapFile);
      initializeSyncs();
    }
  };

  const handleFunctionChange = (path: string) => {
    console.log(`[Watcher] Reloading Function due to change in: ${path.replace(/\\/g, '/')}`);
    initializeFunctions();
  };

  const handleDelete = async (path: string) => {
    const normalizedPath = path.replace(/\\/g, '/');

    if (normalizedPath.includes('_api/')) {
      console.log(`[Watcher] API file deleted: ${normalizedPath}`);
      generateTypeMapFile();
      initializeApis();
    } else if (normalizedPath.includes('_sync/')) {
      console.log(`[Watcher] Sync file deleted: ${normalizedPath}`);

      // Special handling for sync server file deletion when client exists
      if (isSyncServerFile(normalizedPath)) {
        const clientPath = getPairedSyncFile(normalizedPath);
        if (clientPath && fs.existsSync(clientPath)) {
          console.log(`[Watcher] Server file deleted, updating client to standalone: ${clientPath}`);

          // Extract clientInput types from generated types file (server file is already deleted)
          const pagePath = extractSyncPagePath(normalizedPath);
          const syncName = extractSyncName(normalizedPath);
          const clientInputTypes = extractClientInputFromGeneratedTypes(pagePath, syncName);

          if (clientInputTypes) {
            await updateClientFileForDeletedServer(clientPath, clientInputTypes);
          } else {
            // Fallback if types couldn't be extracted
            await updateClientFileForDeletedServer(clientPath, '{\n    // Types were in _server.ts - please add them here\n  }');
          }
        }
      }

      generateTypeMapFile();
      initializeSyncs();
    }
  };

  // Watch the main source folders
  chokidar.watch('src', { ignoreInitial: true })
    .on('add', handleAdd)
    .on('change', handleChange)
    .on('unlink', handleDelete);

  // Watch functions separately
  chokidar.watch('server/functions', { ignoreInitial: true })
    .on('add', handleFunctionChange)
    .on('change', handleFunctionChange);

  // Generate initial type map on startup
  console.log('[Watcher] Generating initial frontend type map...');
  generateTypeMapFile();
};
</file>

<file path="server/dev/typeMapGenerator.ts">
import fs from 'fs';
import path from 'path';
import { inferHttpMethod } from '../utils/httpApiUtils';

/**
 * Frontend Type Map Generator
 * 
 * Generates a complete type map for all API endpoints, enabling
 * type-safe apiRequest calls on the frontend.
 */

const SRC_DIR = path.join(process.cwd(), 'src');
const OUTPUT_FILE = path.join(SRC_DIR, '_sockets', 'apiTypes.generated.ts');

/**
 * Find all API files in the src directory
 */
const findAllApiFiles = (dir: string = SRC_DIR, results: string[] = []): string[] => {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;
        findAllApiFiles(fullPath, results);
      } else if (entry.isFile() && entry.name.endsWith('.ts')) {
        const relativePath = fullPath.replace(/\\/g, '/');
        if (relativePath.includes('/_api/')) {
          results.push(fullPath);
        }
      }
    }
  } catch (error) {
    console.error(`[TypeMapGenerator] Error scanning directory ${dir}:`, error);
  }

  return results;
};

/**
 * Find all Sync server files (_sync/*_server.ts) in the src directory
 */
const findAllSyncFiles = (dir: string = SRC_DIR, results: string[] = []): string[] => {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;
        findAllSyncFiles(fullPath, results);
      } else if (entry.isFile() && entry.name.endsWith('_server.ts')) {
        const relativePath = fullPath.replace(/\\/g, '/');
        if (relativePath.includes('/_sync/')) {
          results.push(fullPath);
        }
      }
    }
  } catch (error) {
    console.error(`[TypeMapGenerator] Error scanning directory ${dir}:`, error);
  }

  return results;
};

/**
 * Find all Sync client files (_sync/*_client.ts) in the src directory
 */
const findAllSyncClientFiles = (dir: string = SRC_DIR, results: string[] = []): string[] => {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;
        findAllSyncClientFiles(fullPath, results);
      } else if (entry.isFile() && entry.name.endsWith('_client.ts')) {
        const relativePath = fullPath.replace(/\\/g, '/');
        if (relativePath.includes('/_sync/')) {
          results.push(fullPath);
        }
      }
    }
  } catch (error) {
    console.error(`[TypeMapGenerator] Error scanning directory ${dir}:`, error);
  }

  return results;
};

const extractPagePath = (filePath: string): string => {
  const normalized = filePath.replace(/\\/g, '/');
  const match = normalized.match(/src\/(.+?)\/_api\//);
  return match ? match[1] : '';
};

const extractApiName = (filePath: string): string => {
  return path.basename(filePath, '.ts');
};

/**
 * Extract httpMethod export from an API file.
 * Returns the declared method or uses inferHttpMethod as fallback.
 */
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

const extractHttpMethod = (filePath: string, apiName: string): HttpMethod => {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Look for explicit export: export const httpMethod = 'GET';
    // or: export const httpMethod: 'GET' | 'POST' = 'GET';
    const methodMatch = content.match(/export\s+const\s+httpMethod\s*(?::[^=]+)?=\s*['"]([^'"]+)['"]/);
    if (methodMatch) {
      const method = methodMatch[1].toUpperCase() as HttpMethod;
      if (['GET', 'POST', 'PUT', 'DELETE'].includes(method)) {
        return method;
      }
    }

    // Use inferHttpMethod as fallback for consistent behavior
    return inferHttpMethod(apiName);
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting httpMethod from ${filePath}:`, error);
    return inferHttpMethod(apiName);
  }
};

// Sync-specific extractors
const extractSyncPagePath = (filePath: string): string => {
  const normalized = filePath.replace(/\\/g, '/');
  const match = normalized.match(/src\/(.+?)\/_sync\//);
  return match ? match[1] : '';
};

const extractSyncName = (filePath: string): string => {
  // Remove _server.ts or _client.ts suffix to get sync name
  // e.g., updateCounter_server.ts -> updateCounter
  // e.g., updateCounter_client.ts -> updateCounter
  const basename = path.basename(filePath, '.ts');
  return basename.replace(/_server$/, '').replace(/_client$/, '');
};

const extractBalancedBraces = (content: string, startIndex: number): string | null => {
  if (content[startIndex] !== '{') return null;

  let depth = 0;
  let i = startIndex;

  while (i < content.length) {
    if (content[i] === '{') depth++;
    else if (content[i] === '}') depth--;

    if (depth === 0) {
      return content.substring(startIndex, i + 1);
    }
    i++;
  }

  return null;
};

const cleanTypeString = (typeStr: string): string => {
  return typeStr
    .replace(/\/\/[^\n]*/g, '')
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/\s+/g, ' ')
    .replace(/{\s+/g, '{ ')
    .replace(/\s+}/g, ' }')
    .replace(/;\s+/g, '; ')
    .replace(/,\s+/g, ', ')
    .trim();
};

/**
 * Extract the data type info from ApiParams interface
 * Returns { typeMap: Map of property name -> type, fullType: the complete data type string }
 */
interface DataTypeInfo {
  typeMap: Map<string, string>;
  fullType: string;
}

const extractDataTypeInfo = (content: string): DataTypeInfo => {
  const typeMap = new Map<string, string>();
  let fullType = 'any';

  // Find ApiParams interface
  const apiParamsMatch = content.match(/interface\s+ApiParams\s*\{/);
  if (!apiParamsMatch) return { typeMap, fullType };

  const apiParamsStart = apiParamsMatch.index!;
  const apiParamsBody = extractBalancedBraces(content, content.indexOf('{', apiParamsStart));
  if (!apiParamsBody) return { typeMap, fullType };

  // Find the data property
  const dataMatch = apiParamsBody.match(/data\s*:\s*\{/);
  if (!dataMatch) return { typeMap, fullType };

  const dataStart = apiParamsBody.indexOf('{', dataMatch.index!);
  const dataObj = extractBalancedBraces(apiParamsBody, dataStart);
  if (!dataObj) return { typeMap, fullType };

  // Store the full type (cleaned up)
  fullType = cleanTypeString(dataObj);

  // Remove comments before parsing properties
  const inner = dataObj.slice(1, -1)
    .replace(/\/\/[^\n]*/g, '')      // Remove line comments
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
    .trim();

  // Match property definitions like "name: string;" or "email?: string;"
  const propRegex = /^\s*(\w+)\s*(\?)?\s*:\s*([^;]+);/gm;
  let match;

  while ((match = propRegex.exec(inner)) !== null) {
    const propName = match[1].trim();
    const propType = match[3].trim();
    if (propName && propType) {
      typeMap.set(propName, propType);
    }
  }

  return { typeMap, fullType };
};

/**
 * Extract type information from SyncParams interface's clientInput property
 * Similar to extractDataTypeInfo but for sync files
 */
const extractSyncDataTypeInfo = (content: string): DataTypeInfo => {
  const typeMap = new Map<string, string>();
  let fullType = 'any';

  // Find SyncParams interface
  const syncParamsMatch = content.match(/interface\s+SyncParams\s*\{/);
  if (!syncParamsMatch) return { typeMap, fullType };

  const syncParamsStart = syncParamsMatch.index!;
  const syncParamsBody = extractBalancedBraces(content, content.indexOf('{', syncParamsStart));
  if (!syncParamsBody) return { typeMap, fullType };

  // Find the clientInput property (try clientInput first, then fall back to clientData for backward compat)
  let clientDataMatch = syncParamsBody.match(/clientInput\s*:\s*\{/);
  if (!clientDataMatch) {
    clientDataMatch = syncParamsBody.match(/clientData\s*:\s*\{/);
  }
  if (!clientDataMatch) return { typeMap, fullType };

  const clientDataStart = syncParamsBody.indexOf('{', clientDataMatch.index!);
  const clientDataObj = extractBalancedBraces(syncParamsBody, clientDataStart);
  if (!clientDataObj) return { typeMap, fullType };

  // Store the full type (cleaned up)
  fullType = cleanTypeString(clientDataObj);

  // Remove comments before parsing properties
  const inner = clientDataObj.slice(1, -1)
    .replace(/\/\/[^\n]*/g, '')      // Remove line comments
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
    .trim();

  // Match property definitions like "name: string;" or "email?: string;"
  const propRegex = /^\s*(\w+)\s*(\?)?\s*:\s*([^;]+);/gm;
  let match;

  while ((match = propRegex.exec(inner)) !== null) {
    const propName = match[1].trim();
    const propType = match[3].trim();
    if (propName && propType) {
      typeMap.set(propName, propType);
    }
  }

  return { typeMap, fullType };
};


/**
 * Extract local variable assignments before the return statement
 * Returns a map of variable name -> inferred type
 */
const extractLocalVariables = (content: string): Map<string, string> => {
  const varMap = new Map<string, string>();

  // Find the main function body - handle both "const main" and "export const main"
  // The regex ends with `=> {` so we can find the body brace at the end of the match
  const mainMatch = content.match(/(?:export\s+)?const\s+main\s*=\s*async\s*\([^)]*\)\s*(?::\s*[^=]+)?\s*=>\s*\{/);
  if (!mainMatch) {
    return varMap;
  }

  // The function body starts at the `{` at the END of our regex match
  const mainStart = mainMatch.index! + mainMatch[0].length - 1;
  const mainBody = extractBalancedBraces(content, mainStart);
  if (!mainBody) {
    return varMap;
  }



  // Look for const/let declarations - handle both \r\n and \n line endings
  const varRegex = /(?:const|let)\s+(\w+)\s*=\s*([^;\r\n]+)/g;
  let match;

  while ((match = varRegex.exec(mainBody)) !== null) {
    const varName = match[1].trim();
    const varValue = match[2].trim();

    // Infer type from the value
    const inferredType = inferTypeFromLiteralValue(varValue);

    varMap.set(varName, inferredType);
  }


  return varMap;
};

/**
 * Infer type from a literal value expression
 */
const inferTypeFromLiteralValue = (value: string): string => {
  const trimmed = value.trim();

  // String literal
  if (trimmed.startsWith("'") || trimmed.startsWith('"') || trimmed.startsWith('`')) {
    return 'string';
  }

  // String concatenation
  if (trimmed.includes('+') && (trimmed.includes("'") || trimmed.includes('"') || trimmed.includes('`'))) {
    return 'string';
  }

  // Number
  if (/^-?\d+(\.\d+)?$/.test(trimmed)) {
    return 'number';
  }

  // Boolean
  if (trimmed === 'true' || trimmed === 'false') {
    return 'boolean';
  }

  // Array literal
  if (trimmed.startsWith('[')) {
    return 'any[]';
  }

  // Object literal
  if (trimmed.startsWith('{')) {
    return 'object';
  }

  // Date
  if (trimmed.includes('new Date') || trimmed.includes('.toISOString')) {
    return 'string';
  }

  return 'any';
};

const getInputTypeFromFile = (filePath: string): string => {
  const DEFAULT_TYPE = '{ }';

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    const apiParamsMatch = content.match(/interface\s+ApiParams\s*\{/);
    if (!apiParamsMatch) return DEFAULT_TYPE;

    const apiParamsStart = apiParamsMatch.index!;
    const apiParamsBody = extractBalancedBraces(content, content.indexOf('{', apiParamsStart));
    if (!apiParamsBody) return DEFAULT_TYPE;

    const dataMatch = apiParamsBody.match(/data\s*:\s*/);
    if (!dataMatch) return DEFAULT_TYPE;

    const dataStart = dataMatch.index! + dataMatch[0].length;
    const afterData = apiParamsBody.substring(dataStart);

    if (afterData.trimStart().startsWith('{')) {
      const braceStart = afterData.indexOf('{');
      const objectType = extractBalancedBraces(afterData, braceStart);
      if (objectType) {
        const cleaned = cleanTypeString(objectType);
        if (cleaned !== '{ }' && cleaned !== '{}') {
          return cleaned;
        }
        return DEFAULT_TYPE;
      }
    }

    const typeRefMatch = afterData.match(/^([A-Za-z][A-Za-z0-9]*(?:<[^>]+>)?)/);
    if (typeRefMatch) {
      const typeRef = typeRefMatch[1];
      if (typeRef.startsWith('Record<')) {
        return typeRef;
      }
      return DEFAULT_TYPE;
    }

    return DEFAULT_TYPE;
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting input type from ${filePath}:`, error);
    return DEFAULT_TYPE;
  }
};

/**
 * Infer type for a result property value, using context from data types and local vars
 */
const inferTypeFromValueWithContext = (
  value: string,
  dataTypes: Map<string, string>,
  localVars: Map<string, string>,
  fullDataType: string = 'any'
): string => {
  const trimmed = value.trim();

  // String literal
  if (trimmed.startsWith("'") || trimmed.startsWith('"') || trimmed.startsWith('`')) {
    return 'string';
  }

  // Number literal
  if (/^-?\d+(\.\d+)?$/.test(trimmed)) {
    return 'number';
  }

  // Boolean literal
  if (trimmed === 'true' || trimmed === 'false') {
    return 'boolean';
  }

  // Array literal
  if (trimmed.startsWith('[')) {
    return 'any[]';
  }

  // Object literal
  if (trimmed.startsWith('{')) {
    const nested = extractBalancedBraces(trimmed, 0);
    if (nested) {
      return inferTypeFromObjectLiteralWithContext(nested, dataTypes, localVars);
    }
    return 'object';
  }

  // data.X reference - look up from data types
  const dataRefMatch = trimmed.match(/^data\.(\w+)$/);
  if (dataRefMatch) {
    const propName = dataRefMatch[1];
    if (dataTypes.has(propName)) {
      return dataTypes.get(propName)!;
    }
    return 'any';
  }

  // user.X reference - common types
  const userRefMatch = trimmed.match(/^user\.(\w+)$/);
  if (userRefMatch) {
    const propName = userRefMatch[1];
    // Common user properties
    const userTypes: Record<string, string> = {
      id: 'string',
      name: 'string',
      email: 'string',
      admin: 'boolean',
      token: 'string',
    };
    return userTypes[propName] || 'any';
  }

  // Local variable reference - special case for 'data'
  if (trimmed === 'data' && fullDataType !== 'any') {
    return fullDataType;
  }

  // Local variable reference
  if (/^[a-z_]\w*$/i.test(trimmed) && localVars.has(trimmed)) {
    return localVars.get(trimmed)!;
  }

  // Date expression
  if (trimmed.includes('new Date') || trimmed.includes('toISOString') || trimmed.includes('Date.now')) {
    return 'string';
  }

  // Nullish coalescing or ternary - take the type of the fallback
  if (trimmed.includes('??')) {
    const parts = trimmed.split('??');
    if (parts.length >= 2) {
      const fallback = parts[parts.length - 1].trim();
      return inferTypeFromValueWithContext(fallback, dataTypes, localVars);
    }
  }

  return 'any';
};

/**
 * Helper to strip comments from code string
 */
const stripComments = (str: string): string => {
  return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
};

/**
 * Infer type from an object literal with context
 */
const inferTypeFromObjectLiteralWithContext = (
  objLiteral: string,
  dataTypes: Map<string, string>,
  localVars: Map<string, string>,
  fullDataType: string = 'any'
): string => {
  // Strip comments first to avoid parsing commented-out code
  const cleanLiteral = stripComments(objLiteral);
  const inner = cleanLiteral.slice(1, -1).trim();
  if (!inner) return '{ }';

  // Split by properties
  const properties: string[] = [];
  let depth = 0;
  let current = '';

  for (let i = 0; i < inner.length; i++) {
    const char = inner[i];
    if (char === '{' || char === '[' || char === '(') depth++;
    else if (char === '}' || char === ']' || char === ')') depth--;

    if (char === ',' && depth === 0) {
      if (current.trim()) properties.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  if (current.trim()) properties.push(current.trim());

  const typeProperties: string[] = [];

  for (const prop of properties) {
    const colonIndex = prop.indexOf(':');

    if (colonIndex === -1) {
      // Shorthand property: just "varName" means "varName: varName"
      const key = prop.trim();
      if (/^[a-z_]\w*$/i.test(key)) {
        let inferredType = 'any';

        // Check if it matches a local variable
        if (localVars.has(key)) {
          inferredType = localVars.get(key)!;
        } else if (key === 'result') {
          // Special case for 'result' in API response
          inferredType = 'any';
        }

        typeProperties.push(`${key}: ${inferredType}`);
      }
      continue;
    }

    const key = prop.substring(0, colonIndex).trim();
    const value = prop.substring(colonIndex + 1).trim();

    // Recursively handle nested objects
    if (value.startsWith('{') && value.endsWith('}')) {
      const nested = value;
      // Pass the fullDataType context but we can't narrow it further easily without complex parsing
      // So we just recurse
      const inferredNested = inferTypeFromObjectLiteralWithContext(nested, dataTypes, localVars);
      typeProperties.push(`${key}: ${inferredNested}`);
      continue;
    }

    let inferredType = 'any';

    // Preserve status literal for tagged unions
    if (key === 'status') {
      const cleanVal = value.replace(/['"`]/g, '');
      if (cleanVal === 'success' || cleanVal === 'error') {
        typeProperties.push(`${key}: '${cleanVal}'`);
        continue;
      }
    }

    if (value.startsWith("'") || value.startsWith('"') || value.startsWith('`')) {
      inferredType = 'string';
    } else if (value.includes('+') && (value.includes("'") || value.includes('"') || value.includes('`'))) {
      // String concatenation detected
      inferredType = 'string';
    } else if (/^-?\d+(\.\d+)?$/.test(value)) {
      inferredType = 'number';
    } else if (value === 'true' || value === 'false') {
      inferredType = 'boolean';
    } else if (value.startsWith('new Date') || value === 'Date.now()' || value.includes('.toISOString()') || value.includes('.toDateString()')) {
      // Date detection
      inferredType = 'Date';
    } else if (value.startsWith('[') && value.endsWith(']')) {
      // Array literal detection
      inferredType = 'any[]';
    } else if (value === 'null') {
      inferredType = 'null';
    } else if (value === 'undefined') {
      inferredType = 'undefined';
    } else if ((value.startsWith('data.') || value.startsWith('clientData.')) && fullDataType !== 'any') {
      // Handle both data. (API) and clientData. (Sync) prefixes
      // Only proceed if it looks like a clean property access (no spaces, operators)
      if (/^[a-zA-Z0-9_$.]+$/.test(value)) {
        // It's referencing a property of the input data
        // e.g. data.name => string, clientData.increase => boolean
        const propName = value.split('.')[1]; // basic support for 1 level
        // extract type from fullDataType string
        const propertyMatch = new RegExp(`${propName}\\??\\s*:\\s*([^;]+)`).exec(fullDataType);
        if (propertyMatch) {
          inferredType = propertyMatch[1].trim();
        }
      }
    } else if (localVars.has(value)) {
      inferredType = localVars.get(value)!;
    }

    typeProperties.push(`${key}: ${inferredType}`);
  }

  if (typeProperties.length > 0) {
    return `{ ${typeProperties.join('; ')} }`;
  }

  return '{ }';
};

const getOutputTypeFromFile = (filePath: string): string => {
  const DEFAULT_TYPE = '{ status: string }';

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract context for type inference
    const { typeMap: dataTypes, fullType: fullDataType } = extractDataTypeInfo(content);
    const localVars = extractLocalVariables(content);

    // Scan for ALL return statements to build a union type
    // Strip comments from entire content FIRST to avoid matching commented return statements
    const strippedContent = stripComments(content);

    const returnRegex = /return\s*\{/g;
    let match;
    const returnTypes = new Set<string>();

    while ((match = returnRegex.exec(strippedContent)) !== null) {
      const returnStart = strippedContent.indexOf('{', match.index!);
      const returnBodyRaw = extractBalancedBraces(strippedContent, returnStart);

      if (returnBodyRaw) {
        const returnBody = returnBodyRaw;
        if (returnBody && returnBody.includes('status:')) {
          const inferred = inferTypeFromObjectLiteralWithContext(returnBody, dataTypes, localVars, fullDataType);
          returnTypes.add(inferred);
        }
      }
    }

    if (returnTypes.size > 0) {
      return Array.from(returnTypes).join(' | ');
    }

    return DEFAULT_TYPE;
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting output type from ${filePath}:`, error);
    return DEFAULT_TYPE;
  }
};

// ═══════════════════════════════════════════════════════════════════════════════
// Sync Type Extraction
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Extract clientData type from sync server file's SyncParams interface
 * Similar to how API files define data in ApiParams
 */
const getSyncClientDataType = (filePath: string): string => {
  const DEFAULT_TYPE = '{ }';

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Look for interface SyncParams with clientInput/clientData property
    const syncParamsMatch = content.match(/interface\s+SyncParams\s*\{/);
    if (syncParamsMatch) {
      const paramsStart = syncParamsMatch.index!;
      const paramsBody = extractBalancedBraces(content, content.indexOf('{', paramsStart));
      if (paramsBody) {
        // Look for clientInput property first (new naming), then clientData (backward compat)
        let clientDataMatch = paramsBody.match(/clientInput\s*:\s*/);
        if (!clientDataMatch) {
          clientDataMatch = paramsBody.match(/clientData\s*:\s*/);
        }
        if (clientDataMatch) {
          const dataStart = paramsBody.indexOf(':', clientDataMatch.index!) + 1;
          const afterColon = paramsBody.substring(dataStart).trim();

          if (afterColon.startsWith('{')) {
            const typeBody = extractBalancedBraces(afterColon, 0);
            if (typeBody) {
              return cleanTypeString(typeBody);
            }
          }
        }
      }
    }

    // Fallback: Look for clientInput usage to infer type (also check clientData for backward compat)
    // Pattern: clientInput.increase, clientInput.value, etc.
    const clientInputUsages = content.matchAll(/clientInput\.(\\w+)/g);
    const properties: string[] = [];
    for (const match of clientInputUsages) {
      if (!properties.includes(match[1])) {
        properties.push(`${match[1]}: any`);
      }
    }
    // Also check clientData for backward compatibility
    const clientDataUsages = content.matchAll(/clientData\.(\\w+)/g);
    for (const match of clientDataUsages) {
      if (!properties.includes(match[1])) {
        properties.push(`${match[1]}: any`);
      }
    }
    if (properties.length > 0) {
      return `{ ${properties.join('; ')} }`;
    }

    return DEFAULT_TYPE;
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting sync clientData type from ${filePath}:`, error);
    return DEFAULT_TYPE;
  }
};

/**
 * Extract serverOutput type from sync server file's return statement
 */
const getSyncServerOutputType = (filePath: string): string => {
  const DEFAULT_TYPE = '{ status: string }';

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract context for type inference - use SyncParams extraction for sync files
    const { typeMap: dataTypes, fullType: fullDataType } = extractSyncDataTypeInfo(content);
    const localVars = extractLocalVariables(content);

    // Strip comments from entire content FIRST to avoid matching commented return statements
    const strippedContent = stripComments(content);

    // Scan for ALL return statements to build a union type
    const returnRegex = /return\s*\{/g;
    let match;
    const returnTypes = new Set<string>();

    while ((match = returnRegex.exec(strippedContent)) !== null) {
      const returnStart = strippedContent.indexOf('{', match.index!);
      const returnBodyRaw = extractBalancedBraces(strippedContent, returnStart);

      if (returnBodyRaw) {
        const returnBody = returnBodyRaw;
        if (returnBody && returnBody.includes('status:')) {
          const inferred = inferTypeFromObjectLiteralWithContext(returnBody, dataTypes, localVars, fullDataType);
          returnTypes.add(inferred);
        }
      }
    }

    if (returnTypes.size > 0) {
      return Array.from(returnTypes).join(' | ');
    }

    return DEFAULT_TYPE;
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting sync serverOutput type from ${filePath}:`, error);
    return DEFAULT_TYPE;
  }
};

/**
 * Extract clientOutput type from sync client file's return statement
 * Only extracts success returns (error returns are skipped at runtime)
 */
const getSyncClientOutputType = (filePath: string): string => {
  const DEFAULT_TYPE = '{ }';

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract context for type inference (clientData from SyncParams)
    const { typeMap: dataTypes, fullType: fullDataType } = extractSyncDataTypeInfo(content);
    const localVars = extractLocalVariables(content);

    // Strip comments from entire content FIRST to avoid matching commented return statements
    const strippedContent = stripComments(content);

    // Scan for ALL return statements, but only include success ones
    const returnRegex = /return\s*\{/g;
    let match;
    const returnTypes = new Set<string>();

    while ((match = returnRegex.exec(strippedContent)) !== null) {
      const returnStart = strippedContent.indexOf('{', match.index!);
      const returnBodyRaw = extractBalancedBraces(strippedContent, returnStart);

      if (returnBodyRaw) {
        const returnBody = returnBodyRaw;
        // Only include success returns (skip error returns as they don't reach clients)
        // Handle both single and double quotes: 'success' or "success"
        const isSuccess = returnBody.includes("'success'") || returnBody.includes('"success"');
        if (returnBody && returnBody.includes("status:") && isSuccess) {
          const inferred = inferTypeFromObjectLiteralWithContext(returnBody, dataTypes, localVars, fullDataType);
          returnTypes.add(inferred);
        }
      }
    }

    if (returnTypes.size > 0) {
      return Array.from(returnTypes).join(' | ');
    }

    return DEFAULT_TYPE;
  } catch (error) {
    console.error(`[TypeMapGenerator] Error extracting sync clientOutput type from ${filePath}:`, error);
    return DEFAULT_TYPE;
  }
};

export const generateTypeMapFile = (): void => {
  // ═══════════════════════════════════════════════════════════════════════════
  // Collect API Types
  // ═══════════════════════════════════════════════════════════════════════════
  const apiFiles = findAllApiFiles();
  const typesByPage = new Map<string, Map<string, { input: string; output: string; method: HttpMethod }>>();

  console.log(`[TypeMapGenerator] Found ${apiFiles.length} API files`);

  for (const filePath of apiFiles) {
    const pagePath = extractPagePath(filePath);
    const apiName = extractApiName(filePath);

    if (!pagePath || !apiName) continue;

    const inputType = getInputTypeFromFile(filePath);
    const outputType = getOutputTypeFromFile(filePath);
    const httpMethod = extractHttpMethod(filePath, apiName);

    console.log(`[TypeMapGenerator] API: ${pagePath}/${apiName} (${httpMethod})`);

    if (!typesByPage.has(pagePath)) {
      typesByPage.set(pagePath, new Map());
    }
    typesByPage.get(pagePath)!.set(apiName, { input: inputType, output: outputType, method: httpMethod });
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Collect Sync Types
  // ═══════════════════════════════════════════════════════════════════════════
  const syncServerFiles = findAllSyncFiles();
  const syncClientFiles = findAllSyncClientFiles();
  const syncTypesByPage = new Map<string, Map<string, { clientInput: string; serverOutput: string; clientOutput: string }>>();

  console.log(`[TypeMapGenerator] Found ${syncServerFiles.length} Sync server files, ${syncClientFiles.length} Sync client files`);

  // Build a unified map of all syncs (key: "pagePath/syncName")
  const allSyncs = new Map<string, {
    pagePath: string;
    syncName: string;
    serverFile?: string;
    clientFile?: string;
  }>();

  // Add all server files to the map
  for (const serverFile of syncServerFiles) {
    const pagePath = extractSyncPagePath(serverFile);
    const syncName = extractSyncName(serverFile);
    if (!pagePath || !syncName) continue;

    const key = `${pagePath}/${syncName}`;
    const existing = allSyncs.get(key) || { pagePath, syncName };
    existing.serverFile = serverFile;
    allSyncs.set(key, existing);
  }

  // Add all client files to the map (may create new entries or add to existing)
  for (const clientFile of syncClientFiles) {
    const pagePath = extractSyncPagePath(clientFile);
    const syncName = extractSyncName(clientFile);
    if (!pagePath || !syncName) continue;

    const key = `${pagePath}/${syncName}`;
    const existing = allSyncs.get(key) || { pagePath, syncName };
    existing.clientFile = clientFile;
    allSyncs.set(key, existing);
  }

  // Process each sync with fallback logic
  for (const [key, { pagePath, syncName, serverFile, clientFile }] of allSyncs) {
    // clientInput: server file is primary, client file is fallback
    let clientInputType = '{ }';
    if (serverFile) {
      clientInputType = getSyncClientDataType(serverFile);
    } else if (clientFile) {
      clientInputType = getSyncClientDataType(clientFile);
    }

    // serverOutput: from server file's return (or empty if no server file)
    let serverOutputType = '{ }';
    if (serverFile) {
      serverOutputType = getSyncServerOutputType(serverFile);
    }

    // clientOutput: from client file's return (or empty if no client file)
    let clientOutputType = '{ }';
    if (clientFile) {
      clientOutputType = getSyncClientOutputType(clientFile);
    }

    console.log(`[TypeMapGenerator] Sync: ${pagePath}/${syncName} (server: ${!!serverFile}, client: ${!!clientFile})`);

    if (!syncTypesByPage.has(pagePath)) {
      syncTypesByPage.set(pagePath, new Map());
    }
    syncTypesByPage.get(pagePath)!.set(syncName, { clientInput: clientInputType, serverOutput: serverOutputType, clientOutput: clientOutputType });
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Generate Output File
  // ═══════════════════════════════════════════════════════════════════════════
  let content = `/**
 * Auto-generated type map for all API and Sync endpoints.
 * Enables type-safe apiRequest and syncRequest calls.
 */

import { PrismaClient } from "@prisma/client";
import { SessionLayout } from "config";

export interface Functions {
  prisma: PrismaClient;

  saveSession: (sessionId: string, data: SessionLayout) => Promise<boolean>;
  getSession: (sessionId: string) => Promise<SessionLayout | null>;
  deleteSession: (sessionId: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;

  [key: string]: any; // allows for other functions that are not defined as a type but do exist in the functions folder
};

// ═══════════════════════════════════════════════════════════════════════════════
// API Type Definitions
// ═══════════════════════════════════════════════════════════════════════════════

export type ApiResponse<T = any> =
  | { status: 'success'; result: T }
  | { status: 'error'; errorCode?: string; errorParams?: { key: string; value: string | number | boolean; }[] }
  | { status: 'error'; message?: string; };

// ═══════════════════════════════════════════════════════════════════════════════
// API Type Map
// ═══════════════════════════════════════════════════════════════════════════════

export interface ApiTypeMap {
`;

  const sortedPages = Array.from(typesByPage.keys()).sort();

  for (const pagePath of sortedPages) {
    const apis = typesByPage.get(pagePath)!;
    const sortedApis = Array.from(apis.keys()).sort();

    content += `  '${pagePath}': {\n`;

    for (const apiName of sortedApis) {
      const { input, output, method } = apis.get(apiName)!;
      content += `    '${apiName}': {\n`;
      content += `      input: ${input};\n`;
      content += `      output: ${output};\n`;
      content += `      method: '${method}';\n`;
      content += `    };\n`;
    }

    content += `  };\n`;
  }

  content += `}

// HTTP Method type
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// API Type helpers
export type PagePath = keyof ApiTypeMap;
export type ApiName<P extends PagePath> = keyof ApiTypeMap[P];
export type ApiInput<P extends PagePath, N extends ApiName<P>> = ApiTypeMap[P][N] extends { input: infer I } ? I : never;
export type ApiOutput<P extends PagePath, N extends ApiName<P>> = ApiTypeMap[P][N] extends { output: infer O } ? O : never;
export type ApiMethod<P extends PagePath, N extends ApiName<P>> = ApiTypeMap[P][N] extends { method: infer M } ? M : never;

// Full API path helper (can be used for debugging)
export type FullApiPath<P extends PagePath, N extends ApiName<P>> = \`api/\${P}/\${N & string}\`;

// ═══════════════════════════════════════════════════════════════════════════════
// Runtime API Method Map (for abort controller logic)
// ═══════════════════════════════════════════════════════════════════════════════

export const apiMethodMap: Record<string, Record<string, HttpMethod>> = {
`;

  // Add runtime method map
  for (const pagePath of sortedPages) {
    const apis = typesByPage.get(pagePath)!;
    const sortedApis = Array.from(apis.keys()).sort();

    content += `  '${pagePath}': {\n`;
    for (const apiName of sortedApis) {
      const { method } = apis.get(apiName)!;
      content += `    '${apiName}': '${method}',\n`;
    }
    content += `  },\n`;
  }

  content += `};

/**
 * Get the HTTP method for an API. Used by apiRequest for abort controller logic.
 */
export const getApiMethod = (pagePath: string, apiName: string): HttpMethod | undefined => {
  return apiMethodMap[pagePath]?.[apiName];
};


// Sync Type Definitions
// ═══════════════════════════════════════════════════════════════════════════════

export type SyncServerResponse<T = any> =
  | { status: 'success' } & T
  | { status: 'error'; message?: string };

export type SyncClientResponse<T = any> =
  | { status: 'success' } & T
  | { status: 'error'; message?: string };

// ═══════════════════════════════════════════════════════════════════════════════
// Sync Type Map
// ═══════════════════════════════════════════════════════════════════════════════

export interface SyncTypeMap {
`;

  const sortedSyncPages = Array.from(syncTypesByPage.keys()).sort();

  for (const pagePath of sortedSyncPages) {
    const syncs = syncTypesByPage.get(pagePath)!;
    const sortedSyncs = Array.from(syncs.keys()).sort();

    content += `  '${pagePath}': {\n`;

    for (const syncName of sortedSyncs) {
      const { clientInput, serverOutput, clientOutput } = syncs.get(syncName)!;
      content += `    '${syncName}': {\n`;
      content += `      clientInput: ${clientInput};\n`;
      content += `      serverOutput: ${serverOutput};\n`;
      content += `      clientOutput: ${clientOutput};\n`;
      content += `    };\n`;
    }

    content += `  };\n`;
  }

  content += `}

// Sync Type helpers
export type SyncPagePath = keyof SyncTypeMap;
export type SyncName<P extends SyncPagePath> = keyof SyncTypeMap[P];
export type SyncClientInput<P extends SyncPagePath, N extends SyncName<P>> = SyncTypeMap[P][N] extends { clientInput: infer C } ? C : never;
export type SyncServerOutput<P extends SyncPagePath, N extends SyncName<P>> = SyncTypeMap[P][N] extends { serverOutput: infer S } ? S : never;
export type SyncClientOutput<P extends SyncPagePath, N extends SyncName<P>> = SyncTypeMap[P][N] extends { clientOutput: infer O } ? O : never;

// Full Sync path helper (can be used for debugging)
export type FullSyncPath<P extends SyncPagePath, N extends SyncName<P>> = \`sync/\${P}/\${N & string}\`;
`;

  try {
    fs.writeFileSync(OUTPUT_FILE, content, 'utf-8');
    console.log(`[TypeMapGenerator] Generated: ${OUTPUT_FILE}`);
  } catch (error) {
    console.error(`[TypeMapGenerator] Error writing type map:`, error);
  }
};
</file>

<file path="server/sockets/handleApiRequest.ts">
import { tryCatch } from '../functions/tryCatch';
import { apis, functions } from '../prod/generatedApis'
import { devApis, devFunctions } from "../dev/loader"
import { apiMessage } from './socket';
import { getSession } from '../functions/session';
import config, { SessionLayout } from '../../config';
import { Socket } from 'socket.io';
import { logout } from './utils/logout';
import { validateRequest } from '../utils/validateRequest';
import { captureException } from '../utils/sentry';
import { checkRateLimit } from '../utils/rateLimiter';

type handleApiRequestType = {
  msg: apiMessage,
  socket: Socket,
  token: string | null,
}

export default async function handleApiRequest({ msg, socket, token }: handleApiRequestType) {
  //? This event gets triggered when the client uses the apiRequest function
  //? We validate the message, check auth then execute

  if (typeof msg != 'object') {
    console.log('socket message was not a json object!!!!', 'red')
    return;
  }

  const { name, data, responseIndex } = msg;
  const user = await getSession(token)

  if (!responseIndex && typeof responseIndex !== 'number') {
    console.log('no response index given!!!!', 'red')
    return;
  }

  //? 'logout' needs special handling since it requires socket access
  if (name == 'logout') {
    await logout({ token, socket, userId: user?.id || null });
    return socket.emit(`apiResponse-${responseIndex}`, { result: true });
  }

  //? Built-in API handlers

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return socket.emit(`apiResponse-${responseIndex}`, {
      status: "error",
      message: `Invalid request: name=${name}, data=${JSON.stringify(data)}`
    });
  }

  console.log(`api: ${name} called`, 'blue');

  const apisObject = process.env.NODE_ENV == 'development' ? devApis : apis;

  //? Check if API exists
  if (!apisObject[name]) {
    return socket.emit(`apiResponse-${responseIndex}`, {
      status: "error",
      message: `API not found: ${name}`
    });
  }

  const { auth, main, schema } = apisObject[name];

  //? Auth validation: check login requirement
  if (auth.login) {
    if (!user?.id) {
      console.log(`ERROR: API ${name} requires login`, 'red');
      return socket.emit(`apiResponse-${responseIndex}`, {
        status: "error",
        message: 'Authentication required'
      });
    }
  }

  //? Auth validation: check additional requirements
  const authResult = validateRequest({ auth, user: user as SessionLayout });
  if (authResult.status === "error") {
    console.log(`ERROR: Auth failed for ${name}: ${authResult.message}`, 'red');
    return socket.emit(`apiResponse-${responseIndex}`, authResult);
  }

  //? Rate limiting check
  const apiRateLimit = apisObject[name].rateLimit;
  const effectiveLimit = apiRateLimit !== undefined
    ? apiRateLimit
    : config.rateLimiting.defaultApiLimit;

  if (effectiveLimit !== false && effectiveLimit > 0) {
    const rateLimitKey = user?.id
      ? `user:${user.id}:api:${name}`
      : `ip:${socket.handshake.address}:api:${name}`;

    const { allowed, remaining, resetIn } = checkRateLimit({
      key: rateLimitKey,
      limit: effectiveLimit,
      windowMs: config.rateLimiting.windowMs
    });

    if (!allowed) {
      console.log(`Rate limit exceeded for ${name}`, 'yellow');
      return socket.emit(`apiResponse-${responseIndex}`, {
        status: 'error',
        message: `Rate limit exceeded. Try again in ${resetIn} seconds.`,
        rateLimitRemaining: remaining,
        rateLimitResetIn: resetIn
      });
    }
  }

  //? Execute the API handler
  const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;
  const [error, result] = await tryCatch(
    async () => await main({ data, user, functions: functionsObject })
  );

  if (error) {
    console.log(`ERROR in ${name}:`, error, 'red');
    captureException(error, { api: name, userId: user?.id });
    socket.emit(`apiResponse-${responseIndex}`, {
      status: "error",
      message: error.message || 'Internal server error'
    });
  } else if (result) {
    console.log(`api: ${name} completed`, 'blue');

    // Check if result is already formatted as ApiResponse (has status='success' or 'error')
    // This allows users to return strict ApiResponse objects without double-wrapping
    if (result && typeof result === 'object' && (result.status === 'success' || result.status === 'error')) {
      socket.emit(`apiResponse-${responseIndex}`, result);
    } else {
      // Legacy/Convenience: Wrap raw data in success response
      socket.emit(`apiResponse-${responseIndex}`, { status: "success", result });
    }
  } else {
    console.log(`WARNING: ${name} returned nothing`, 'yellow');
    socket.emit(`apiResponse-${responseIndex}`, {
      status: "error",
      message: 'API returned no result'
    });
  }
}
</file>

<file path="src/_sockets/socketInitializer.ts">
import { toast } from "sonner";
import { io, Socket } from 'socket.io-client';
import config, { dev, backendUrl, SessionLayout } from "config";
import { useSocketStatus } from "../_providers/socketStatusProvider";
import { RefObject, useEffect, useRef } from "react";
import { initSyncRequest, useSyncEventTrigger } from "./syncRequest";
import { flushApiQueue, flushSyncQueue, isOnline } from "./offlineQueue";

export let socket: Socket | null = null;

let responseIndex = 0;
export const incrementResponseIndex = () => {
  return responseIndex = responseIndex + 1;
}

export function useSocket(session: SessionLayout | null) {
  const { socketStatus, setSocketStatus } = useSocketStatus();
  const { triggerSyncEvent } = useSyncEventTrigger();
  const sessionRef = useRef(session);

  useEffect(() => {
    sessionRef.current = session;
  }, [session])

  useEffect(() => {
    const socketOptions: any = {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      autoConnect: true,
      withCredentials: true,
      auth: {}
    };

    if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
      const token = sessionStorage.getItem("token");
      if (token) {
        socketOptions.auth = { token };
      }
    }

    const socketConnection = io(backendUrl, socketOptions);
    socket = socketConnection;

    const canFlushQueue = () => socketConnection.connected && isOnline();

    const handleVisibility = async () => {
      if (!config.socketActivityBroadcaster) { return; }

      console.log(document.visibilityState)
      
      //? user switched tab or navigated away
      if (document.visibilityState === "hidden") {
        socketConnection.emit("intentionalDisconnect");

        //? user switched back to the tab
      } else if (document.visibilityState === "visible") {
        if (socketStatus.self.status !== "CONNECTED") {
          socketConnection.connect();
        }
        socketConnection.emit("intentionalReconnect");
      }
    };
    document.addEventListener("visibilitychange", handleVisibility);

    if (config.socketActivityBroadcaster) {
      initSyncRequest({
        socketStatus,
        setSocketStatus,
        sessionRef: sessionRef as RefObject<SessionLayout>
      })
    } else {
      socketConnection.on("connect", () => {
        console.log("Connected to server");
      });

      socketConnection.on("disconnect", () => {
        console.log("Disconnected, trying to reconnect...");
      });

      socketConnection.on("reconnect_attempt", (attempt) => {
        console.log(`Reconnecting attempt ${attempt}...`);
      });

      socketConnection.on("connect_error", (err) => {
        if (dev) {
          console.error(`Connection error: ${err.message}`);
          toast.error(`Connection error: ${err.message}`);
        }
      });
    }

    socketConnection.on("connect", () => {
      flushApiQueue(canFlushQueue);
      flushSyncQueue(canFlushQueue);
    });

    socketConnection.on("logout", (status: "success" | "error") => {
      if (status === "success") {
        if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
          sessionStorage.clear();
        }
        window.location.href = config.loginPageUrl;
      } else {
        console.error("Logout failed");
        toast.error("Logout failed");
      }
    });

    socketConnection.on("sync", ({ cb, clientOutput, serverOutput, message, status }) => {
      const path = window.location.pathname;
      if (dev) console.log("Server Sync Response:", { cb, clientOutput, serverOutput, status, message });

      if (status === "error") {
        if (dev) {
          console.log(message);
          toast.error(message);
        }
        return;
      }

      triggerSyncEvent(`sync${path}/${cb}`, clientOutput, serverOutput);
    });


    const handleOnline = () => {
      if (socketConnection.connected) {
        flushApiQueue(canFlushQueue);
        flushSyncQueue(canFlushQueue);
        return;
      }
      socketConnection.connect();
    };

    window.addEventListener("online", handleOnline);

    return () => {
      if (socket) {
        socket.disconnect();
        socket = null;
        setSocketStatus(prev => ({
          ...prev,
          self: {
            status: "DISCONNECTED",
            reconnectAttempt: undefined,
            endTime: undefined,
          }
        }));
      }

      document.removeEventListener("visibilitychange", handleVisibility)
      window.removeEventListener("online", handleOnline)
    };

  }, []);

  return socket;
}


export const waitForSocket = async () => {

  let i = 0;
  while (!socket) {
    await new Promise((resolve) => setTimeout(resolve, 10));
    i++
    if (i > 500) {
      if (dev) {
        console.error("Socket is not initialized, giving up");
        toast.error("Socket is not initialized, giving up");
      }
      return false
    } //? we give it 500 * 10 so 5000ms or 5s to load the socket connection
  }

  return true
}

export const joinRoom = async (group: string) => {
  return new Promise(async (resolve) => {
    if (!group || typeof group !== "string") {
      if (dev) {
        console.error("Invalid group");
        toast.error("Invalid group");
      }
      return resolve(null);
    }

    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }

    const tempIndex = incrementResponseIndex();
    socket.emit('joinRoom', { group, responseIndex: tempIndex });

    socket.once(`joinRoom-${tempIndex}`, () => {
      return resolve(true);
    });
  })
}

export const updateLocationRequest = async ({ location }: { location: { pathName: string, searchParams: Record<string, string> } }) => {
  if (!location.pathName || !location.searchParams) {
    if (dev) {
      console.error("Invalid location");
      toast.error("Invalid location");
    }
    return null;
  }

  if (!await waitForSocket()) { return }
  if (!socket) { return null; }

  socket.emit('updateLocation', location);
}
</file>

<file path="src/docs/page.tsx">
import React, { useEffect, useState } from 'react';
import { apiRequest } from 'src/_sockets/apiRequest'; // We keep using this for the initial fetch as it's within the 'docs' page context
import { socket } from 'src/_sockets/socketInitializer';
import tryCatch from 'src/_functions/tryCatch';
import notify from 'src/_functions/notify';

// Define types for the docs structure (matching server response)
interface ApiDoc {
  page: string;
  name: string;
  method: string;
  description?: string;
  input: string;
  output: string;
  auth: any;
  rateLimit: number | false | undefined;
  path: string;
}

interface SyncDoc {
  page: string;
  name: string;
  clientInput: string;
  serverOutput: string;
  clientOutput: string;
  path: string;
}

interface DocsResult {
  apis: Record<string, ApiDoc[]>;
  syncs: Record<string, SyncDoc[]>;
}

export const template = 'dashboard'; // Use dashboard template for sidebar layout

export default function DocsPage() {
  const [docs, setDocs] = useState<DocsResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [selectedApi, setSelectedApi] = useState<ApiDoc | null>(null);
  const [selectedSync, setSelectedSync] = useState<SyncDoc | null>(null);
  const [inputData, setInputData] = useState('{}');
  const [apiResult, setApiResult] = useState<any>(null);
  const [apiStatus, setApiStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

  useEffect(() => {
    const fetchDocs = async () => {
      // We can use the generic apiRequest here because we are ON the 'docs' page, 
      // so 'getDocs' resolves to 'api/docs/getDocs' which is correct.
      const [err, res] = await tryCatch(async () => 
        // @ts-ignore - Dynamic API not in generated types yet during dev
        await apiRequest({ name: 'getDocs', data: {} })
      );

      if (err) {
        notify.error({ key: 'Failed to load documentation' });
        console.error(err);
      } else if (res?.status === 'success') {
        setDocs(res.result);
      }
      setLoading(false);
    };

    fetchDocs();
  }, []);

  const handleApiRun = (api: ApiDoc) => {
    if (!socket) {
      notify.error({ key: 'Socket not connected' });
      return;
    }

    setApiStatus('loading');
    setApiResult(null);

    let parsedData = {};
    try {
      parsedData = JSON.parse(inputData);
    } catch (e) {
      notify.error({ key: 'Invalid JSON input' });
      setApiStatus('error');
      return;
    }

    const responseIndex = Date.now(); // Simple index for this manual run
    const eventName = `apiResponse-${responseIndex}`;
    
    // We use raw socket emit to bypass apiRequest's page-scoped logic
    // This allows us to call ANY api from this docs page
    socket.emit('apiRequest', {
      name: api.path, // e.g., 'api/examples/test123'
      data: parsedData,
      responseIndex
    });

    socket.once(eventName, (response: any) => {
      setApiResult(response);
      setApiStatus(response.status === 'success' ? 'success' : 'error');
    });

    // Cleanup listener after timeout
    setTimeout(() => {
      if (socket?.hasListeners(eventName)) {
        socket.off(eventName);
        if (apiStatus === 'loading') {
          setApiStatus('error');
          setApiResult({ message: 'Request timed out' });
        }
      }
    }, 5000);
  };

  if (loading) return <div className="p-8 text-common/60">Loading documentation...</div>;
  if (!docs) return <div className="p-8 text-wrong">Failed to load documentation.</div>;

  return (
    <div className="flex h-full min-h-screen bg-background text-common overflow-hidden">
      {/* Sidebar */}
      <div className="w-64 flex-shrink-0 border-r border-container-border overflow-y-auto p-4 bg-container/50">
        <h2 className="text-xl font-bold mb-6 text-title">Documentation</h2>
        
        <div className="mb-6">
          <h3 className="text-sm font-semibold uppercase tracking-wider text-common/50 mb-3">APIs</h3>
          {Object.entries(docs.apis).map(([page, apis]) => (
            <div key={page} className="mb-4">
              <div className="text-xs font-medium text-container-border mb-2 px-2 uppercase">{page}</div>
              <div className="space-y-1">
                {apis.map(api => (
                  <button
                    key={api.name}
                    onClick={() => { setSelectedApi(api); setSelectedSync(null); setInputData('{}'); setApiResult(null); setApiStatus('idle'); }}
                    className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                      selectedApi?.path === api.path 
                        ? 'bg-container3 text-title shadow-sm' 
                        : 'hover:bg-container2 text-common/80'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <span className="truncate">{api.name}</span>
                      <span className={`text-[10px] px-1.5 py-0.5 rounded ${
                        api.method === 'GET' ? 'bg-blue-500/10 text-blue-500' : 'bg-green-500/10 text-green-500'
                      }`}>{api.method}</span>
                    </div>
                  </button>
                ))}
              </div>
            </div>
          ))}
        </div>

        <div>
          <h3 className="text-sm font-semibold uppercase tracking-wider text-common/50 mb-3">Syncs</h3>
          {Object.entries(docs.syncs).map(([page, syncs]) => (
            <div key={page} className="mb-4">
              <div className="text-xs font-medium text-container-border mb-2 px-2 uppercase">{page}</div>
              <div className="space-y-1">
                {syncs.map(sync => (
                  <button
                    key={sync.name}
                    onClick={() => { setSelectedSync(sync); setSelectedApi(null); }}
                    className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                      selectedSync?.path === sync.path 
                        ? 'bg-container3 text-title shadow-sm' 
                        : 'hover:bg-container2 text-common/80'
                    }`}
                  >
                    <span className="truncate">{sync.name}</span>
                  </button>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 overflow-y-auto p-8">
        {!selectedApi && !selectedSync && (
          <div className="flex flex-col items-center justify-center h-full text-common/40">
            <div className="text-6xl mb-4">📚</div>
            <p>Select an API or Sync event to view documentation</p>
          </div>
        )}

        {/* API Details */}
        {selectedApi && (
          <div className="max-w-4xl mx-auto space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-300">
            {/* Header */}
            <div>
              <div className="flex items-center gap-3 mb-2">
                <span className={`text-sm font-bold px-2 py-1 rounded ${
                  selectedApi.method === 'GET' ? 'bg-blue-500 text-white' : 'bg-green-600 text-white'
                }`}>
                  {selectedApi.method}
                </span>
                <h1 className="text-2xl font-bold text-title tracking-tight">{selectedApi.name}</h1>
              </div>
              <div className="font-mono text-sm text-common/60 bg-container px-3 py-1.5 rounded w-fit border border-container-border">
                {selectedApi.path}
              </div>
            </div>

            {/* Info Cards */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="bg-container p-4 rounded-xl border border-container-border">
                <h3 className="text-sm font-semibold text-common/70 mb-3 uppercase tracking-wider">Authentication</h3>
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-sm">Login Required:</span>
                    <span className={`text-xs px-2 py-0.5 rounded-full font-medium ${
                      selectedApi.auth?.login 
                        ? 'bg-wrong/10 text-wrong border border-wrong/20' 
                        : 'bg-correct/10 text-correct border border-correct/20'
                    }`}>
                      {selectedApi.auth?.login ? 'YES' : 'NO'}
                    </span>
                  </div>
                  {/* Additional auth rules could be parsed and listed here */}
                </div>
              </div>

              <div className="bg-container p-4 rounded-xl border border-container-border">
                <h3 className="text-sm font-semibold text-common/70 mb-3 uppercase tracking-wider">Rate Limit</h3>
                <div className="flex items-center gap-2">
                  <span className="text-2xl font-bold text-title">
                    {selectedApi.rateLimit === false ? 'None' : selectedApi.rateLimit ?? '60'}
                  </span>
                  <span className="text-xs text-common/50">requests / min</span>
                </div>
              </div>
            </div>

            {/* Type Defs */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <h3 className="text-sm font-semibold text-common/70 mb-2 pl-1">Input Schema</h3>
                <pre className="bg-container3 p-4 rounded-lg border border-container-border text-xs font-mono overflow-x-auto text-common/90 leading-relaxed shadow-inner">
                  {selectedApi.input}
                </pre>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-common/70 mb-2 pl-1">Output Schema</h3>
                <pre className="bg-container3 p-4 rounded-lg border border-container-border text-xs font-mono overflow-x-auto text-common/90 leading-relaxed shadow-inner">
                  {selectedApi.output}
                </pre>
              </div>
            </div>

            {/* Try It Playground */}
            <div className="bg-container p-6 rounded-xl border border-container-border shadow-lg">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-bold text-title">⚡ Try it out</h3>
                {apiStatus === 'success' && <span className="text-xs text-correct font-bold">Request Successful</span>}
                {apiStatus === 'error' && <span className="text-xs text-wrong font-bold">Request Failed</span>}
              </div>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-xs font-medium text-common/60 mb-1.5 uppercase">Request Body (JSON)</label>
                  <textarea
                    value={inputData}
                    onChange={(e) => setInputData(e.target.value)}
                    className="w-full h-32 bg-background border border-container-border rounded-lg p-3 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition-all resize-y"
                    placeholder="{}"
                  />
                </div>

                <button
                  onClick={() => handleApiRun(selectedApi)}
                  disabled={apiStatus === 'loading'}
                  className="px-6 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 text-white font-medium rounded-lg shadow-lg hover:shadow-blue-500/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                >
                  {apiStatus === 'loading' ? 'Running...' : 'Run Request'}
                </button>

                {apiResult && (
                  <div className="animate-in fade-in slide-in-from-top-2 duration-200">
                    <label className="block text-xs font-medium text-common/60 mb-1.5 uppercase">Response</label>
                    <pre className={`w-full bg-background border rounded-lg p-3 font-mono text-sm overflow-x-auto ${
                      apiResult.status === 'error' ? 'border-wrong/30 text-wrong' : 'border-correct/30 text-correct'
                    }`}>
                      {JSON.stringify(apiResult, null, 2)}
                    </pre>
                  </div>
                )}
              </div>
            </div>

            {/* Socket Usage */}
            <div>
              <h3 className="text-lg font-bold text-title mb-4">Socket Usage</h3>
              <div className="bg-[#1e1e1e] text-gray-300 p-4 rounded-xl overflow-x-auto border border-white/10 shadow-inner">
                <code className="font-mono text-xs leading-relaxed">
                  <span className="text-purple-400">socket</span>.<span className="text-blue-400">emit</span>(<span className="text-green-400">'apiRequest'</span>, {'{'}<br/>
                  &nbsp;&nbsp;<span className="text-sky-300">name</span>: <span className="text-green-400">'{selectedApi.path}'</span>,<br/>
                  &nbsp;&nbsp;<span className="text-sky-300">data</span>: {inputData !== '{}' ? inputData : '{ ... }'},<br/>
                  &nbsp;&nbsp;<span className="text-sky-300">responseIndex</span>: <span className="text-yellow-400">123</span><br/>
                  {'}'});<br/>
                  <br/>
                  <span className="text-gray-500">// Listen for response</span><br/>
                  <span className="text-purple-400">socket</span>.<span className="text-blue-400">on</span>(<span className="text-green-400">'apiResponse-123'</span>, (<span className="text-orange-300">response</span>) {'=>'} {'{'}<br/>
                  &nbsp;&nbsp;<span className="text-purple-400">console</span>.<span className="text-yellow-300">log</span>(response);<br/>
                  {'}'});
                </code>
              </div>
            </div>
          </div>
        )}

        {/* Sync Details */}
        {selectedSync && (
          <div className="max-w-4xl mx-auto space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-300">
            <div>
              <div className="flex items-center gap-3 mb-2">
                <span className="text-sm font-bold px-2 py-1 rounded bg-purple-600 text-white">SYNC</span>
                <h1 className="text-2xl font-bold text-title tracking-tight">{selectedSync.name}</h1>
              </div>
              <div className="font-mono text-sm text-common/60 bg-container px-3 py-1.5 rounded w-fit border border-container-border">
                {selectedSync.path}
              </div>
            </div>

            <div className="bg-container p-6 rounded-xl border border-container-border">
               <p className="text-common/80 leading-relaxed">
                Sync events provide real-time updates to all clients in a room. 
                When a client triggers a sync request, the server validates it and broadcasts the result to everyone.
               </p>
            </div>

             <div className="grid grid-cols-1 gap-6">
              <div>
                <h3 className="text-sm font-semibold text-common/70 mb-2 pl-1">Client Input (Trigger)</h3>
                <pre className="bg-container3 p-4 rounded-lg border border-container-border text-xs font-mono overflow-x-auto text-common/90 leading-relaxed">
                  {selectedSync.clientInput}
                </pre>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-common/70 mb-2 pl-1">Server Output (Broadcast)</h3>
                <pre className="bg-container3 p-4 rounded-lg border border-container-border text-xs font-mono overflow-x-auto text-common/90 leading-relaxed">
                  {selectedSync.serverOutput}
                </pre>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-common/70 mb-2 pl-1">Client Output (Local)</h3>
                <pre className="bg-container3 p-4 rounded-lg border border-container-border text-xs font-mono overflow-x-auto text-common/90 leading-relaxed">
                  {selectedSync.clientOutput}
                </pre>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/_sockets/syncRequest.ts">
import { dev, SessionLayout } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
import { statusContent } from "src/_providers/socketStatusProvider";
import { Dispatch, RefObject, SetStateAction } from "react";
import { enqueueSyncRequest, isOnline } from "./offlineQueue";
import type {
  SyncPagePath,
  SyncName,
  SyncClientInput,
  SyncServerOutput,
  SyncClientOutput
} from "./apiTypes.generated";

// ═══════════════════════════════════════════════════════════════════════════════
// Type Helpers for Sync Requests
// ═══════════════════════════════════════════════════════════════════════════════

// Check if data input is required (i.e., T does NOT allow empty object)
// Unions like {a:1} | {b:1} do NOT allow {}, so data will be required
type DataRequired<T> = {} extends T ? false : true;

// Force expansion of types to clear aliases in tooltips
type Prettify<T> = { [K in keyof T]: T[K] } & {};

// ═══════════════════════════════════════════════════════════════════════════════
// Global Sync Params
// ═══════════════════════════════════════════════════════════════════════════════

// All possible sync names across all pages
export type AllSyncNames = {
  [P in SyncPagePath]: SyncName<P>
}[SyncPagePath];

// Get clientInput type for a sync name (union if exists on multiple pages)
type ClientInputForName<N extends AllSyncNames> = {
  [P in SyncPagePath]: N extends SyncName<P> ? SyncClientInput<P, N> : never
}[SyncPagePath];

// Get serverOutput type for a sync name (union if exists on multiple pages)
type ServerOutputForName<N extends AllSyncNames> = {
  [P in SyncPagePath]: N extends SyncName<P> ? SyncServerOutput<P, N> : never
}[SyncPagePath];

// Get clientOutput type for a sync name (union if exists on multiple pages)
type ClientOutputForName<N extends AllSyncNames> = {
  [P in SyncPagePath]: N extends SyncName<P> ? SyncClientOutput<P, N> : never
}[SyncPagePath];

// Build params type for a specific sync name
type SyncParamsForName<N extends AllSyncNames> =
  DataRequired<ClientInputForName<N>> extends true
  ? { name: N; data: Prettify<ClientInputForName<N>>; receiver: string; ignoreSelf?: boolean }
  : { name: N; data?: Prettify<ClientInputForName<N>>; receiver: string; ignoreSelf?: boolean };

// ═══════════════════════════════════════════════════════════════════════════════
// Sync Event Callbacks Registry
// ═══════════════════════════════════════════════════════════════════════════════

const syncEvents: Record<string, ((params: { clientOutput: any; serverOutput: any; aditionalData: any }) => void)> = {};

// ═══════════════════════════════════════════════════════════════════════════════
// Page-Specific Params (for exact types when duplicate names exist)
// ═══════════════════════════════════════════════════════════════════════════════

// Build params type for a specific page and sync name
type PageSyncParamsForName<P extends SyncPagePath, N extends SyncName<P>> =
  DataRequired<SyncClientInput<P, N>> extends true
  ? { name: N; data: SyncClientInput<P, N>; receiver: string; ignoreSelf?: boolean }
  : { name: N; data?: SyncClientInput<P, N>; receiver: string; ignoreSelf?: boolean };

// ═══════════════════════════════════════════════════════════════════════════════
// syncRequest Function Overloads
// ═══════════════════════════════════════════════════════════════════════════════

// Overload 1: Name-based inference - PRIMARY usage
// TypeScript infers N from the literal name value
export function syncRequest<N extends AllSyncNames>(
  params: SyncParamsForName<N>
): Promise<boolean>;

// Overload 2: Explicit page + name - for duplicate sync names across pages
// Both type params REQUIRED when specifying page
export function syncRequest<P extends SyncPagePath, N extends SyncName<P>>(
  params: PageSyncParamsForName<P, N>
): Promise<boolean>;

// Implementation
export function syncRequest(params: any): Promise<boolean> {
  let { name, data, receiver, ignoreSelf } = params;

  return new Promise(async (resolve) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name for syncRequest");
        toast.error("Invalid name for syncRequest");
      }
      return resolve(false);
    }

    if (!data || typeof data !== "object") {
      data = {};
    }

    if (!receiver) {
      if (dev) {
        console.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
        toast.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
      }
      return resolve(false);
    }

    if (!await waitForSocket()) { return resolve(false); }
    if (!socket) { return resolve(false); }

    const pathname = window.location.pathname;
    const fullName = `sync${pathname}/${name}`;
    let queueId: string | null = null;

    const canSendNow = () => {
      if (!socket) return false;
      if (!socket.connected) return false;
      return isOnline();
    };

    const runRequest = () => {
      if (!canSendNow()) {
        if (!queueId) {
          queueId = `${Date.now()}-${Math.random()}`;
        }
        enqueueSyncRequest({
          id: queueId,
          key: fullName,
          run: runRequest,
          createdAt: Date.now(),
        });
        return;
      }

      const tempIndex = incrementResponseIndex();

      if (dev) { console.log(`Client Sync Request: `, { name, data, receiver, ignoreSelf }) }

      socket.emit('sync', { name: fullName, data, cb: name, receiver, responseIndex: tempIndex, ignoreSelf });

      socket.once(`sync-${tempIndex}`, (data: { status: "success" | "error", message: string }) => {
        if (data.status === "error") {
          if (dev) {
            console.error(`Sync ${name} failed: ${data.message}`);
            toast.error(`Sync ${name} failed: ${data.message}`);
          }
          return resolve(false);
        }
        resolve(data.status == "success");
      });
    };

    runRequest();
  })
}

// ═══════════════════════════════════════════════════════════════════════════════
// useSyncEvents Hook - Type-Safe Event Registration
// ═══════════════════════════════════════════════════════════════════════════════

// Type-safe callback for sync events
export type SyncEventCallback<N extends AllSyncNames> = (params: {
  clientOutput: ClientOutputForName<N>;
  serverOutput: ServerOutputForName<N>;
}) => void;

export const useSyncEvents = () => {
  // Type-safe version: use with specific sync name
  function upsertSyncEventCallback<N extends AllSyncNames>(
    name: N,
    cb: SyncEventCallback<N>
  ): void;

  // Legacy version: accepts any string (for backward compatibility)
  function upsertSyncEventCallback(
    name: string,
    cb: (params: { clientOutput: any; serverOutput: any }) => void
  ): void;

  // Implementation
  function upsertSyncEventCallback(
    name: string,
    cb: (params: { clientOutput: any; serverOutput: any }) => void
  ): void {
    const path = window.location.pathname;
    syncEvents[`sync${path}/${name}`] = cb;
  }

  return { upsertSyncEventCallback };
}

export const useSyncEventTrigger = () => {

  const triggerSyncEvent = (name: string, clientOutput: any = {}, serverOutput: any = {}, aditionalData: any = {}) => {
    const cb = syncEvents[name];
    if (!cb) {
      if (dev) {
        console.log(syncEvents)
        console.error(`Sync event ${name} not found`);
        toast.error(`Sync event ${name} not found`);
      }
      return;
    }
    if (typeof cb == 'function') {
      cb({ clientOutput, serverOutput, aditionalData });
    }
  }

  return { triggerSyncEvent }
}

export const initSyncRequest = async ({
  socketStatus,
  setSocketStatus,
  sessionRef
}: {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
  sessionRef: RefObject<SessionLayout> | null;
}) => {

  if (!await waitForSocket()) { return; }
  if (!socket) { return; }
  if (!sessionRef) { return; }

  socket.on("connect", () => {
    console.log(socketStatus)
    console.log("Connected to server");
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "CONNECTED",
        // reconnectAttempt: undefined,
      }
    }));
  });

  socket.on("disconnect", () => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
      }
    }));
    console.log("Disconnected, trying to reconnect...");
  });

  socket.on("reconnect_attempt", (attempt) => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "RECONNECTING",
        reconnectAttempt: attempt,
      }
    }));
    console.log(`Reconnecting attempt ${attempt}...`);
  });

  //? will not trigger when you call this event
  socket.on("userAfk", ({ userId, endTime }) => {
    if (userId == sessionRef.current?.id) {
      setSocketStatus(prev => ({
        ...prev,
        self: {
          status: "DISCONNECTED",
          reconnectAttempt: undefined,
          endTime
        }
      }));
    } else {
      setSocketStatus(prev => ({
        ...prev,
        [userId]: {
          status: "DISCONNECTED",
          endTime
        }
      }));
    }
  });

  //? will not trigger when you call this event
  socket.on("userBack", ({ userId }) => {
    console.log("userBack", { userId });

    setSocketStatus(prev => {
      const newStatus = { ...prev };
      newStatus[userId] = {
        status: "CONNECTED",
        endTime: undefined,
      };
      return newStatus;
    });
  });

  socket.on("connect_error", (err) => {
    console.log("connect_error", { err });
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
        reconnectAttempt: undefined,
      }
    }));
    if (dev) {
      console.error(`Connection error: ${err.message}`);
      toast.error(`Connection error: ${err.message}`);
    }
  });

}
</file>

<file path="PROJECT_CONTEXT.md">
<!--
  to toggle markdown file press
  1. ctrl + k
  2. v
-->

# LuckyStack Project Context

> **Human-readable documentation for AI assistants and developers to understand this project.**
> Last updated: 2026-02-10

---

# Part 1: Framework Summary

The framework is a **custom-built React + Node.js stack** inspired by Next.js but with socket-first architecture.

## Root Configuration Files

| File                   | Purpose                                                                                        |
| ---------------------- | ---------------------------------------------------------------------------------------------- |
| `config.ts`            | Main app configuration (URLs, defaults, session layout). Gitignored - use `configTemplate.txt` |
| `envTemplate.txt`      | Template for `.env` file with database, OAuth, and server secrets                              |
| `vite.config.ts`       | Vite bundler config with path aliases (`src/`, `config`) and exclusions for server files       |
| `index.html`           | Entry point with two root divs: `#root` (app) and `#portalRoot` (modals/overlays z-999999999)  |
| `redis.conf`           | Redis configuration for session storage                                                        |
| `prisma/schema.prisma` | MongoDB database schema - currently only `user` model with OAuth providers                     |

## Server Architecture (`/server`)

The backend is **raw Node.js** (no Express) with a custom HTTP router and Socket.io.

### `server/server.ts` - Main Entry Point

- Creates HTTP server with CORS, security headers (Referrer-Policy, X-Frame-Options, X-XSS-Protection)
- HTTP route handling by path prefix:
  - `/auth/api/{provider}` → Redirects to OAuth provider or handles credentials login
  - `/auth/callback/{provider}` → Handles OAuth callback from providers
  - `/uploads/*` → Serves uploaded files (avatars, etc.)
  - `/assets/*` → Serves static assets
  - Everything else → Falls back to `index.html` for SPA routing
- In development mode: initializes hot-reload watchers and REPL console
- Initializes Socket.io via `loadSocket()`

### `server/auth/` - Authentication System

| File             | Purpose                                                                              |
| ---------------- | ------------------------------------------------------------------------------------ |
| `login.ts`       | Handles credentials login/register and OAuth callback processing                     |
| `loginConfig.ts` | Defines 5 OAuth provider configs (credentials, Google, GitHub, Discord, Facebook)    |
| `checkOrigin.ts` | Validates request origins against allowed domains (DNS, localhost, external origins) |

**Supported Providers:** credentials, Google, GitHub, Facebook, Discord

**Login Flow:**

1. Credentials: Validates email/password, hashes with bcrypt, creates/authenticates user
2. OAuth: Redirects to provider → callback exchanges code for token → fetches user info → creates/finds user
3. On successful login, generates random token and saves session to Redis

### `server/sockets/socket.ts` - Socket.io Server

Handles all real-time communication:

- **`apiRequest`** - RPC-style API calls from client (routed via `handleApiRequest.ts`)
- **`sync`** - Room-based sync events between clients (routed via `handleSyncRequest.ts`)
- **`joinRoom`** - Adds socket to a room (room code stored in session)
- **`updateLocation`** - Tracks user's current page path
- **`disconnect`** - Handles socket disconnection with optional activity broadcasting

### `server/sockets/handleApiRequest.ts` - API Request Handler

- Special handlers for `session` (returns user session) and `logout` (logs out user)
- Validates `auth` requirements before executing API functions
- **Auth Validation System** supports flexible conditions:
  - `login: true` - Requires user to be logged in
  - `additional: [{key, type?, value?, nullish?, mustBeFalsy?}]` - Custom field checks

### `server/sockets/handleHttpApiRequest.ts` - HTTP API Request Handler

- Provides HTTP/REST fallback for all socket-based APIs
- Supports `GET`, `POST`, `PUT`, `DELETE` methods via path `/api/{page}/{apiName}`
- Automatic method inference based on API name prefix (get*, delete*, update\*, etc.)
- Token passed via cookie or `Authorization: Bearer` header

### `server/sockets/handleSyncRequest.ts` - Sync Request Handler

- Validates server-side sync file before broadcasting
- Loops through all sockets in the room and runs client-side sync for each
- Supports `ignoreSelf` to exclude sender from receiving the event

### `server/functions/` - Server Utilities

| File             | Purpose                                                           |
| ---------------- | ----------------------------------------------------------------- |
| `session.ts`     | Session CRUD in Redis + **auto-kicks previous sessions on login** |
| `redis.ts`       | Redis client wrapper (ioredis)                                    |
| `db.ts`          | Prisma client export for MongoDB                                  |
| `tryCatch.ts`    | Error-safe async function wrapper                                 |
| `sleep.ts`       | Promise-based delay                                               |
| `broadcaster.ts` | Utility for broadcasting to socket rooms                          |
| `game.ts`        | Game-related utilities (for multiplayer games)                    |

### Session Kicking Feature (`session.ts`)

When a user logs in, the system automatically kicks all previous sessions for that user:

1. Looks up all active tokens for the user ID in Redis
2. For each existing session: emits `logout` event to connected sockets, deletes session data
3. Registers new token in the active users set
4. Broadcasts `updateSession` to all sockets with the new token

### `server/dev/` - Development Utilities

| File           | Purpose                                                     |
| -------------- | ----------------------------------------------------------- |
| `loader.ts`    | Hot-reloads `_api` and `_sync` files without server restart |
| `hotReload.ts` | File watcher that triggers reloads on changes               |

### `server/sockets/utils/` - Socket Utilities

| File                     | Purpose                                                      |
| ------------------------ | ------------------------------------------------------------ |
| `logout.ts`              | Handles logout: clears timers, leaves rooms, deletes session |
| `activityBroadcaster.ts` | Tracks user activity (AFK detection, reconnection)           |

### Build Scripts (`/scripts`)

| Script                      | Purpose                                                            |
| --------------------------- | ------------------------------------------------------------------ |
| `generateServerRequests.ts` | Scans `src/` for `_api/` and `_sync/` folders, generates route map |
| `bundleServer.ts`           | Bundles server for production                                      |
| `clearServerRequests.ts`    | Clears generated route map for dev restart                         |

---

## Client Architecture (`/src`)

### Entry Point: `main.tsx`

- File-based routing similar to Next.js
- Scans for `page.tsx` in any non-underscore folder
- Wraps app in providers: `SocketStatus` → `Session` → `Translation` → `Avatar` → `MenuHandler` → `Router`

### Provider Hierarchy (Framework-level)

```
SocketStatusProvider   # Socket connection status
└── SessionProvider    # User session from Redis
    └── TranslationProvider  # i18n with JSON locale files
        └── AvatarProvider   # User avatar caching
            └── MenuHandlerProvider  # Global menu state
                └── RouterProvider   # React Router
```

### `src/_sockets/` - Client-Server Communication

These are the core functions for communicating with the backend:

#### `apiRequest({ name, data })` → Promise (Type-Safe)

- **Fully type-safe API calls** - TypeScript validates API names, input data, and output types
- Auto-prefixes with current path: `api/{path}/{name}`
- Has abort controllers for duplicate GET-like requests
- Queues requests in memory when offline or socket-disconnected, then flushes on reconnect

**Type System Features:**

1. **Automatic type inference** - No manual type parameters needed for most cases
2. **Union types for duplicate names** - If same API name exists on multiple pages, accepts union of all input types
3. **Optional page path** - Pass `<'page/path'>` for exact types when duplicate names exist
4. **Required data validation** - `data` is required when API expects specific fields, optional for `Record<string, any>`
5. **Errors for invalid names** - TypeScript error if API name doesn't exist

**Examples:**

```typescript
// Auto-typed - works for unique API names
const result = await apiRequest({ name: "adminOnly", data: {} });

// Union type - 'jow' exists on multiple pages
const result = await apiRequest({
  name: "jow",
  data: { email: "x" }, // OR { name: 'x' }
});

// Exact typing with page path
const result = await apiRequest<"examples/examples2">({
  name: "jow",
  data: { name: "john" }, // Must be { name: string }
});

// Error: API doesn't exist
const result = await apiRequest({ name: "invalid" }); // ❌ TypeScript error

// Error: missing required data
const result = await apiRequest({ name: "jow" }); // ❌ Property 'data' is missing
```

**Type Generation:**

- Types are auto-generated in `src/_sockets/apiTypes.generated.ts` by `server/dev/typeMapGenerator.ts`
- Watches `_api` folders and extracts input/output types from `ApiParams` interface and `main` function return type
- Regenerates on file changes via `server/dev/hotReload.ts`

#### `syncRequest({ name, data, receiver, ignoreSelf })` → Promise (Type-Safe)

- Sends real-time events to other clients in same room
- `receiver` is the room code (e.g., "abc123")
- `ignoreSelf` prevents the sender from receiving the event
- **Fully type-safe** - sync names, clientData, and serverOutput are validated
- Queues requests in memory when offline or socket-disconnected, then flushes on reconnect

**Type System Features:**

1. **Automatic type inference** - No manual type parameters needed
2. **Union types for duplicate names** - Same as apiRequest
3. **Optional page path** - Pass `<'page/path'>` for exact types
4. **Required data validation** - `data` required when sync expects specific fields

**Examples:**

```typescript
// Type-safe sync with auto-complete
await syncRequest({
  name: "updateCounter", // ← Autocomplete for sync names
  data: { increase: true }, // ← Type-checked
  receiver: roomCode,
});

// Exact typing with page path
await syncRequest<"examples">({
  name: "updateCounter",
  data: { increase: true },
  receiver: roomCode,
});
```

#### `useSyncEvents()` Hook (Type-Safe)

```typescript
const { upsertSyncEventCallback } = useSyncEvents();

// Type-safe: clientOutput and serverOutput are inferred from sync definition
upsertSyncEventCallback("updateCounter", ({ clientOutput, serverOutput }) => {
  console.log(clientOutput.randomKey); // ← Type from _client file return (success only)
  console.log(serverOutput.increase); // ← Type from _server file return
});
```

**Sync Type System:**
The sync type system has three distinct data types that flow through the system:

| Type           | Source                | Description                                           |
| -------------- | --------------------- | ----------------------------------------------------- |
| `clientInput`  | Sender's `data` param | Original data passed to `syncRequest({ data: ... })`  |
| `serverOutput` | `_server.ts` return   | Data returned from server-side sync handler           |
| `clientOutput` | `_client.ts` return   | Data returned from client-side handler (success only) |

**Type Generation:**

- Types auto-generated in `src/_sockets/apiTypes.generated.ts`
- Watches `_sync/*_server.ts` and `_sync/*_client.ts` files
- `clientOutput` only includes successful returns (error returns are filtered out)

#### `joinRoom(code)` → Promise

- Joins a socket room for sync events
- Room code stored in user session

### `src/_components/` - Reusable UI Components

| Component                 | Purpose                                              |
| ------------------------- | ---------------------------------------------------- |
| `TemplateProvider.tsx`    | Wraps pages in templates: `plain`, `home`, `dashboard` |
| `SessionProvider.tsx`     | Provides session context and socket initialization   |
| `Middleware.tsx`          | Route authentication guards                          |
| `LoginForm.tsx`           | OAuth login buttons                                  |
| `MenuHandler.tsx`         | Global menu/modal management                         |
| `Navbar.tsx`              | Top navigation bar                                   |
| `Tooltip.tsx`             | Hover tooltips                                       |
| `Dropdown.tsx`            | Dropdown menus                                       |
| `ConfirmMenu.tsx`         | Confirmation dialogs                                 |
| `TranslationProvider.tsx` | i18n with `src/_locales/{lang}.json`                 |

### Templates (`TemplateProvider.tsx`)

Pages export a `template` constant to specify their wrapper:

1. **`plain`** - Minimal wrapper, no UI chrome. Sets theme to `config.defaultTheme`.
2. **`home`** - Top bar with user avatar, name, settings/home toggle, and logout button. Includes `Middleware` for route guards.
3. **`dashboard`** - Side navigation bar (`Navbar`) with main content area. Includes `Middleware` for route guards.

### Page Routes

| Route       | Template | Purpose                                          |
| ----------- | -------- | ------------------------------------------------ |
| `/`         | plain    | Root redirect based on session                   |
| `/login`    | plain    | OAuth login page                                 |
| `/register` | plain    | Registration (uses LoginForm)                    |
| `/docs`     | plain    | Documentation pages                              |
| `/settings` | home     | User settings with `_api` folder                 |
| `/examples` | home     | Framework demo page with `_api` and `_sync` examples |
| `/admin`    | (none)   | Admin pages                                      |

### API/Sync Convention

**API Routes** (server-only functions):

- Place files in `src/{page}/_api/{name}.ts`
- Export `main` function and optional `auth` guard
- Call from client: `apiRequest({ name: '{name}' })`

**Sync Routes** (real-time client-server events):

- `src/{page}/_sync/{name}_server.ts` - Runs on server for validation, returns `serverOutput`
- `src/{page}/_sync/{name}_client.ts` - Runs on receiving clients, returns `clientOutput`
- Both files use `clientInput` in SyncParams for the original sender's data
- Call from client: `syncRequest({ name: '{name}', data: clientInput, receiver: 'room-code' })`

---

## Styling

- **TailwindCSS v4** with custom colors in `src/index.css`
- Theme support: light (default) and dark mode via CSS classes
- Custom CSS variables for theme colors defined in `@theme` block:
  - Layout: `background`, `container` (1-4 with `-border` and `-hover` variants)
  - Text: `title`, `common`, `muted`
  - Status: `correct`, `correct-hover`, `wrong`, `wrong-hover`
- Dark mode via `.dark` CSS class on `<html>` element
- `src/scrollbar-dark.css` - Dark scrollbar styles
</file>

<file path="src/_sockets/apiRequest.ts">
import { dev } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
import type { PagePath, ApiName, ApiInput, ApiOutput } from './apiTypes.generated';
import { getApiMethod } from './apiTypes.generated';
import notify from "src/_functions/notify";
import { enqueueApiRequest, isOnline, removeApiQueueItem } from "./offlineQueue";

//? Abort controller logic:
//? - abortable: true → always use abort controller
//? - abortable: false → never use abort controller
//? - abortable: undefined → use abort controller for GET APIs (from generated types)
const abortControllers = new Map<string, AbortController>();

/**
 * Check if an API is a GET method using the generated type map.
 * Falls back to name inference if API not found in map.
 */
const isGetMethod = (pagePath: string, apiName: string): boolean => {
  const method = getApiMethod(pagePath, apiName);
  if (method) return method === 'GET';

  // Fallback: infer from name (only 'get' prefix)
  return apiName.toLowerCase().startsWith('get');
};

export interface apiRequestResponse {
  status: 'success' | 'error';
  result?: Record<string, any>;
  errorCode?: string;
  errorParams?: {
    key: string;
    value: string | number | boolean;
  }[];
  message?: string;
}

// ═══════════════════════════════════════════════════════════════════════════════
// Type Helpers
// ═══════════════════════════════════════════════════════════════════════════════

// Check if data input is required (i.e., T does NOT allow empty object)
// Unions like {a:1} | {b:1} do NOT allow {}, so data will be required
type DataRequired<T> = {} extends T ? false : true;

// ═══════════════════════════════════════════════════════════════════════════════
// Global API Params - Union of ALL valid API calls with proper data enforcement
// ═══════════════════════════════════════════════════════════════════════════════

// All possible API names across all pages
type AllApiNames = {
  [P in PagePath]: ApiName<P>
}[PagePath];

// Force expansion of types to clear aliases in tooltips
type Prettify<T> = { [K in keyof T]: T[K] } & {};

// Get input type for an API name (union if exists on multiple pages)
type InputForName<N extends AllApiNames> = {
  [P in PagePath]: N extends ApiName<P> ? ApiInput<P, N> : never
}[PagePath];

// Get output type for an API name (union if exists on multiple pages)
type OutputForName<N extends AllApiNames> = {
  [P in PagePath]: N extends ApiName<P> ? ApiOutput<P, N> : never
}[PagePath];

// Build params type for a specific API name
type ApiParamsForName<N extends AllApiNames> =
  DataRequired<InputForName<N>> extends true
  ? { name: N; data: Prettify<InputForName<N>>; abortable?: boolean; disableErrorMessage?: boolean; }
  : { name: N; data?: Prettify<InputForName<N>>; abortable?: boolean; disableErrorMessage?: boolean; };

// ═══════════════════════════════════════════════════════════════════════════════
// Page-Specific Params (for exact types when duplicate names exist)
// ═══════════════════════════════════════════════════════════════════════════════

// Build params type for a specific page and API name
type PageApiParamsForName<P extends PagePath, N extends ApiName<P>> =
  DataRequired<ApiInput<P, N>> extends true
  ? { name: N; data: ApiInput<P, N>; abortable?: boolean; disableErrorMessage?: boolean; }
  : { name: N; data?: ApiInput<P, N>; abortable?: boolean; disableErrorMessage?: boolean; };

/**
 * Type-safe API request function.
 * 
 * @example
 * ```typescript
 * // Normal usage - shows all APIs with data validation
 * const result = await apiRequest({ name: 'publicApi', data: { message: 'hello' } });
 * // result is typed correctly for publicApi
 * 
 * // Page-specific for exact types when duplicates exist
 * await apiRequest<'examples', 'publicApi'>({ name: 'publicApi', data: { message: 'hello' } });
 * ```
 */

// Overload 1: Name-based inference - PRIMARY usage
// TypeScript infers N from the literal name value
// Use: apiRequest({ name: "publicApi", ... })
export function apiRequest<N extends AllApiNames>(
  params: ApiParamsForName<N>
): Promise<Prettify<OutputForName<N>>>;

// Overload 2: Explicit page + name - for duplicate API names across pages
// Both type params REQUIRED when specifying page
// Use: apiRequest<"examples", "publicApi">({ name: "publicApi", ... })
export function apiRequest<P extends PagePath, N extends ApiName<P>>(
  params: PageApiParamsForName<P, N>
): Promise<ApiOutput<P, N>>;

// Implementation (not exposed to TypeScript - only runtime)
export function apiRequest(params: any): Promise<any> {
  const { name, disableErrorMessage = false } = params;
  let { data } = params;
  return new Promise(async (resolve, reject) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name");
        toast.error("Invalid name");
      }
      return resolve(null as any);
    }

    if (!data || typeof data !== "object") {
      data = {} as any;
    }

    if (!await waitForSocket()) { return resolve(null as any); }
    if (!socket) { return resolve(null as any); }

    //? Abort controller logic:
    //? - abortable: true → always use abort controller
    //? - abortable: false → never use abort controller  
    //? - abortable: undefined → smart default (GET APIs get abort controller)
    const pathname = window.location.pathname;
    const pagePath = pathname.startsWith('/') ? pathname.slice(1) : pathname;
    const isGet = isGetMethod(pagePath, name as string);
    const useAbortController = params.abortable === true || isGet;
    const fullname = (name as string) != 'session' && (name as string) != 'logout' ? `api${pathname}/${name}` : name;
    // example: api/games/boerZoektVrouw/getGameData

    let signal: AbortSignal | null = null;
    let abortFunc = () => { };
    let queueId: string | null = null;

    if (useAbortController) {
      if (abortControllers.has(fullname as string)) {
        //? if we have an abort controller we abort it and create a new one
        const prevAbortController = abortControllers.get(fullname as string);
        prevAbortController?.abort();
      }
      //? here we create a new abort controller and add it to the map with the api fullname as the key
      const abortController = new AbortController();
      abortControllers.set(fullname as string, abortController);
      abortFunc = () => {
        if (signal) { signal.removeEventListener("abort", abortFunc); }
        if (queueId) { removeApiQueueItem(queueId); }
        reject(`Request ${fullname} aborted`)
      };
      //? here we bind the abortFunc to the abort event so it will be called when the abort controller is aborted
      signal = abortController.signal;
      signal.addEventListener("abort", abortFunc);
    }

    const canSendNow = () => {
      if (!socket) return false;
      if (!socket.connected) return false;
      return isOnline();
    };

    const runRequest = (socketInstance) => {
      if (!canSendNow()) {
        if (!queueId) {
          queueId = `${Date.now()}-${Math.random()}`;
        }
        enqueueApiRequest({
          id: queueId,
          key: fullname,
          run: runRequest,
          createdAt: Date.now(),
        });
        return;
      }

      if (signal && signal.aborted) { return; }

      const tempIndex = incrementResponseIndex();
      socketInstance.emit('apiRequest', { name: fullname, data, responseIndex: tempIndex });

      if (dev && (name as string) != 'session' && (name as string) != 'logout') { console.log(`Client API Request(${tempIndex}): `, { name, data }) }
      socketInstance.once(`apiResponse-${tempIndex}`, ({ result, message, status, errorCode, errorParams }: {
        result: any;
        message: string;
        status: "success" | "error";
        errorCode?: string;
        errorParams?: {
          key: string;
          value: string | number | boolean;
        }[];
      }) => {
        if (signal && signal.aborted) { return; }

        if (status === "error") {
          if (!disableErrorMessage) {
            // toast.error(message)
            if (errorCode) {
              notify.error({ key: errorCode, params: errorParams })
            } else {
              notify.error({ key: message })
            }
          }
          return resolve({
            status,
            message,
            errorCode,
            errorParams
          } as any)
        }

        if (dev && (name as string) != 'session' && (name as string) != 'logout') { console.log(`Server API Response(${tempIndex}): `, { name, ...result }) }
        if (dev && (name as string) == 'session') { console.log(`Session result(${tempIndex}): `, result) }
        if (dev && (name as string) == 'logout') { console.log(`Logout result(${tempIndex}): `, result) }

        if (signal) {
          signal.removeEventListener("abort", abortFunc);
          abortControllers.delete(fullname as string);
        }

        resolve(result)
      });
    };

    runRequest(socket);
  })
}
</file>

<file path="src/examples/page.tsx">
import { useEffect, useState } from 'react';
import { Link } from "react-router-dom";

import notify from "src/_functions/notify";
import { useSession } from "src/_providers/SessionProvider";
import { apiRequest } from "src/_sockets/apiRequest";
import { joinRoom } from "src/_sockets/socketInitializer";
import { syncRequest, useSyncEvents } from "src/_sockets/syncRequest";

export const template = 'home';

export default function ExamplesPage() {
  const { session } = useSession();
  const [counter, setCounter] = useState(0);
  const [apiResults, setApiResults] = useState<{ name: string; result: unknown; ts: string }[]>([]);

  useEffect(() => {
    void joinRoom('examples-room');
  }, []);

  const { upsertSyncEventCallback } = useSyncEvents();

  upsertSyncEventCallback('updateCounter', ({ serverOutput, clientOutput }) => {
    console.log(clientOutput)
    setCounter(prev => serverOutput.increase ? prev + 1 : prev - 1);
  });

  const logResult = (name: string, result: unknown) => {
    setApiResults(prev => [{ name, result, ts: new Date().toLocaleTimeString() }, ...prev.slice(0, 4)]);
  };

  return (
    <div className="w-full h-full bg-background overflow-y-auto">
      <div className="max-w-6xl mx-auto p-6 flex flex-col gap-6">

        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex flex-col gap-1">
            <h1 className="text-3xl font-bold text-title">LuckyStack Examples</h1>
            <p className="text-muted text-sm">Interactive demo of all framework features</p>
          </div>
          <Link to="/docs" className="px-4 h-9 bg-container border border-container-border text-commen rounded-md flex items-center justify-center hover:scale-105 transition-all duration-300">
            📖 Docs
          </Link>
        </div>

        {/* Bento Grid */}
        <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 auto-rows-auto">

          {/* User Info - Tall */}
          <div className="md:row-span-2 bg-container border border-container-border rounded-lg p-5 flex flex-col gap-4">
            <h2 className="font-semibold text-title flex items-center gap-2">
              <span className="w-6 h-6 bg-blue-500 rounded flex items-center justify-center text-white text-xs">👤</span>
              User Info
            </h2>
            {session?.id ? (
              <div className="flex flex-col gap-3 flex-1">
                <div className="w-16 h-16 bg-container2 border border-container2-border rounded-full flex items-center justify-center text-title text-2xl font-bold">
                  {session.name.charAt(0).toUpperCase()}
                </div>
                <div className="flex flex-col gap-1">
                  <p className="text-title font-medium">{session.name}</p>
                  <p className="text-xs text-muted">{session.email}</p>
                  <p className={`text-xs mt-2 px-2 py-1 rounded inline-block w-fit ${session.admin ? 'bg-correct text-white' : 'bg-container2 text-muted'}`}>
                    {session.admin ? '✓ Admin' : 'Not Admin'}
                  </p>
                </div>
                <button
                  onClick={() => {
                    void (async () => {
                      const result = await apiRequest({ name: 'logout' })
                      logResult('logout', result)
                    })();
                  }}
                  className="mt-auto px-4 h-9 bg-container2 border border-container2-border text-commen rounded-md hover:bg-container2-hover transition-colors text-sm"
                >
                  Logout
                </button>
              </div>
            ) : (
              <div className="flex flex-col gap-3 flex-1 items-center justify-center">
                <p className="text-muted text-sm">Not logged in</p>
                <Link to="/login" className="px-4 h-9 bg-blue-500 text-white rounded-md flex items-center justify-center hover:scale-105 transition-all duration-300 text-sm">
                  Go to Login
                </Link>
              </div>
            )}
          </div>

          {/* Real-time Sync - Wide */}
          <div className="md:col-span-2 lg:col-span-3 bg-container border border-container-border rounded-lg p-5 flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <h2 className="font-semibold text-title flex items-center gap-2">
                <span className="w-6 h-6 bg-orange-500 rounded flex items-center justify-center text-white text-xs">⚡</span>
                Real-time Sync
              </h2>
              <span className="text-xs text-muted">Open in 2 tabs to test</span>
            </div>
            <div className="flex items-center gap-6 justify-center py-4">
              <button
                onClick={() => { void syncRequest({ name: 'updateCounter', data: { increase: false }, receiver: 'examples-room' }); }}
                className="w-14 h-14 bg-wrong text-white rounded-full text-3xl font-bold hover:scale-110 transition-transform cursor-pointer"
              >−</button>
              <div className="w-28 h-20 bg-container2 border border-container2-border rounded-lg flex items-center justify-center">
                <span className="text-4xl font-bold text-title">{counter}</span>
              </div>
              <button
                onClick={() => { void syncRequest({ name: 'updateCounter', data: { increase: true }, receiver: 'examples-room' }); }}
                className="w-14 h-14 bg-correct text-white rounded-full text-3xl font-bold hover:scale-110 transition-transform cursor-pointer"
              >+</button>
            </div>
          </div>

          {/* Public API */}
          <div className="bg-container border border-container-border rounded-lg p-5 flex flex-col gap-3">
            <h3 className="font-semibold text-title text-sm">🌐 Public API</h3>
            <p className="text-xs text-muted">No login needed</p>
            <button
              onClick={() => void apiRequest<"examples", "publicApi">({ name: "publicApi", data: { message: "Message sent from the client!" } })}
              className="mt-auto px-4 h-9 bg-correct text-white rounded-md hover:bg-correct-hover transition-colors text-sm cursor-pointer"
            >
              Call API
            </button>
          </div>

          {/* Toggle Admin */}
          <div className="bg-container border border-container-border rounded-lg p-5 flex flex-col gap-3">
            <h3 className="font-semibold text-title text-sm">🔄 Toggle Admin</h3>
            <p className="text-xs text-muted">Requires login</p>
            <button
              onClick={() => void apiRequest({ name: "toggleAdmin" })}
              className="mt-auto px-4 h-9 bg-orange-500 text-white rounded-md hover:bg-orange-600 transition-colors text-sm cursor-pointer"
            >
              Toggle
            </button>
          </div>

          {/* Admin Only */}
          <div className="bg-container border border-container-border rounded-lg p-5 flex flex-col gap-3">
            <h3 className="font-semibold text-title text-sm">🔐 Admin Only</h3>
            <p className="text-xs text-muted">admin: true required</p>
            <button
              onClick={() => {
                void (async () => {
                  const result = await apiRequest({ name: 'adminOnly' })
                  logResult('adminOnly', result)
                })();
              }}
              className="mt-auto px-4 h-9 bg-wrong text-white rounded-md hover:bg-wrong-hover transition-colors text-sm cursor-pointer"
            >
              Call API
            </button>
          </div>

          {/* Notification - Wide */}
          <div className="md:col-span-2 bg-container border border-container-border rounded-lg p-5 flex flex-col gap-3">
            <h3 className="font-semibold text-title text-sm">🔔 Notifications</h3>
            <p className="text-xs text-muted">Toast system with translation support (Sonner)</p>
            <div className="flex gap-2 mt-auto">
              <button
                onClick={() => { notify.success({ key: 'test', params: [{ key: 'name', value: session?.name ?? 'Guest' }] }); }}
                className="flex-1 px-4 h-9 bg-correct text-white rounded-md hover:bg-correct-hover transition-colors text-sm cursor-pointer"
              >
                ✓ Success
              </button>
              <button
                onClick={() => { notify.error({ key: 'commen/.404' }); }}
                className="flex-1 px-4 h-9 bg-wrong text-white rounded-md hover:bg-wrong-hover transition-colors text-sm cursor-pointer"
              >
                ✗ Error
              </button>
            </div>
          </div>

          {/* API Results - Full Width */}
          <div className="md:col-span-3 lg:col-span-4 bg-container border border-container-border rounded-lg p-5 flex flex-col gap-3">
            <h3 className="font-semibold text-title text-sm">📋 API Results</h3>
            {apiResults.length === 0 ? (
              <p className="text-xs text-muted">Click an API button to see results here</p>
            ) : (
              <div className="flex flex-col gap-2 max-h-48 overflow-y-auto">
                {apiResults.map((item) => (
                  <div key={`${item.name}-${item.ts}`} className="flex gap-3 text-xs p-2 bg-container2 border border-container2-border rounded">
                    <span className="font-mono text-blue-500 w-32 flex-shrink-0">{item.name}</span>
                    <span className="text-muted">{item.ts}</span>
                    <pre className="text-commen flex-1 overflow-x-auto">{JSON.stringify(item.result, null, 0)}</pre>
                  </div>
                ))}
              </div>
            )}
          </div>

        </div>
      </div>
    </div>
  );
}
</file>

</files>
