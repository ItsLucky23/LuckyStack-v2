This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursorrules
.gitignore
configTemplate.txt
envTemplate.txt
eslint.config.js
index.html
package.json
postcss.config.mjs
prisma/schema.prisma
PROJECT_CONTEXT.md
public/apple.png
public/discord.png
public/facebook.png
public/favicon.ico
public/github.png
public/google.png
public/instagram.png
public/linkedIn.png
public/x.png
README.md
redis.conf
scripts/bundleServer.ts
scripts/clearServerRequests.ts
scripts/generateServerRequests.ts
server/auth/checkOrigin.ts
server/auth/login.ts
server/auth/loginConfig.ts
server/dev/hotReload.ts
server/dev/loader.ts
server/dev/request.py
server/functions/boardcaster.ts
server/functions/db.ts
server/functions/game.ts
server/functions/redis.ts
server/functions/session.ts
server/functions/sleep.ts
server/functions/tryCatch.ts
server/prod/generatedApis.ts
server/prod/serveFile.ts
server/server.ts
server/sockets/handleApiRequest.ts
server/sockets/handleSyncRequest.ts
server/sockets/socket.ts
server/sockets/utils/activityBroadcaster.ts
server/sockets/utils/logout.ts
server/sockets/utils/onLocationChange.ts
server/utils/console.log.ts
server/utils/getParams.ts
server/utils/repl.ts
server/utils/serveAvatars.ts
src/_components/Avatar.tsx
src/_components/AvatarProvider.tsx
src/_components/ConfirmMenu.tsx
src/_components/Icon.tsx
src/_components/LocationProvider.tsx
src/_components/LoginForm.tsx
src/_components/MenuHandler.tsx
src/_components/Middleware.tsx
src/_components/Navbar.tsx
src/_components/Router.tsx
src/_components/TemplateProvider.tsx
src/_components/ThemeToggler.tsx
src/_components/TranslationProvider.tsx
src/_functions/confetti.ts
src/_functions/icon.ts
src/_functions/menuHandler.ts
src/_functions/middlewareHandler.ts
src/_functions/notify.ts
src/_functions/sleep.ts
src/_functions/translator.ts
src/_functions/tryCatch.ts
src/_locales/de.json
src/_locales/en.json
src/_locales/fr.json
src/_locales/nl.json
src/_providers/SessionProvider.tsx
src/_providers/socketStatusProvider.tsx
src/_sockets/apiRequest.ts
src/_sockets/socketInitializer.ts
src/_sockets/syncRequest.ts
src/admin/page.tsx
src/index.css
src/login/page.tsx
src/main.tsx
src/page.tsx
src/register/page.tsx
src/scrollbar-dark.css
src/scrollbar-white.css
src/settings/_api/updateUser.ts
src/settings/page.tsx
src/test/_api/testApi.ts
src/test/_sync/updateCounter_client.ts
src/test/_sync/updateCounter_server.ts
src/test/page.tsx
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.server.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursorrules">
# Cursor AI Project Rules

You have access to valid project context in the following files. You should prioritize reading these files to understand the project structure, configuration, and current state before proposing changes or answering complex questions:

1. **`repomix-output.xml`**: Contains a comprehensive dump or summary of the codebase. Check this for overall code patterns and existing implementation.
2. **`PROJECT_CONTEXT.md`**: Contains high-level architecture documentation, terminology, and design decisions. useful for "big picture" understanding.
3. **`config.ts`**: Contains the main application configuration constants and types.
4. **`.env`**: Contains environment variables and active configuration settings.

## Behavior
- When starting a significant task, always check `PROJECT_CONTEXT.md` first.
- If you need to understand the broader codebase without searching every file, `repomix-output.xml` is a good source.
- Verify configuration values in `config.ts` and `.env` when debugging or adding features.

## Context Update Rule (IMPORTANT)
**After every code change, you MUST:**
1. **Update `PROJECT_CONTEXT.md`** - Document any new files, functions, patterns, or behavior changes you've made. Keep the documentation in sync with the codebase.
2. **Regenerate `repomix-output.xml`** - Run `npx repomix` to regenerate the codebase summary with your changes.

This ensures future AI sessions have accurate context about the current state of the codebase.
</file>

<file path="PROJECT_CONTEXT.md">
<!-- 
  to toggle markdown file press  
  1. ctrl + k
  2. v
-->


# UI-Builder Project Context

> **Human-readable documentation for AI assistants to understand this project.**  
> Last updated: 2025-01-11

---

## Project Overview

**UI-Builder** (internally called "LuckyStack") is a **creative platform** for:
- **Visual UI development** - Upload `.tsx/.jsx` files, compile with Babel, and render live in viewports
- **Idea organization** - Notes, drawings, and file management on an infinite 2D canvas
- **Future: Real-time collaboration** - Room-based sync infrastructure is built-in

The project is split into two logical parts:
1. **Framework** - Custom full-stack framework with authentication, sockets, and API routing
2. **Application (Sandbox)** - The main canvas-based workspace where users create

---

# Part 1: Framework Summary

The framework is a **custom-built React + Node.js stack** inspired by Next.js but with socket-first architecture.

## Root Configuration Files

| File | Purpose |
|------|---------|
| `config.ts` | Main app configuration (URLs, defaults, session layout). Gitignored - use `configTemplate.txt` |
| `envTemplate.txt` | Template for `.env` file with database, OAuth, and server secrets |
| `vite.config.ts` | Vite bundler config with path aliases (`src/`, `config`) and exclusions for server files |
| `index.html` | Entry point with two root divs: `#root` (app) and `#portalRoot` (modals/overlays z-999999999) |
| `redis.conf` | Redis configuration for session storage |
| `prisma/schema.prisma` | MongoDB database schema - currently only `user` model with OAuth providers |

## Server Architecture (`/server`)

The backend is **raw Node.js** (no Express) with a custom HTTP router and Socket.io.

### `server/server.ts` - Main Entry Point
- Creates HTTP server with CORS, security headers (Referrer-Policy, X-Frame-Options, X-XSS-Protection)
- HTTP route handling by path prefix:
  - `/auth/api/{provider}` → Redirects to OAuth provider or handles credentials login
  - `/auth/callback/{provider}` → Handles OAuth callback from providers
  - `/uploads/*` → Serves uploaded files (avatars, etc.)
  - `/assets/*` → Serves static assets
  - Everything else → Falls back to `index.html` for SPA routing
- In development mode: initializes hot-reload watchers and REPL console
- Initializes Socket.io via `loadSocket()`

### `server/auth/` - Authentication System

| File | Purpose |
|------|---------|
| `login.ts` | Handles credentials login/register and OAuth callback processing |
| `loginConfig.ts` | Defines 5 OAuth provider configs (credentials, Google, GitHub, Discord, Facebook) |
| `checkOrigin.ts` | Validates request origins against allowed domains (DNS, localhost, external origins) |

**Supported Providers:** credentials, Google, GitHub, Facebook, Discord

**Login Flow:**
1. Credentials: Validates email/password, hashes with bcrypt, creates/authenticates user
2. OAuth: Redirects to provider → callback exchanges code for token → fetches user info → creates/finds user
3. On successful login, generates random token and saves session to Redis

### `server/sockets/socket.ts` - Socket.io Server
Handles all real-time communication:
- **`apiRequest`** - RPC-style API calls from client (routed via `handleApiRequest.ts`)
- **`sync`** - Room-based sync events between clients (routed via `handleSyncRequest.ts`)
- **`joinRoom`** - Adds socket to a room (room code stored in session)
- **`updateLocation`** - Tracks user's current page path
- **`disconnect`** - Handles socket disconnection with optional activity broadcasting

### `server/sockets/handleApiRequest.ts` - API Request Handler
- Special handlers for `session` (returns user session) and `logout` (logs out user)
- Validates `auth` requirements before executing API functions
- **Auth Validation System** supports flexible conditions:
  - `login: true` - Requires user to be logged in
  - `additional: [{key, type?, value?, nullish?, mustBeFalsy?}]` - Custom field checks

### `server/sockets/handleSyncRequest.ts` - Sync Request Handler
- Validates server-side sync file before broadcasting
- Loops through all sockets in the room and runs client-side sync for each
- Supports `ignoreSelf` to exclude sender from receiving the event

### `server/functions/` - Server Utilities
| File | Purpose |
|------|---------|
| `session.ts` | Session CRUD in Redis + **auto-kicks previous sessions on login** |
| `redis.ts` | Redis client wrapper (ioredis) |
| `db.ts` | Prisma client export for MongoDB |
| `tryCatch.ts` | Error-safe async function wrapper |
| `sleep.ts` | Promise-based delay |
| `broadcaster.ts` | Utility for broadcasting to socket rooms |
| `game.ts` | Game-related utilities (for multiplayer games) |

### Session Kicking Feature (`session.ts`)
When a user logs in, the system automatically kicks all previous sessions for that user:
1. Looks up all active tokens for the user ID in Redis
2. For each existing session: emits `logout` event to connected sockets, deletes session data
3. Registers new token in the active users set
4. Broadcasts `updateSession` to all sockets with the new token

### `server/dev/` - Development Utilities
| File | Purpose |
|------|---------|
| `loader.ts` | Hot-reloads `_api` and `_sync` files without server restart |
| `hotReload.ts` | File watcher that triggers reloads on changes |

### `server/sockets/utils/` - Socket Utilities
| File | Purpose |
|------|---------|
| `logout.ts` | Handles logout: clears timers, leaves rooms, deletes session |
| `activityBroadcaster.ts` | Tracks user activity (AFK detection, reconnection) |

### Build Scripts (`/scripts`)
| Script | Purpose |
|--------|---------|
| `generateServerRequests.ts` | Scans `src/` for `_api/` and `_sync/` folders, generates route map |
| `bundleServer.ts` | Bundles server for production |
| `clearServerRequests.ts` | Clears generated route map for dev restart |

---

## Client Architecture (`/src`)

### Entry Point: `main.tsx`
- File-based routing similar to Next.js
- Scans for `page.tsx` in any non-underscore folder
- Wraps app in providers: `SocketStatus` → `Session` → `Translation` → `Avatar` → `MenuHandler` → `Router`

### Provider Hierarchy (Framework-level)
```
SocketStatusProvider   # Socket connection status
└── SessionProvider    # User session from Redis
    └── TranslationProvider  # i18n with JSON locale files
        └── AvatarProvider   # User avatar caching
            └── MenuHandlerProvider  # Global menu state
                └── RouterProvider   # React Router
```

### `src/_sockets/` - Client-Server Communication

These are the core functions for communicating with the backend:

#### `apiRequest({ name, data })` → Promise
- Sends RPC-style request over socket
- Auto-prefixes with current path: `api/{path}/{name}`
- Has abort controllers for duplicate GET-like requests

#### `syncRequest({ name, data, receiver, ignoreSelf })` → Promise  
- Sends real-time events to other clients in same room
- `receiver` is the room code (e.g., "abc123")
- `ignoreSelf` prevents the sender from receiving the event

#### `joinRoom(code)` → Promise
- Joins a socket room for sync events
- Room code stored in user session

### `src/_components/` - Reusable UI Components

| Component | Purpose |
|-----------|---------|
| `TemplateProvider.tsx` | Wraps pages in templates: `plain`, `main`, `sandbox` |
| `SessionProvider.tsx` | Provides session context and socket initialization |
| `Middleware.tsx` | Route authentication guards |
| `LoginForm.tsx` | OAuth login buttons |
| `MenuHandler.tsx` | Global menu/modal management |
| `Navbar.tsx` | Top navigation bar |
| `Tooltip.tsx` | Hover tooltips |
| `Dropdown.tsx` | Dropdown menus |
| `ConfirmMenu.tsx` | Confirmation dialogs |
| `TranslationProvider.tsx` | i18n with `src/_locales/{lang}.json` |

### Templates (`TemplateProvider.tsx`)

Pages export a `template` constant to specify their wrapper:

1. **`plain`** - Minimal wrapper, no UI chrome
2. **`main`** - Navbar with user info and navigation
3. **`sandbox`** - Full sandbox with all feature providers:
   ```
   GridProvider → BlueprintsProvider → BuilderPanelProvider → 
   MenusProvider → CodeProvider → DrawingProvider → NotesProvider → MainTemplate
   ```

### Page Routes

| Route | Template | Purpose |
|-------|----------|---------|
| `/` | plain | Root redirect based on session |
| `/login` | plain | OAuth login page |
| `/register` | plain | Registration (uses LoginForm) |
| `/home` | main | Sandbox selection (in progress) |
| `/settings` | main | User settings with `_api` folder |
| `/test` | main | Development testing with `_api` and `_sync` examples |
| `/sandbox` | sandbox | Main application canvas |

### API/Sync Convention

**API Routes** (server-only functions):
- Place files in `src/{page}/_api/{name}.ts`
- Export `main` function and optional `auth` guard
- Call from client: `apiRequest({ name: '{name}' })`

**Sync Routes** (real-time client-server events):
- `src/{page}/_sync/{name}_server.ts` - Runs on server for validation
- `src/{page}/_sync/{name}_client.ts` - Runs on receiving clients
- Call from client: `syncRequest({ name: '{name}', receiver: 'room-code' })`

---

## Styling

- **TailwindCSS v4** with custom colors in `src/index.css`
- Theme support: light (default) and dark mode via CSS classes
- Custom CSS variables for colors (`--color-background`, `--color-primary`, etc.)
- `src/NoteEditor.css` - ProseMirror/TipTap styles for notes
- `src/scrollbar-*.css` - Theme-specific scrollbar styles (not yet dynamically loaded)

---

# Part 2: Application Summary
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

.env
node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

config.ts
config

uploads/**
</file>

<file path="configTemplate.txt">
import { PrismaClient } from "@prisma/client";

const config = {
  // backendUrl: 'https://your.domain.com', //* the url of the backend server
  backendUrl: 'http://localhost:80', //* the url of the backend server

  dev: true, //* if true then we get extra console logs
  loginPageUrl: '/login', //* url the client is redirected to when the user is not authenticate
  loginRedirectUrl: '/test', //* url the client is redirected to after logging in
  defaultLanguage: 'en', //* default language if the session data doesnt include it, this is used with the notify system with the json files in the localed folder
  defaultTheme: 'dark', //* the default theme the client uses when the user hasnt set a theme yet
  mobileConsole: false, //* if true then there is a extra console you can open on any device (including mobile)

  
  //? if false syncing works to users in your room but they wont know who they are sycning to
  //? if true on the client we know the activity status of all users in the same room
  //? this is usefull for multiplayer games to e.g. pause the game when a user is afk
  //? this data is stored in socketStatus (context provider)
  socketActivityBroadcaster: false
}
//* these values are optional to have in the session object, used for type declartion after an apiRequest on the client
export interface SessionLayout {
  id: string;
  name: string;
  email: string;
  provider: string;
  admin: boolean;
  avatar: string;
  avatarFallback: string;
  language: string;
  theme: 'light' | 'dark';
  createdAt: Date;
  updatedAt: Date;
  token: string;
  location?: {
    pathName: string;
    searchParams: {
      [key: string]: string;
    };
  };
};

export interface AuthProps {
  login: boolean; //* if true then the user needs to have an id in the session object
  additional?: { //* if true then the user needs to have the additional keys in the session object with the condition
    key: keyof SessionLayout; //* the key of the session object
    value?: any //* the exact value the key needs to have. this is a strict comparison
    type?: 'string' | 'number' | 'boolean'; //* the type of the key. this is a strict comparison
    nullish?: boolean; //* if true then the key needs to be null or undefined, if false then the key needs to be not null and not undefined
    mustBeFalsy?: boolean; //* if true than the passes key needs to be a false value such as false, 0, -0, 0n, "", null, undefined or NaN, if false then the key needs to be a true value such as true, 1, 'a' or any other value
  }[]
}

interface ServerFunctions {
  prisma: PrismaClient;

  saveSession: (token: string, data: any) => Promise<boolean>;
  getSession: (token: string) => Promise<any | null>;
  deleteSession: (token: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;
  sleep: (ms: number) => Promise<void>;

  [key: string]: any; // allows you to call functions you made yourself, autocomplete wont work for your own functions if you dont add them here
};


export interface ServerSyncProps {
  clientData: any;
  functions: ServerFunctions;
  user: SessionLayout;
}

export interface ClientSyncProps extends ServerSyncProps {
  serverData: any;
}

export const providers = ['credentials', 'google', 'github', 'facebook', 'discord'];

export default config;
export const { backendUrl, dev, loginPageUrl, loginRedirectUrl, defaultLanguage, mobileConsole } = config;
</file>

<file path="envTemplate.txt">
# NODE_ENV=production # development | production
NODE_ENV=development # development | production
# VITE_SESSION_BASED_TOKEN=false # when true we store the token in the sessionStorage wich allows you to upen multiple tabs at the same time and have different session data on there, if false we use cookies
VITE_SESSION_BASED_TOKEN=true # when true we store the token in the sessionStorage wich allows you to upen multiple tabs at the same time and have different session data on there, if false we use cookies
# SECURE=true # when true we use https else http, make sure your nginx server is configured to use https if this is set to true
SECURE=false # when true we use https else http, make sure your nginx server is configured to use https if this is set to true
PROJECT_NAME=YOUR_PROJECT_NAME # used for the redis cache so that when using the same template other session data will not collide with this one
# example would be that if you login here with a certain email that on a different project you will not be logged out automaticly cause it is a different project (on the same project you will be logged out)

SERVER_IP=localhost # this should either be localhost if using a reverse proxy or 0.0.0.0 if you want other devices on your network to access the server to test mobile support for example or networking between devices. have it set to the ip when calling the node server directly
# SERVER_PORT=3000 # 80 for localhost and for production any port you like e.g 3000
SERVER_PORT=80 # 80 for localhost and for production any port you like e.g 3000

# DNS is used to redirect the user to the server when they login with oauth
# so when NODE_ENV is set to development it should be someting like http://localhost:5173
# and when NODE_ENV is set to production it should be someting like https://random.dns.com
# DNS=https://random.dns.com
DNS=http://localhost:5173

REDIS_HOST=127.0.0.1
REDIS_PORT=6379

#here you can add urls that are allowed to communicate with the server, such as oauth urls
#when adding new urls make sure to saperate them with a ','
EXTERNAL_ORIGINS=https://accounts.google.com,https://github.com,https://www.facebook.com,https://discord.com

#https://console.cloud.google.com/apis/credentials
# create a new project, go to credentials, create OAuth clientId
# scroll down to Authorized redirect URIs and add the server ip port and than /auth/callback/google
# so for dev it should be http://localhost:80/auth/callback/google
# copy the google client id and secret.

#USED FOR PRODUCTION
GOOGLE_CLIENT_ID=xxxxx
GOOGLE_CLIENT_SECRET=xxxxx
#USED FOR DEVELOPMENT
DEV_GOOGLE_CLIENT_ID=xxxxx
DEV_GOOGLE_CLIENT_SECRET=xxxxx



#https://github.com/settings/developers
# create a new OAuth app, homepage url can be http://localhost:80/auth/callback/github
# callback url should be ip port and than /auth/callback/github, so for dev it should be http://localhost:80/auth/callback/github
# than just copy the client id and secret

#USED FOR PRODUCTION
GITHUB_CLIENT_ID=xxxxxxx
GITHUB_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_GITHUB_CLIENT_ID=xxxxxxx
DEV_GITHUB_CLIENT_SECRET=xxxxxxx



#https://developers.facebook.com/async/registration/dialog/?src=default
# go to my apps and it want you to create an account, after creating an account you should be able to create a new app
# go to use cases and click customize on 'authenticate and request data from users with facebook login' and then click on quickstart
# after quick setup go to apps ettings - basics and copy the app id and app secret, the callback url for localhost is automaticly handeld but for production you need to change this
# you can change this on use cases and click on 'authenticate and request data from users with facebook login' and then click on 'settings' and go down to valid oauth redirect urls

#USED FOR PRODUCTION
FACEBOOK_CLIENT_ID=xxxxxxx
FACEBOOK_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_FACEBOOK_CLIENT_ID=xxxxxxx
DEV_FACEBOOK_CLIENT_SECRET=xxxxxxx



#https://discord.com/developers/applications
# create a new application, navigate to OAuth2, copy the client id and secret
# add a redirects url, for dev it should be http://localhost:80/auth/callback/discord

#USED FOR PRODUCTION
DISCORD_CLIENT_ID=xxxxxxx
DISCORD_CLIENT_SECRET=xxxxxxx
#USED FOR DEVELOPMENT
DEV_DISCORD_CLIENT_ID=xxxxxxx
DEV_DISCORD_CLIENT_SECRET=xxxxxxx



# https://www.linkedin.com/developers/apps/new
# requires you to have an company page wich requires id verification
# LINKEDIN_CLIENT_ID=aaaaaaaaaaa
# LINKEDIN_CLIENT_SECRET=aaaaaaaaaaa



# requires a $99 subscription to create a App id
# APPLE_CLIENT_ID=a
# APPLE_CLIENT_SECRET=a



# only supports businness accounts so you can add it yourself if you want but not worth my time right now
# INSTAGRAM_CLIENT_ID=a
# INSTAGRAM_CLIENT_SECRET=a



# currently switching from twitter to X and no clear documentation in my opinion 
# X_CLIENT_ID=a
# X_CLIENT_SECRET=a



# DATABASE_URL="provider://user:password@host:port/database"
# example: DATABASE_URL="mysql://root:@localhost:3306/test"
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import reactX from 'eslint-plugin-react-x' // Import react-x plugin
// No need to import react-dom here

export default tseslint.config(
  { ignores: ['dist'] },
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Replace ...tseslint.configs.recommended with this for strict type checking
      ...tseslint.configs.strictTypeChecked,
      // Optionally add stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // From eslint-plugin-react-x
      js.configs.recommended,
      tseslint.configs.recommended,
      reactX.configs.recommended, // Add react-x plugin's recommended configuration
      // No need to add react-dom.configs.recommended again, it's redundant
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
      // Removed react-x from plugins since it's already handled by extends
      // Removed react-dom here since it's already handled by extends
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      // You can add specific custom rules for react-x or react-dom here if necessary
    },
  },
  {
    files: [
      'src/**/*api/**/*.ts', 
      'src/**/*Api/**/*.ts', 
      'src/**/*sync/**/*.ts',
      'src/**/*Sync/**/*.ts'
    ],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
    },
  }
)
//npx eslint src/**/*.tsx
// ctrl + shift + p -> Restart TS server
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- <script src="https://unpkg.com/react-scan/dist/auto.global.js"></script> -->
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div class="w-full h-svh m-0 p-0" id="root"></div>
    <div 
      class="w-full h-svh m-0 p-0 absolute top-0 pointer-events-none overflow-hidden" id="portalRoot"
      style="z-index: 999999999;"
    ></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "lucky-stack-v2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "client": "tsx scripts/clearServerRequests.ts && vite --host",
    "server": "npx tsx server/server.ts",
    "liveServer": "npx tsx --watch server/server.ts",
    "lint": "eslint src/**/*.tsx",
    "buildClient": "tsc -b && vite build",
    "buildServer": "tsx scripts/generateServerRequests.ts && tsx scripts/bundleServer.ts",
    "build": "tsx scripts/generateServerRequests.ts && npm run buildClient && tsx scripts/bundleServer.ts",
    "prod": "node dist/server.js",
    "production": "node dist/server.js"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^7.0.1",
    "@fortawesome/free-brands-svg-icons": "^7.0.1",
    "@fortawesome/free-regular-svg-icons": "^7.0.1",
    "@fortawesome/free-solid-svg-icons": "^7.0.1",
    "@fortawesome/react-fontawesome": "^3.0.2",
    "@prisma/client": "^6.5.0",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tailwindcss/postcss": "^4.0.17",
    "bcrypt": "^5.1.1",
    "chokidar": "^4.0.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "fs": "^0.0.1-security",
    "ioredis": "^5.6.0",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.540.0",
    "path": "^0.12.7",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.4.0",
    "repl": "^0.1.3",
    "sharp": "^0.34.3",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.2",
    "url": "^0.11.4",
    "uuid": "^11.1.0",
    "validator": "^13.15.0",
    "vconsole": "^3.15.1",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@rollup/plugin-alias": "^5.1.1",
    "@types/bcrypt": "^5.0.2",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@types/validator": "^13.15.1",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.21.0",
    "eslint-plugin-react-dom": "^1.48.4",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "eslint-plugin-react-x": "^1.48.4",
    "globals": "^15.15.0",
    "postcss": "^8.5.6",
    "prisma": "^6.5.0",
    "tailwindcss": "^4.1.11",
    "tsx": "^4.19.3",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

<file path="postcss.config.mjs">
export default {
    plugins: {
        "@tailwindcss/postcss": {},
    }
}
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model user {
  id        String    @id @default(uuid())
  email     String
  name      String
  password  String?
  admin     Boolean @default(false)
  avatar    String @db.VarChar(512) @default("")
  language  String @default("en")
  theme     THEME @default(dark)
  provider  PROVIDERS
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum THEME {
  dark
  light
}

enum PROVIDERS {
  credentials
  google
  github
  x
  facebook
  linkedIn
  apple
  discord
  instagram
}

// Command:               Purpose
/*
npx prisma format:	      Auto-format your schema.prisma file (fixes spacing, indentation, style)
npx prisma validate:	    Validate that your schema.prisma is correct (syntax & relational rules)
npx prisma generate:	    Generate the Prisma Client (after changing schema or installing Prisma)
npx prisma db pull:	      Pull the current database structure into your Prisma schema (reverse-engineer an existing database)
npx prisma db push:	      Push your Prisma schema to the database — creates tables based on schema (development only, no migrations)
npx prisma migrate dev:	  Create a new migration based on schema changes and apply it to the database
npx prisma migrate reset:	Reset the database: drops all tables, re-applies migrations, and runs seed scripts if any
npx prisma studio:      	Open Prisma Studio (a GUI to view and edit database records easily)
*/
</file>

<file path="README.md">
Self made tech stack.

https://lucky23.gitbook.io/luckystack/
</file>

<file path="redis.conf">
appendonly yes          # Enable AOF persistence
appendfsync everysec    # Sync every write operation to disk every second
</file>

<file path="scripts/bundleServer.ts">
import { build } from "esbuild";
import { dependencies } from "../package.json";

const externalDeps = [
  ...Object.keys(dependencies || {}),
  // Native Node.js modules
  "fs", "path", "url", "os", "child_process", "crypto"
];

await build({
  entryPoints: ["server/server.ts"], // Adjust if entry is different
  outfile: "dist/server.js",         // Final bundled output
  bundle: true,
  platform: "node",
  target: "node22",                  // Match your runtime (Node 18, 20 etc.)
  format: "esm",                     // Your project uses "type": "module"
  sourcemap: true,
  external: externalDeps,
  logLevel: "info",
}).catch((e) => {
  console.error("Build failed:", e);
  process.exit(1);
});
</file>

<file path="scripts/clearServerRequests.ts">
//? used when running npm run dev
//? in dev mode we dont need the production apis and syncs so we clear them to avoid it erroring when e.g. changing file names

import fs from "fs";

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = { };\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };\n";
let functionsMap = "export const functions: Record<string, any> = { };";

const output = `${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
// console.log("✅ server/prod/generatedApis.ts Cleared");
</file>

<file path="scripts/generateServerRequests.ts">
import fs from "fs";
import path from "path";

const normalizePath = (p: string) => p.split(path.sep).join("/");

// Recursively walk dirs to collect _api and _sync files
const walkSrcFiles = (dir: string, results: string[] = []) => {
  const list = fs.readdirSync(dir);
  for (const file of list) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      walkSrcFiles(fullPath, results);
    } else if (file.endsWith(".ts") && (fullPath.includes("_api") || fullPath.includes("_sync"))) {
      // if (file.endsWith("_client.ts")) continue; // skip client stubs
      results.push(fullPath);
    }
  }
  return results;
};

// Collect server function files
const walkFunctionFiles = (dir: string) => {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir)
    .filter((file) => file.endsWith(".ts"))
    .map((file) => normalizePath(path.join(dir, file)));
};

// --------------------
// Collect files
// --------------------
const rawSrcFiles = walkSrcFiles("./src").map(normalizePath).sort();
const functionFiles = walkFunctionFiles("./server/functions").sort();

// --------------------
// Buckets
// --------------------
const apiImports: string[] = [];
const syncImports: string[] = [];
const functionImports: string[] = [];

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = {\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = {\n";
let functionsMap = "export const functions: Record<string, any> = {\n";

let apiCount = 0;
let syncCount = 0;
let fnCount = 0;

// --------------------
// Process API + Sync
// --------------------
rawSrcFiles.forEach((normalized) => {
  const importPath = "../../" + normalized.replace(/\.ts$/, "");

  // API
  if (normalized.includes("_api/")) {
    const varName = `api${apiCount++}`;
    apiImports.push(`import * as ${varName} from '${importPath}';`);

    // capture "games/boerZoektVrouw" and "getGameData"
    const match = normalized.match(/src\/(.+?)\/_api\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, apiName] = match;
    const routeKey = `api/${pagePath}/${apiName}`; // clean route-like key

    apiMap += `  "${routeKey}": {\n    auth: "auth" in ${varName} ? ${varName}.auth : {},\n    main: ${varName}.main,\n  },\n`;
  }

  // Sync
  if (normalized.includes("_sync/")) {
    const match = normalized.match(/src\/(.+?)\/_sync\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, syncName] = match;
    const routeKey = `sync/${pagePath}/${syncName}`;
  
    console.log(syncName)
    if (syncName.endsWith("_client")) {
      const varName = `syncClient${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": ${varName}.main,\n`;
    }
  
    if (syncName.endsWith("_server")) {
      const varName = `syncServer${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": { auth: "auth" in ${varName} ? ${varName}.auth : {}, main: ${varName}.main },\n`;
    }
  }
});

// --------------------
// Process Functions
// --------------------
functionFiles.forEach((filePath) => {
  const importPath = "../../" + filePath.replace(/\.ts$/, "");
  const varName = `fn${fnCount++}`;
  functionImports.push(`import * as ${varName} from '${importPath}';`);
  functionsMap += `  ...${varName},\n`;
});

// --------------------
// Close Maps
// --------------------
apiMap += "};\n";
syncMap += "};\n";
functionsMap += "};";

// --------------------
// Final Output
// --------------------
const importStatements = [
  ...apiImports,
  "",
  ...syncImports,
  "",
  ...functionImports,
].join("\n");

const output = `${importStatements}\n\n${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
console.log("✅ server/prod/generatedApis.ts created");
</file>

<file path="server/auth/checkOrigin.ts">
const allowedOrigin = (origin: string) => {
  const location = `http${process.env.SECURE == 'true'?'s' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}/`;
  const formattedOrigin = origin.includes('://') ? origin : `http${process.env.SECURE == 'true' ? 's' : ''}://${origin}/`;
    
  //? we check if the origin of the user is allowed to access the server directly
  if (location == formattedOrigin) { return true; } 
  if (origin == 'localhost') { return true; }

  //? if the origin is not allowed we check if the origin is allowed we port 80 or port 443 cause the browser removes these sometimes

  const externalOrigins = process.env.EXTERNAL_ORIGINS?.split(',') || [];
  for (const externalOrigin of externalOrigins) {
    if (origin == externalOrigin) { return true; }
    if (origin == externalOrigin+'/') { return true; }
  }

  if (origin == process.env.DNS) { return true; }
  if (origin == process.env.DNS+'/') { return true; }
  if (!origin.startsWith('http://') && !origin.startsWith('https://')) {
    // origin = 'https://' + origin;
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}`) { return true; }
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}/`) { return true; }
  }

  console.log('')
  console.log('origin not allowed')
  console.log('origin:', origin)
  console.log('formattedOrigin:', formattedOrigin)
  console.log('dns:', process.env.DNS)
  console.log('dns:', process.env.DNS+'/')
  for (const externalOrigin of externalOrigins) {
    console.log('externalOrigin:', externalOrigin)
    console.log('externalOrigin:', externalOrigin+'/')
  }
  return false;
}

export default allowedOrigin;
</file>

<file path="server/auth/login.ts">
import dotenv from 'dotenv';
import oauthProviders from "./loginConfig";
import { IncomingMessage, ServerResponse } from 'http';
import { URLSearchParams } from 'url';
import { tryCatch } from '../functions/tryCatch';
import { prisma } from '../functions/db';
import { Prisma, PROVIDERS } from '@prisma/client';
import bcrypt from 'bcrypt';
import { randomBytes } from 'crypto';
import { saveSession } from "../functions/session"
import validator from "validator"
import config, { SessionLayout } from '../../config';
import path from 'path';
import { existsSync } from 'fs';

dotenv.config();

type paramsType = {
  email?: string,
  password?: string,
  name?: string,
  confirmPassword?: string,
}

const uploadsFolder = path.join(process.cwd(), "uploads");

// Route that starts the OAuth flow for the specified provider and redirects to the callback endpoint
const loginWithCredentials = async (params: paramsType) => {

  const email = validator.escape(params.email || '');
  const password = validator.escape(params.password || '');
  const name = params.name ? validator.escape(params.name) : undefined;
  const confirmPassword = params. confirmPassword ? validator.escape(params.confirmPassword) : undefined;

  console.log(name, email, password, confirmPassword)
  
  if (!email || !password) { return { status: false, reason: 'login.empty' }; }
  if (email.length > 191) { return { status: false, reason: 'login.emailCharacterLimit' }; }
  if (password.length < 8) { return { status: false, reason: 'login.passwordCharacterMinimum' }; }
  if (password.length > 191) { return { status: false, reason: 'login.passwordCharacterLimit' }; }
  if (name && name.length > 191) { return { status: false, reason: 'login.nameCharacterLimit' }; }
  if (!validator.isEmail(email)) { return { status: false, reason: 'login.invalidEmailFormat' }; }

  if (name && confirmPassword) { //? register
    if (password != confirmPassword) { return { status: false, reason: 'login.passwordNotMatch' }; }

    const checkEmail = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        },
      })
    }

    //? check if email already exists
    const [checkEmailError, checkEmailResponse] = await tryCatch(checkEmail);
    if (checkEmailError) { 
      console.log(checkEmailError);
      return { status: false, reason: checkEmailError }; 
    }
    if (checkEmailResponse) { return { status: false, reason: 'login.emailExist' }; }

    //? email is not in use so we define the function to create the new user
    const createNewUser = async () => {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      return await prisma.user.create({
        data: {
          email: email,
          provider: PROVIDERS.credentials,
          name: name,
          password: hashedPassword,
          avatar: '',
          admin: false,
          language: config.defaultLanguage
        }
      }) 
    }

    //? here we create the new user
    const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
    if (createNewUserError) { return { status: false, reason: createNewUserError }; }
    if (createNewUserResponse) { return { status: true, reason: 'login.userCreated', session: createNewUserResponse }; }
    return { status: false, reason: 'login.createUserFailed' };

  } else { //? login
    //? here we define the function to find the user
    const findUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        }
      }) 
    }

    //? attempt to find the user
    const [findUserError, findUserResponse] = await tryCatch(findUser);
    if (findUserError) { 
      console.log(findUserError, ' findUserError');
      return { status: false, reason: findUserError }; 
    }
    if (!findUserResponse) { return { status: false, reason: 'login.userNotFound' }; }

    //? if we found a user we check if the password matches the hashed one in the db
    const checkPassword = async () => { return await bcrypt.compare(password, findUserResponse.password as string); }
    const [checkPasswordError, checkPasswordResponse] = await tryCatch(checkPassword);
    if (checkPasswordError) { 
      console.log(checkPasswordError, ' checkPasswordError');
      return { status: false, reason: checkPasswordError }; 
    }
    if (!checkPasswordResponse) { return { status: false, reason: 'login.wrongPassword' }; }

    //? if the password matches we return the user
    if (checkPasswordResponse) {
      const newToken = randomBytes(32).toString("hex")
      const newUser = { 
        id: findUserResponse.id,
        name: findUserResponse.name,
        provider: 'credentials',
        email: findUserResponse.email,
        createdAt: findUserResponse.createdAt,
        updatedAt: findUserResponse.updatedAt,
        token: newToken,
        avatar: findUserResponse.avatar || '',
        avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        admin: findUserResponse.admin,
        language: findUserResponse.language,
        theme: findUserResponse.theme
      };

      const filePath = path.join(uploadsFolder, `${newUser.id}.webp`);
      if (existsSync(filePath)) {
        newUser.avatar = `${newUser.id}.webp`;
      }

      await saveSession(newToken, newUser, true);
      console.log(newUser);
      return { status: true, reason: 'login.loggedIn', newToken, session: newUser };
    }
  }
}

// Route that handles the callback from the OAuth provider
const loginCallback = async (pathname: string, req: IncomingMessage, res: ServerResponse) => {
  //? check if provider exists
  const providerName = pathname.split('/')[3]; // Extract the provider (google/github)
  const provider = oauthProviders.find(p => p.name === providerName);
  if (!provider || !req.url) { return false }
  if (!('clientID' in provider)) { return }

  const queryString = req.url.split('?')[1]; // Get the part after '?'
  const params = new URLSearchParams(queryString);
  const code = params.get('code');

  //? if no code provided in the url we return false (the code is used to get the access token and should be provided by the oauth provider)
  if (!code || code == '') { 
    console.log('no code provided in callback url')
    return false 
  }

  const values = {
    code,
    client_id: provider.clientID,
    client_secret: provider.clientSecret,
    redirect_uri: provider.callbackURL,
    grant_type: 'authorization_code'
  }

  //? with the code we can get the access token
  const getToken = async () => {
    if (provider.tokenExchangeMethod == 'json') {
      const url = provider.tokenExchangeURL;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(values),
      })
      return await response.json();
    } else if (provider.tokenExchangeMethod == 'form') {
      const url = provider.tokenExchangeURL;
      const params = new URLSearchParams();
      params.append('client_id', provider.clientID);
      params.append('client_secret', provider.clientSecret);
      params.append('code', values.code);
      params.append('grant_type', 'authorization_code');
      params.append('redirect_uri', provider.callbackURL);
    
      console.log(params)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body: params.toString()
      });
    
      return await response.json();
    }
  }

  const [getTokenError, getTokenResponse] = await tryCatch(getToken)
  if (getTokenError) {
    console.log(getTokenError, 'getTokenError');
    return false;
  }

  //? here we get the access token
  const { access_token, id_token } = getTokenResponse;
  const getUserData = async () => {
    // const url = `${provider.userInfoURL}?alt=json&access_token=${access_token}`;
    const url = provider.userInfoURL;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${access_token}`
      },
    })
    return await response.json();
  }

  //? with the access_token token we get the user data 
  const [getUserDataError, getUserDataResponse] = await tryCatch(getUserData);
  if (getUserDataError) {
    console.log(getUserDataError);
    return false;
  }

  const name: string = getUserDataResponse[provider.nameKey] || 'didnt find a name'

  let email: string | undefined = getUserDataResponse[provider.emailKey];
  const avatar: string = 
    provider?.avatarKey ? getUserDataResponse[provider.avatarKey] : 
    provider.getAvatar ? provider.getAvatar({userData: getUserDataResponse, avatarId: getUserDataResponse[provider.avatarCodeKey]}) : '';

  console.log(avatar)
  // const user = {
  //   id: '',
  //   name,
  //   provider: provider.name,
  //   email,
  //   createdAt: new Date(),
  //   updatedAt: new Date(),
  //   token: '',
  //   avatar,
  //   admin: false,
  //   language: config.defaultLanguage
  // }

  //? if we didnt find the email we try to get it with a external link if this one is provided
  if (!email && provider.getEmail) {
    const selectedEmail = await provider.getEmail(access_token);
    
    if (!selectedEmail) {
      console.log('no email found');
      return false; 
    }

    email = selectedEmail;
  }

  let tempUser: SessionLayout | undefined;
  if (email) {
    const fetchUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: provider.name as PROVIDERS
        }
      })
    } 

    //? here we check if the user exists in the db
    const [userDataError, userDataResponse] = await tryCatch(fetchUser);
    if (userDataError) {
      console.log(userDataError);
      return false;
    }

    console.log('ASDSADASDDASDA')
    //? if the user exists we assign it to the tempUser variable
    if (userDataResponse?.id) { 
      const { password, ...safeData } = userDataResponse;
      const filePath = path.join(uploadsFolder, `${safeData.id}.webp`);
      if (existsSync(filePath)) {
        safeData.avatar = `${safeData.id}.webp`;
      }

      tempUser = {
        ...safeData, 
        avatarFallback: 
        `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        token: '' 
      }; 
    }

    //? if the user doesnt exist we create a new one
    if (!tempUser) {
      const createNewUser = async () => {
        if (!email) { return false; }
        return await prisma.user.create({
          data: {
            email,
            provider: provider.name as PROVIDERS,
            name,
            avatar,
            language: config.defaultLanguage
          }
        })
      }
      const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
      if (createNewUserError) {
        console.log(createNewUserError);
        return false;
      }

      if (createNewUserResponse) { 
        const { password,...safeData } = createNewUserResponse;
        tempUser = {
          ...safeData, 
          avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
          token: ''
        }; 
      }
    }
  }

  if (!tempUser) {
    return false;
  }

  //? here we create a new token, create the users session and return the token as a sign of success
  const newToken = randomBytes(32).toString("hex")
  // user.id = tempUser.id;
  // user.createdAt = tempUser.createdAt;
  // user.updatedAt = tempUser.updatedAt;
  // user.token = newToken;
  // user.admin = tempUser.admin
  // user.language = config.defaultLanguage;
  // if (tempUser.avatar) { user.avatar = tempUser.avatar; }


  tempUser.token = newToken;
  await saveSession(newToken, tempUser, true);
  console.log(tempUser)
  return newToken;
}

export { loginWithCredentials, loginCallback }
</file>

<file path="server/auth/loginConfig.ts">
import dotenv from 'dotenv';
import { tryCatch } from '../functions/tryCatch';

dotenv.config(); // Load environment variables from .env file

interface BasicProvider {
  name: string;
}

interface FullProvider {
  name: string,
  clientID: string,
  clientSecret: string,
  callbackURL: string,
  authorizationURL: string,
  tokenExchangeURL: string,
  tokenExchangeMethod: 'json' | 'form',
  userInfoURL: string,
  scope: string[],
  getEmail?: (access_token: string) => Promise<string | false | undefined>,
  nameKey: string,
  emailKey: string, 

  avatarKey?: string, //? the avatarKey represent the url to the img
  avatarCodeKey: string, //? the avatarCodeKey should be the key representing the avatar id if the provider doesnt give the avatar url directly, we use the getAvatar function with this value together
  getAvatar?: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => any
}

type oauthProvidersProps = | BasicProvider | (Required<FullProvider>); 

// const backendUrl = `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`;
const prod = process.env.NODE_ENV !== 'development';
const backendUrl = process.env.NODE_ENV == 'development' 
  ? `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`
  : process.env.DNS
  
const oauthProviders: oauthProvidersProps[] = [
  {
    name: 'credentials',
  },
  {
    name: 'google',
    clientID: prod ?  process.env.GOOGLE_CLIENT_ID : process.env.DEV_GOOGLE_CLIENT_ID,
    clientSecret: prod ?  process.env.GOOGLE_CLIENT_SECRET : process.env.DEV_GOOGLE_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/google`,
    authorizationURL: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenExchangeURL: 'https://oauth2.googleapis.com/token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://www.googleapis.com/oauth2/v1/userinfo',
    scope: [
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/userinfo.email"
    ],
    nameKey: 'name',
    emailKey: 'email',
    avatarKey: 'picture'
  },
  {
    name: 'github',
    clientID: prod ?  process.env.GITHUB_CLIENT_ID : process.env.DEV_GITHUB_CLIENT_ID,
    clientSecret: prod ?  process.env.GITHUB_CLIENT_SECRET : process.env.DEV_GITHUB_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/github`,
    authorizationURL: 'https://github.com/login/oauth/authorize',
    tokenExchangeURL: 'https://github.com/login/oauth/access_token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://api.github.com/user',
    scope: ['read:user', 'user:email'],
    nameKey: 'login',
    emailKey: 'email',
    avatarKey: 'avatar_url',
    getEmail: async (access_token: string) => {
      const getEmail = async () => {
        const url = 'https://api.github.com/user/emails';
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${access_token}`
          },
        })
        return await response.json(); 
      }
  
      const [getEmailError, getEmailResponse] = await tryCatch(getEmail);
      if (getEmailError) {
        console.log(getEmailError);
        return false;
      }
  
      //? if we found the email we set it to the user object
      let mainEmail: string | undefined;
      for (const email of getEmailResponse) {
        if (email.primary) { mainEmail = email.email; }
      }
      if (!mainEmail) { mainEmail = getEmailResponse?.[0]?.email; }
      return mainEmail;
    },
  },
  {
    name: 'discord',
    clientID: prod ?  process.env.DISCORD_CLIENT_ID : process.env.DEV_DISCORD_CLIENT_ID,
    clientSecret: prod ?  process.env.DISCORD_CLIENT_SECRET : process.env.DEV_DISCORD_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/discord`,
    authorizationURL: 'https://discord.com/oauth2/authorize',
    tokenExchangeURL: 'https://discord.com/api/oauth2/token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://discord.com/api/users/@me',
    scope: [
      "identify",
      'email',
    ],
    nameKey: 'username',
    emailKey: 'email',
    avatarCodeKey: 'avatar',
    getAvatar: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => {
      if (!avatarId) {
        // Default avatar (based on discriminator % 5)
        // const defaultAvatarIndex = userId % 5;
        // return `https://cdn.discordapp.com/embed/avatars/${defaultAvatarIndex}.png`;
        return undefined;
      }
      const userId = userData.id;
      const format = avatarId.startsWith("a_") ? "gif" : "png";
      return `https://cdn.discordapp.com/avatars/${userId}/${avatarId}.${format}`;
    }
  },
  {
    name: 'facebook',
    clientID: prod ?  process.env.FACEBOOK_CLIENT_ID : process.env.DEV_FACEBOOK_CLIENT_ID,
    clientSecret: prod ?  process.env.FACEBOOK_CLIENT_SECRET : process.env.DEV_FACEBOOK_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/facebook`,
    authorizationURL: 'https://www.facebook.com/v10.0/dialog/oauth',
    tokenExchangeURL: 'https://graph.facebook.com/v10.0/oauth/access_token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://graph.facebook.com/me?fields=id,name,email,picture.type(large)',
    scope: ['public_profile', 'email'],
    nameKey: 'name',
    emailKey: 'email',
    getAvatar: ({userData}: {userData: Record<string, any>}) => {
      return userData?.picture?.data?.url || undefined;
    }
  },
];

export default oauthProviders;
</file>

<file path="server/dev/hotReload.ts">
import chokidar from "chokidar";
import { initializeApis, initializeFunctions, initializeSyncs } from "./loader";

// ----------------------------
// Watcher for Hot Reload
// ----------------------------
export const setupWatchers = () => {
  if (process.env.NODE_ENV !== "development") return;

  const handleChange = (path: string) => {
    const normalizedPath = path.replace(/\\/g, '/');

    if (normalizedPath.includes('api/')) {
      console.log(`[Watcher] Reloading API due to change in: ${normalizedPath}`);
      initializeApis();
    } else if (normalizedPath.includes('sync/')) {
      console.log(`[Watcher] Reloading Sync due to change in: ${normalizedPath}`);
      initializeSyncs();
    }
  };

  const handleFunctionChange = (path: string) => {
    console.log(`[Watcher] Reloading Function due to change in: ${path.replace(/\\/g, '/')}`);
    initializeFunctions();
  };

  // Watch the main source folders
  chokidar.watch('src', { ignoreInitial: true })
    .on('add', handleChange)
    .on('change', handleChange);

  // Watch functions separately
  chokidar.watch('server/functions', { ignoreInitial: true })
    .on('add', handleFunctionChange)
    .on('change', handleFunctionChange);
};
</file>

<file path="server/dev/loader.ts">
import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";
import { tryCatch } from "../functions/tryCatch";

// ----------------------------
// Storage for loaded modules
// ----------------------------
export const devApis: Record<string, any> = {};
export const devSyncs: Record<string, any> = {};
export const devFunctions: Record<string, any> = {};

// ----------------------------
// Unified Initialization
// ----------------------------
export const initializeAll = async () => {
  await Promise.all([initializeApis(), initializeSyncs(), initializeFunctions()]);
  console.log(devApis)
  console.log(devSyncs)
  console.log("DEV modules initialized.");
  // console.log(devFunctions)
};

// ----------------------------
// Helper: convert absolute path to proper file URL for import
// ----------------------------
const importFile = async (absolutePath: string) => {
  const url = pathToFileURL(absolutePath).href;
  return import(`${url}?update=${Date.now()}`);
};

// ----------------------------
// API Loader
// ----------------------------
export const initializeApis = async () => {
  Object.keys(devApis).forEach(k => delete devApis[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanApiFolder(file);
  }
};

const scanApiFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("api")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith(".ts")) continue;

      const modulePath = path.join(fullPath, f);
      const [err, module] = await tryCatch(async () => importFile(modulePath));
      if (err) continue;

      const { auth = {}, main } = module;
      if (!main || typeof main !== "function") continue;

      // const pageLocation = modulePath.split(`/${file}/`)[0].replace(/^src[\/\\]/, "");
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split("/api")[0];

      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      devApis[`api/${pageLocation}/${f.replace(".ts", "")}`] = {
        main,
        auth: {
          login: auth.login || false,
          additional: auth.additional || [],
        },
      };
    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanApiFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Sync Loader
// ----------------------------
export const initializeSyncs = async () => {
  Object.keys(devSyncs).forEach(k => delete devSyncs[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanSyncFolder(file);
  }
};

const scanSyncFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("sync")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith("_client.ts") && !f.endsWith("_server.ts")) { continue; }

      const filePath = path.join(fullPath, f);
      const [fileError, fileResult] = await tryCatch(async () => importFile(filePath));

      if (fileError) { continue; }

      // build the route key similar to API routes
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split('/sync')[0];

      // remove last segment
      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      if (f.endsWith("_server.ts")) {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = { 
          main: fileResult.main, 
          auth: fileResult.auth || {} 
        };
      } else {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = fileResult.main;
      }

      // // optional _server.ts
      // const serverFile = f.replace("_client.ts", "_server.ts");
      // const serverPath = path.join(fullPath, serverFile);

      // if (fs.existsSync(serverPath)) {
      //   const [errServer, serverModule] = await tryCatch(async () => importFile(serverPath));
      //   if (!errServer && typeof serverModule.main === "function") {
      //     // final key style: sync/games/boerZoektVrouw/getCards
      //     devSyncs[`sync/${pageLocation}/${f.replace("_client.ts", "_server")}`] = { main: serverModule.main, auth: serverModule.auth || {} };
      //   }
      // }


    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanSyncFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Functions Loader
// ----------------------------
export const initializeFunctions = async () => {
  Object.keys(devFunctions).forEach(k => delete devFunctions[k]);
  const functionsFolder = fs.readdirSync(path.resolve("./server/functions"));

  for (const file of functionsFolder) {
    const filePath = path.join("./server/functions", file);
    if (!fs.statSync(filePath).isFile() || !file.endsWith(".ts")) continue;

    const [err, module] = await tryCatch(async () => importFile(filePath));
    if (err) continue;


    Object.assign(devFunctions, module);
  }
};
</file>

<file path="server/dev/request.py">
import requests

url = "http://192.168.178.68:80"
data = {"name": "mike", "age": 18}

response = requests.get(url, json=data)

print("Status Code:", response.status_code)
print("Response:", response.text)
</file>

<file path="server/functions/boardcaster.ts">
import { ioInstance } from "../../server/sockets/socket"
import { getSession } from "./session";

export default async function boardcaster({
  code,
  event,
  session,
  data,
  ignoreSelf
}: {
  code: string,
  event: string,
  session?: boolean,
  data?: any,
  ignoreSelf?: string
}) {
  const io = ioInstance;
  if (!io) { return; }

  const sockets = io.sockets.adapter.rooms.get(code);
  if (!sockets) { return; }

  
  for (const socketId of sockets || []) {
    const tempSocket = io.sockets.sockets.get(socketId as string);
    if (!tempSocket) { continue; }

    if (ignoreSelf || session) {
      
      const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
      const tempSessionToken = tempSocket.handshake.auth?.token
      const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
        : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
        : null; 

      if (ignoreSelf == tempToken) { 
        console.log(' skipping self emit ');
        continue; 
      } //? we dont send the event to the client who called the event


      if (!tempToken) { continue; }
      const sessionData = await getSession(tempToken);

      tempSocket.emit(event, { ...data, session: sessionData });

    } else {
      tempSocket.emit(event, { ...data });
    }
  }
  
}
</file>

<file path="server/functions/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="server/functions/game.ts">
import redis from "./redis";

export interface GameDataProps {
  players: { 
    id: string, 
    name: string, 
    avatar: string,
    role: 'farmer' | 'queen' | 'manipulator' | null,
    selected?: boolean
  }[],
  gameCode: string,
  queenRoles: number,
  manipulatorRoles: number,
  currentCountdownId: number,
  state: 'lobby' | 'loadingScreen' | 'started' | 'finished',
  loadingScreenState: 'roulette' | 'focusFarmer' | 'focusPersonalCard' | null;
  selectedRewards: { [key: string]: string[] },
  availableRewards: {
    name: string,
    id: string
  }[],
  lives: number,
  maxLives: number,
  gameStartTime: number | null,
  totalDrinkTime: number,
  won: 'farmer' | 'player' | 'none' | false,
  revealed: { 
    id: string, 
    role: 'queen' | 'manipulator'
  }[],
}


const saveGameData = async (gameCode: string, data: GameDataProps) => {
  // console.log(gameCode)
  // console.log(data)
  await redis.set(`${process.env.PROJECT_NAME}-games:${gameCode}`, JSON.stringify(data));
  await redis.expire(`${process.env.PROJECT_NAME}-games:${gameCode}`, 60 * 60 * 24 * 7); // same TTL as session or adjust
  return true;
};

const getGameData = async (gameCode: string) => {
  const data = await redis.get(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return data ? JSON.parse(data) as GameDataProps : null;
};

const getAllGameDatas = async () => {
  const allGameDatas = await redis.keys("*");
  const GameDatas = await Promise.all(allGameDatas.map((gameData) => redis.get(gameData)));
  return GameDatas.map((gameData) => JSON.parse(gameData || "{}")); 
}


const deleteGameData = async (gameCode: string) => {
  await redis.del(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return true;
};

const gameExists = async (gameCode: string): Promise<boolean> => {
  const exists = await redis.exists(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return exists === 1;
};

export { saveGameData, getGameData, getAllGameDatas, deleteGameData, gameExists  };
</file>

<file path="server/functions/redis.ts">
import Redis from 'ioredis';
import dotenv from 'dotenv';

dotenv.config(); 

//? here we create a Redis instance
const redis = new Redis({
  host: process.env.REDIS_HOST as string,
  port: parseInt(process.env.REDIS_PORT as string),
});

redis.on('connect', async () => {
  console.log('Connected to Redis');

  if (process.env.NODE_ENV == 'development') { return; }

  const prefix = `${process.env.PROJECT_NAME}-games:`;
  await clearKeysWithPrefix(prefix);
});

redis.on('error', (err) => {
  console.error('Error connecting to Redis:', err);
});

async function clearKeysWithPrefix(prefix: string) {
  let cursor = '0';
  do {
    const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', `${prefix}*`, 'COUNT', 100);
    cursor = nextCursor;
    if (keys.length > 0) {
      // delete keys in bulk
      await redis.del(...keys);
      console.log(`Deleted Redis keys: ${keys.join(', ')}`);
    }
  } while (cursor !== '0');
}

export default redis;
</file>

<file path="server/functions/session.ts">
import type { SessionLayout } from "config";
import redis from "./redis";
// import { logout } from "../sockets/utils/logout";

const saveSession = async (token: string, data: SessionLayout, newUser?: boolean) => {
  await redis.set(`${process.env.PROJECT_NAME}-session:${token}`, JSON.stringify(data));
  await redis.expire(`${process.env.PROJECT_NAME}-session:${token}`, 60 * 60 * 24 * 7); //? 7 days

  const { ioInstance } = await import('../sockets/socket');

  const io = ioInstance;
  if (!io) { return false; } //? if this fails we are fucked but it should never fail

  if (newUser) { //? new user is true when someone logs in
    const userId = data?.id;
    if (!userId) return;

    const tokensOfPreviousUsersKey = `${process.env.PROJECT_NAME}-activeUsers:${userId}`
    const tokensOfPreviousUsers = await redis.smembers(tokensOfPreviousUsersKey);

    const { logout } = await import('../sockets/utils/logout');

    await Promise.all(tokensOfPreviousUsers.map(async (tokenOfPreviousUser) => {
      const sockets = io.sockets.adapter.rooms.get(tokenOfPreviousUser); // Set of socket IDs
      if (sockets) { //? if we found a client it means the user is still connected
        console.log('remving old session data from sockets', 'green')
        for (const socketId of sockets) {
          const socket = io.sockets.sockets.get(socketId);
          if (socket) {
            await logout({ token: tokenOfPreviousUser, socket, userId });
          }
        }
      } else {
        //? if we didnt find any clients it means the user is not connected, we can just delete there session data
        await redis.del(`${process.env.PROJECT_NAME}-session:${tokenOfPreviousUser}`);
        await redis.srem(tokensOfPreviousUsersKey, tokenOfPreviousUser);
      }
    }));

    await redis.sadd(tokensOfPreviousUsersKey, token);
    await redis.expire(tokensOfPreviousUsersKey, 60 * 60 * 24 * 7); //? 7 days
  }

  if (io.sockets.adapter.rooms.has(token)) {
    io.to(token).emit('updateSession', JSON.stringify(data));
  }
};

const getSession = async (token: string | null) => {
  if (!token) return {};
  const session = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);
  if (!session) { return {} };
  const formattedSession = JSON.parse(session);
  if (!formattedSession) { return {} };
  return {...formattedSession, token: token};
};

const deleteSession = async (token: string) => {
  const user = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);

  if (user) {
    const userId = JSON.parse(user)?.id;
    if (userId) {
      const tokensOfPreviousUsers = `${process.env.PROJECT_NAME}-activeUsers:${userId}`;
      const { ioInstance } = await import('../sockets/socket');
      // ioInstance?.to(token).emit('forceLogout');
      if (ioInstance?.sockets.adapter.rooms.has(token)) {
        ioInstance.to(token).emit('forceLogout');
      }

      await redis.srem(tokensOfPreviousUsers, token);
    }
  }

  await redis.del(`${process.env.PROJECT_NAME}-session:${token}`);
  return true;
};

const getAllSessions = async () => {
  const sessions = await redis.keys(`${process.env.PROJECT_NAME}-session:*`);
  const sessionData = await Promise.all(sessions.map((session) => redis.get(session)));
  return sessionData.map((session) => JSON.parse(session || "{}")); 
}

// const clearAllSessions = async () => {
//   const sessions = await redis.keys("*");
//   await Promise.all(sessions.map((session) => redis.del(session)));
//   return true; 
// }

export { saveSession, getSession, deleteSession, getAllSessions };
</file>

<file path="server/functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="server/functions/tryCatch.ts">
const tryCatch = async <T, P>(func: (values: P) => Promise<T> | T, params?: P): Promise<[any, T | null]> => {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error) {
    return [error, null];
  }
}

export { tryCatch }
</file>

<file path="server/prod/generatedApis.ts">
export const apis: Record<string, { auth: any, main: any }> = { };

export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };

export const functions: Record<string, any> = { };
</file>

<file path="server/prod/serveFile.ts">
import fs from "fs";
import { IncomingMessage, ServerResponse } from "http";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootFolder = path.join(__dirname, '../dist');

export const serveFavicon = (res: ServerResponse) => {
  //? here we get the favicon.ico file from the public folder and serve it to the client
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const faviconPath = path.join(__dirname, '../public', 'favicon.ico');
  res.writeHead(200, { 'Content-Type': 'image/x-icon' });
  fs.createReadStream(faviconPath).pipe(res); 
}

export const serveFile = async (req: IncomingMessage | { url: string }, res: ServerResponse) => {

  //? if request is / (root) we serve the index.html 
  const url = !req.url ? 'index.html' : req.url == '/' ? 'index.html' : req.url;
  const safePath = path.normalize(decodeURIComponent(url)).replace(/^(\.\.[\/\\])+/, '');
  let filePath = path.join(rootFolder, safePath);

  console.log(filePath)
  console.log(rootFolder)

  if (!filePath.startsWith(rootFolder)) {
    //! here we avoid directory traversal attacks
    res.writeHead(403, { "Content-Type": "text/plain" });
    return res.end("Forbidden");
  }

  //? here we check if the file extension or just the filename is in the list of files we dont want to serve
  //? a file that is in the list below should not be able to run this function in the first place cause we filter the routePath using zod before calling this function
  //? but if it passes somehow, we avoid it being served
  if (filePath.includes('.env') || 
      filePath.includes('.ts') || 
      filePath.includes('.tsx') || 
      filePath.includes('.py') || 
      filePath.includes('package.json') || 
      filePath.includes('package-lock.json') || 
      filePath.includes('.gitignore') || 
      filePath.includes('eslint.config.js') || 
      filePath.includes('postcss.config.mjs') || 
      filePath.includes('README.md') || 
      filePath.includes('redis.conf') || 
      filePath.includes('tailwind.config.js') || 
      filePath.includes('tsconfig.app.json') || 
      filePath.includes('tsconfig.json') || 
      filePath.includes('tsconfig.node.json') || 
      filePath.includes('vite.config.ts') || 
      filePath.includes('schema.prisma')
  ) {
    return res.end("Forbidden");
  }
  

  const extname = path.extname(filePath);
  let contentType = 'text/html';

  //? here we get the content type of the file and serve it to the client
  //? if the file extension is not in the list below, we serve the index.html file
  switch (extname) {
    case '.css': contentType = 'text/css'; break;
    case '.js': contentType = 'text/javascript'; break;
    case '.json': contentType = 'application/json'; break;
    case '.png': contentType = 'image/png'; break;
    case '.jpg':
    case '.jpeg': contentType = 'image/jpeg'; break;
    case '.gif': contentType = 'image/gif'; break;
    case '.svg': contentType = 'image/svg+xml'; break;
    case '.ico': contentType = 'image/x-icon'; break;
    default:
      contentType = 'text/html';
      filePath = path.join(rootFolder, 'index.html');
  }

  try {
    //? attempt to read the file and serve it to the client
    const content = await fs.promises.readFile(filePath);
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(content);
  } catch (err) {
    if (url == 'index.html') {
      res.end("-_- you have to run the 'npm run build' command first -_-")
    } else {
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("Not Found");
    }
  }
};
</file>

<file path="server/server.ts">
import dotenv from 'dotenv';
dotenv.config();
import http from 'http';
import getParams from './utils/getParams';
import { loginWithCredentials, loginCallback } from './auth/login';
import { serveFavicon, serveFile } from './prod/serveFile';
import loadSocket from './sockets/socket';
import z from 'zod';
import oauthProviders from "./auth/loginConfig";
import { deleteSession } from './functions/session';
import allowedOrigin from './auth/checkOrigin';
import { SessionLayout } from '../config';
import { initializeAll } from './dev/loader';
import { setupWatchers } from './dev/hotReload';
import { initConsolelog } from './utils/console.log';
import { initRepl } from './utils/repl';
import { serveAvatar } from './utils/serveAvatars';

const ServerRequest = async (req: http.IncomingMessage, res: http.ServerResponse) => {

  const origin = req.headers.origin || req.headers.referer || req.headers.host || '';

  if (!allowedOrigin(origin)) {
    res.statusCode = 403;
    res.setHeader('Content-Type', 'text/plain');
    return res.end('Forbidden');
  }
  
  res.setHeader("Access-Control-Allow-Origin", origin);
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader('Referrer-Policy', 'no-referrer'); // prevents the browser from leaking sensative urls
  res.setHeader('X-Frame-Options', 'SAMEORIGIN'); // only allows iframes to use this pages content if on the same domain
  res.setHeader('X-XSS-Protection', '1; mode=block'); // prevents some xss attacks
  res.setHeader('X-Content-Type-Options', 'nosniff'); // prevents mimetype sniffing, this means that when sending a txt file it will not try to execute it as ddl if the user requested this

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    return res.end();
  }

  const method = req.method;
  const url = req.url || '/';
  const [routePath, queryString] = url.split('?');

  if (method !== 'GET' && method != 'POST' && method != 'PUT' && method != 'DELETE') {
    res.statusCode = 404;
    res.setHeader('Content-Type', 'text/plain');
    return res.end(`method: ${method} not supported, use one of the following methods: GET, POST, PUT, DELETE`);
  }

  const cookieHeader = req.headers.cookie || '';
  const token = cookieHeader
    .split('; ')
    .find(row => row.startsWith('token='))
    ?.split('=')[1];


  //? here we load the application icon
  if (z.literal('/favicon.ico').safeParse(routePath).success) {
    return serveFavicon(res);
  }

  //? here we get the params from the request
  let params: object | null;
  params = await getParams({ method, req, res, queryString });

  //? we log the request and if there are any params we log them with the request
  if (params && typeof params == 'object' && Object.keys(params).length !== 0) { 
    console.log(`method: ${method}, url: ${routePath}, params: ${JSON.stringify(params)}`, 'magenta') 
  } else { 
    console.log(`method: ${method}, url: ${routePath}`, 'magenta'); 
    params = {}; 
  }

  //? we dont use zod cause it doesnt allow you to pass in a id in the url
  // if (z.literal('/uploads/').safeParse(routePath).success) {
  if (routePath.startsWith('/uploads/')) {
    await serveAvatar({ routePath, res });
    return;
  }
    
  //? triggers when logging in
  //? when using the credentials provider all the logic happends here else we redirect to the oauth provider and all the logic happends in the auth/callback api
  if (z.string().startsWith('/auth/api').safeParse(routePath).success) {
    const providerName = routePath.split('/')[3]; // Extract the provider (google/github)
    const provider = oauthProviders.find(p => p.name === providerName);
    if (!provider || !provider.name) { return { provider, status: false, reason: 'login.providerNotFound' }; }

    if (provider?.name != 'credentials' && 'scope' in provider) {
      res.writeHead(302, {
        'Location': `${provider.authorizationURL}?client_id=${provider.clientID}&redirect_uri=${provider.callbackURL}&scope=${provider.scope.join('%20')}&response_type=code&prompt=select_account`,
      });
      return res.end(); 
    }

    //? here all the logic happends for login or creating an account with credentials
    const { status, reason, newToken, session } = await loginWithCredentials(params) as {
      status: boolean,
      reason: string,
      newToken: string | null,
      session: SessionLayout | undefined
    }

    //? if it failed to either login or creating an account then we return
    if (!status) {
      res.setHeader("content-type", "application/json; charset=utf-8");
      return res.end(JSON.stringify({ status, reason: reason || 'internal server error' }));
    }

    //? if it was successful then we apply the cookie and return the user id and reason for the login or account creation
    if (newToken) { 
      if (token) { await deleteSession(token); }

      console.log('setting cookie with newToken: ', newToken, 'green');
      // const cookieOptions = process.env.NODE_ENV == "development" ? 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800;": 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; Secure;";
      const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`

      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      // return res.end(JSON.stringify({ status, reason, session })) 
    // } else { 
    }
    return res.end(JSON.stringify({ status, reason, session, newToken })) 

  } else if (z.string().startsWith('/auth/callback').safeParse(routePath).success) {
    //? this endpoint is triggerd by the oauth provider after the user has logged in
    const newToken = await loginCallback(routePath, req, res);

    //? if it failed to either login or creating an account then we return
    if (!newToken) {
      res.writeHead(401, { "Content-Type": "text/plain" });
      return res.end('Login failed');
    }

    //? we successfully logged in or created an acocunt

    //? if the user already had a token then we delete the previous session data
    if (token) { await deleteSession(token); }

    //? we set the cookie with the new token and redirect the user to the frontend
    console.log('setting cookie with newToken: ', newToken, 'green');
    const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`
      
    const location = process.env.DNS

    if (process.env.VITE_SESSION_BASED_TOKEN == 'true') {
      res.writeHead(302, {
        Location: `${process.env.DNS}?token=${newToken}`,
      });
    } else {
      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      res.writeHead(302, { Location: location }); // Redirect without exposing token in URL
    }
    return res.end();

  } else if (routePath.includes("/assets/")) {
    const assetPath = routePath.slice(routePath.indexOf("/assets/"));
    req.url = assetPath;
    return serveFile(req, res);

  } else if (z.string()
    .regex(/^\/(assets\/[a-zA-Z0-9_\-/]+|[a-zA-Z0-9_\-]+)\.(png|jpg|jpeg|gif|svg|html|css|js)$/)
    .safeParse(routePath).success) {
    //? if the request is a file with one of the following extensions then we serve it
    //? png|jpg|jpeg|gif|svg|html|css|js
    return serveFile(req, res); 

  } else { // for the index.html
    //? if the request doesnt fit any of the above then we serve the index.html file
    return serveFile({url: '/'}, res);
  }
}

const ip: string = process.env.SERVER_IP || '127.0.0.1';
const port: string = process.env.SERVER_PORT || '80';

(async () => {
  if (process.env.NODE_ENV == 'development') {
    initConsolelog();
    await initializeAll();
    setupWatchers();
    initRepl();
  }

  const httpServer = http.createServer(async(req, res) => { ServerRequest(req, res) });
  loadSocket(httpServer);
  // @ts-ignore // typescript thinks ip needs to be a number
  httpServer.listen(port, ip, () => {
    console.log(`Server is running on http://${ip}:${port}/`, 'green'); 
  });
  
  
})()
</file>

<file path="server/sockets/handleApiRequest.ts">
import { tryCatch } from '../functions/tryCatch';
import { apis, functions } from '../prod/generatedApis'
import { devApis, devFunctions } from "../dev/loader"
import { apiMessage } from './socket';
import { getSession } from '../functions/session';
import type { SessionLayout } from '../../config';
import { Socket } from 'socket.io';
import { logout } from './utils/logout';

type handleApiRequestType = {
  msg: apiMessage,
  socket: Socket,
  token: string | null,
}

const isFalsy = (value: any) => {
  return (
    value === false ||
    value === 0 ||
    value === 0n ||
    value === '' ||
    value === null ||
    value === undefined ||
    (typeof value === 'number' && isNaN(value))
  );
}

const validateRequest = ({ auth, user }: {
  auth: {
    login: boolean;
    additional?: {
      key: string;
      type?: 'string' | 'number' | 'boolean' | 'object' | 'function' | 'undefined';
      value?: any;
      mustBeFalsy?: boolean;
      nullish?: boolean;
    }[]
  }, 
  user: SessionLayout
}) => {

  //? if the additional key is an array we check if the following
  //? if it has a key and a type we check if the user has the key and if the value is of the correct type
  //? if it has a key and a value we check if the user has the key and if the value is the same as the given value
  //? examples:
  //? { key: 'admin', type: 'boolean' } -> checks if the user has the key admin and if the value is of type boolean
  //? { key: 'admin', value: true } -> checks if the user has the key admin and if the value is true   

  if (auth.additional) {
    for (const condition of auth.additional) {
      if (!condition.key) { 
        return {
          status: "error",
          message: `Missing key in auth.additional condition`,
        };
      }

      if (!(condition.key in user)) {
        return { status: "error", message: `Key ${condition.key} not found in user session` };
      }

      const val = user?.[condition.key as keyof SessionLayout];

      //? If nullish flag is set, check accordingly
      if (typeof condition.nullish === 'boolean') {
        const isNullish = val === null || val === undefined;
        if (condition.nullish && !isNullish) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be null or undefined`,
          };
        }
        if (!condition.nullish && isNullish) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be not null and not undefined`,
          };
        }
      }

      //? Check type if specified (skip null or undefined values)
      if (condition.type && val != null) {
        if (typeof val !== condition.type) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be of type ${condition.type}`,
          };
        }
      }

      //? Check exact value if specified (strict equality)
      if ('value' in condition) {
        if (val !== condition.value) {
          return {
            status: "error",
            message: `Expected ${condition.key} to equal ${JSON.stringify(condition.value)}`,
          };
        }
      }

      //? Check truthy/falsy if specified
      if (typeof condition.mustBeFalsy === 'boolean') {
        if (condition.mustBeFalsy && !isFalsy(val)) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be falsy`,
          };
        }
        if (!condition.mustBeFalsy && isFalsy(val)) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be truthy`,
          };
        }
      }
    }
  
  }
  return {
    status: "success"
  }
}

// export default async function handleApiRequest({ name, data, user }: handleApiRequestType) {
export default async function handleApiRequest({ msg, socket, token }: handleApiRequestType) {
  // console.log(msg)
  //? this event gets triggerd when the client uses the apiRequest function from serverRequest.ts
  //? we check if the msg contains a name and check if there is a api that exist with this name
  if (typeof msg != 'object' ) {
    console.log('socket message was not a json object!!!!', 'red')
    console.log('socket message was not a json object!!!!', 'red')
    console.log('socket message was not a json object!!!!', 'red')
    return;
  }

  const { name, data, responseIndex } = msg;
  const user = await getSession(token)

  if (!responseIndex && typeof responseIndex !== 'number') {
    console.log('no response index given!!!!', 'red')
    console.log('no response index given!!!!', 'red')
    console.log('no response index given!!!!', 'red')
    return;
  }

  //? if the name of the apiRequest is 'session' we return the users session data else we check if there is an api with this name
  if (name == 'session') {
    return socket.emit(`apiResponse-${responseIndex}`, { result: user });
  }

  if (name == 'logout') {
    await logout({ token, socket, userId: user?.id || null });
    return socket.emit(`apiResponse-${responseIndex}`, { result: true });
  }

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return socket.emit(`apiResponse-${responseIndex}`, { status: "error" , message: `socket message was incomplete, needs a name ${name} and data: ${JSON.stringify(data)}` });
  }

  console.log(' ', 'blue')
  console.log(' ', 'blue')
  console.log(`api: ${name} called`, 'blue');

  const apisObject = process.env.NODE_ENV == 'development'? devApis : apis;

  //? check if there exist a function with the given name
  if (!apisObject[name]) { return socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'api not found' }); }

  const { auth, main } = apisObject[name];

  //? if the login key is true we check if the user has an id in the session object
  if (auth.login) { 
    if (!user?.id) { 
      console.log(`ERROR!!!, not logged in but api call requires login`, 'red');
      return socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'not logged in but api call requires login' }); 
    }
  }

  const notValid = validateRequest({ auth, user: user as SessionLayout });
  if (!notValid || notValid?.status === "error") { return socket.emit(`apiResponse-${responseIndex}`, notValid); }

  //? All checks passed so we call the api function and return the result
  const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;
  const [error, result] = await tryCatch(async () => await main({ data, user, functions: functionsObject }));
  if (error) { 
    console.log(error, 'red'); 
    socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: error });
  } else if (result) { 
    console.log(result, 'blue');
    socket.emit(`apiResponse-${responseIndex}`, { status: "success", result });
  } else {
    console.log('api didnt return anything', 'red');
    socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'api didnt return anything' });
  }
}
</file>

<file path="server/sockets/handleSyncRequest.ts">
import { tryCatch } from "../functions/tryCatch";
import { devSyncs, devFunctions } from "../dev/loader"
import { syncs, functions } from '../prod/generatedApis'
import { ioInstance, syncMessage } from "./socket";
import { Socket } from "socket.io";
import { getSession } from "../functions/session";
import { SessionLayout } from "config";

const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;

const isFalsy = (value: any) => {
  return (
    value === false ||
    value === 0 ||
    value === 0n ||
    value === '' ||
    value === null ||
    value === undefined ||
    (typeof value === 'number' && isNaN(value))
  );
}

const validateRequest = ({ auth, user }: {
  auth: {
    login: boolean;
    additional?: {
      key: string;
      type?: 'string' | 'number' | 'boolean' | 'object' | 'function' | 'undefined';
      value?: any;
      mustBeFalsy?: boolean;
      nullish?: boolean;
    }[]
  }, 
  user: SessionLayout
}) => {

  //? if the additional key is an array we check if the following
  //? if it has a key and a type we check if the user has the key and if the value is of the correct type
  //? if it has a key and a value we check if the user has the key and if the value is the same as the given value
  //? examples:
  //? { key: 'admin', type: 'boolean' } -> checks if the user has the key admin and if the value is of type boolean
  //? { key: 'admin', value: true } -> checks if the user has the key admin and if the value is true   

  if (auth.additional) {
    for (const condition of auth.additional) {

      if (!condition.key) { 
        return {
          error: true,
          message: `Missing key in auth.additional condition`,
        };
      }

      if (!(condition.key in user)) {
        return { status: "error", message: `Key ${condition.key} not found in user session` };
      }

      const val = user?.[condition.key as keyof SessionLayout];

      //? If nullish flag is set, check accordingly
      if (typeof condition.nullish === 'boolean') {
        const isNullish = val === null || val === undefined;
        if (condition.nullish && !isNullish) {
          return {
            error: true,
            message: `Expected ${condition.key} to be null or undefined`,
          };
        }
        if (!condition.nullish && isNullish) {
          return {
            error: true,
            message: `Expected ${condition.key} to be not null and not undefined`,
          };
        }
      }

      //? Check type if specified (skip null or undefined values)
      if (condition.type && val != null) {
        if (typeof val !== condition.type) {
          return {
            error: true,
            message: `Expected ${condition.key} to be of type ${condition.type}`,
          };
        }
      }

      //? Check exact value if specified (strict equality)
      if ('value' in condition) {
        if (val !== condition.value) {
          return {
            error: true,
            message: `Expected ${condition.key} to equal ${JSON.stringify(condition.value)}`,
          };
        }
      }

      //? Check truthy/falsy if specified
      if (typeof condition.mustBeFalsy === 'boolean') {
        if (condition.mustBeFalsy && !isFalsy(val)) {
          return {
            error: true,
            message: `Expected ${condition.key} to be falsy`,
          };
        }
        if (!condition.mustBeFalsy && isFalsy(val)) {
          return {
            error: true,
            message: `Expected ${condition.key} to be truthy`,
          };
        }
      }
    }
  
  }
}


// export default async function handleSyncRequest({ name, clientData, user, serverData, roomCode }: syncMessage) {
export default async function handleSyncRequest({ msg, socket, token }: {
  msg: syncMessage,
  socket: Socket,
  token: string | null,
}) {

  if (!ioInstance) { return; }
  
  //? first we validate the data
  if (typeof msg!= 'object' ) {
    console.log('message','socket message was not a json object', 'red')
    return socket.emit('sync','socket message was not a json object');
  }

  const { name, data, cb, receiver, responseIndex, ignoreSelf } = msg;

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, syncName: ${name}, syncData: ${JSON.stringify(data)}` })
  }

  if (!cb || typeof cb != 'string') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, cb: ${cb}` });
  }
  
  if (!receiver) {
    console.log('receiver / roomCode: ', receiver, 'red')
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, needs a receiver / roomCode: ${receiver}` });
  }

  console.log(' ', 'blue')
  console.log(' ', 'blue')
  console.log(`sync: ${name} called`, 'blue');

  const user = await getSession(token);
  const syncObject = process.env.NODE_ENV == 'development' ? devSyncs : syncs;

  console.log(syncObject)
  //? we check if there is a client file or/and a server file, if they both dont exist we abort
  if (!syncObject[`${name}_client`] && !syncObject[`${name}_server`]) { 
    console.log("ERROR!!!, ", `you need ${name}_client or ${name}_server file to sync`, 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `you need ${name}_client or ${name}_server file to sync` });
  }

  let serverData = {};
  if (syncObject[`${name}_server`]) {
    const { auth, main: serverMain } = syncObject[`${name}_server`];

    //? if the login key is true we check if the user has an id in the session object
    if (auth.login) { 
      if (!user?.id) { 
        console.log(`ERROR!!!, not logged in but sync requires login`, 'red');
        return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: 'not logged in but sync requires login' }); 
      }
    }

    const notValid = validateRequest({ auth, user: user as SessionLayout });
    if (notValid) { 
      console.log('ERROR!!!, ', notValid.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, notValid); 
    }

    //? if the user has passed all the checks we call the preload sync function and return the result
    const [serverSyncError, serverSyncResult] = await tryCatch(async () => await serverMain({ clientData: data, user, functions: functionsObject, roomCode: receiver }));
    if (serverSyncError) {
      console.log('ERROR!!!, ', serverSyncError.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncError.message });
    } else if (serverSyncResult?.status == 'error') {
      console.log('ERROR!!!, ', serverSyncResult.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncResult.message });
    } else if (serverSyncResult?.status !== 'success') {
      //? badReturn means it doesnt include a status key with the value 'success' || 'error'
      console.log('ERROR!!!, ', `sync ${name}_server function didnt return a status key with the value 'success' or 'error'`, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `sync ${name}_server function didnt return a status key with the value 'success' or 'error'` });
    } else if (serverSyncResult?.status == 'success') {
      serverData = serverSyncResult;
    }
  }

  //? from here on we can assume that we have either called a server sync and got a proper result of we didnt call a server sync

  //? get the desired sockets based on the receiver key
  const sockets = receiver === 'all'
    ? ioInstance.sockets.sockets //? all connected sockets (Map)
    : ioInstance.sockets.adapter.rooms.get(receiver) //? Set of socket IDs in room

  //? now we check if we found any sockets
  if (!sockets) { 
    console.log('data: ', msg, 'red');
    console.log('receiver: ', receiver, 'red');
    console.log('no sockets found', 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `no sockets found for receiver / roomCode: ${receiver}` });
  }

  //? here we loop over all the connected clients
  //? we keep track of an counter and await the loop every 100 iterations to avoid the server running out of memory and crashing
  let tempCount = 1;
  for (const socketEntry of sockets) {
    tempCount++;
    if (tempCount % 100 == 0) { await new Promise(resolve => setTimeout(resolve, 1)); }

    const tempSocket = receiver === 'all'
      ? (socketEntry as [string, Socket])[1] //? Map entry
      : ioInstance.sockets.sockets.get(socketEntry as string); //? socket ID from Set

    if (!tempSocket) { continue; }

    //? check if they have a token stored in there cookie or session based on the settings
    const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
    const tempSessionToken = tempSocket.handshake.auth?.token
    const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
      : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
      : null; 

    //? here we get the users session of the client and run the sync function with the data and the users session data
    const user = await getSession(tempToken);

    if (ignoreSelf && typeof ignoreSelf == 'boolean') {
      if (token == tempToken) {
        continue;
      }
    }

    if (syncObject[`${name}_client`]) {
      const [clientSyncError, clientSyncResult] = await tryCatch(async () => await syncObject[`${name}_client`]({ clientData: data, user, functions: functionsObject, serverData, roomCode: receiver }));
      // if (clientSyncError) { socket.emit(`sync-${responseIndex}`, { status: "error", message: clientSyncError }); }
      if (clientSyncError) { tempSocket.emit(`sync`, { status: "error", message: clientSyncError }) }
      //? if we return error we dont want this client to get the event
      else if (clientSyncResult?.status == 'error') { continue; }
      else if (clientSyncResult?.status == 'success') {
        const result = { 
          cb, 
          serverData, 
          clientData: clientSyncResult, 
          message: clientSyncResult.message || `${name} sync success`, 
          status: 'success' 
        };
        console.log(result, 'blue')
        tempSocket.emit(`sync`, result);
      } 
    } else {
      //? if there is no client function we still want to send the server data to the clients
      const result = { 
        cb, 
        serverData, 
        clientData: {}, 
        message: `${name} sync success`, 
        status: 'success' 
      };
      console.log(result, 'blue')
      tempSocket.emit(`sync`, result);
    }
  }

  return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { success: true, message: `sync ${name} success` });
}
</file>

<file path="server/sockets/socket.ts">
import dotenv from 'dotenv';
dotenv.config();

import handleApiRequest from "./handleApiRequest";
import { getSession, saveSession } from "../functions/session";
import { Server as SocketIOServer } from 'socket.io';
import handleSyncRequest from "./handleSyncRequest";
import allowedOrigin from '../auth/checkOrigin';
import { initAcitivityBroadcaster, socketConnected, socketDisconnecting, socketLeaveRoom } from './utils/activityBroadcaster';
import config, { SessionLayout } from '../../config';

export type apiMessage = {
  name: string;
  data: object;
  responseIndex: number;
}

export type syncMessage = {
  name: string;
  data: object;
  cb: string;
  receiver: string;
  responseIndex?: number;
  ignoreSelf?: boolean;
}

export let ioInstance: SocketIOServer | null = null;

export default function loadSocket(httpServer: any) {

  //? here we create the SocketIOServer instance
  const io = new SocketIOServer(httpServer, {
    cors: { 
      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      origin: (origin, callback) => {
        if (!origin || allowedOrigin(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
    },
    maxHttpBufferSize: 5 * 1024 * 1024, // 5 MB
  });

  ioInstance = io;
  
  console.log('SocketIO server initialized', 'green');

  //? when a client connects to the SocketIO server we define there cookies and define some events to work with the exports of serverRequest.ts on the client
  io.on('connection', (socket) => {
    const cookie = socket.handshake.headers.cookie; // get the cookie from the socket connection
    const sessionToken = socket.handshake.auth?.token;
    const token = 
      cookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? cookie.split("=")[1] 
      : sessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true'? sessionToken
      : null; 


    if (token) {
      socketConnected({ token, io });
    }

    socket.on('apiRequest', async (msg: apiMessage) => {
      handleApiRequest({ msg, socket, token });
    });
    socket.on('sync', async (msg: syncMessage) => {
      handleSyncRequest({ msg, socket, token });
    });
    socket.on('joinRoom', async (data) => {
      const { group, responseIndex } = data;
      await socket.join(group);
      await saveSession(token, { ...await getSession(token), code: group });
      socket.emit(`joinRoom-${responseIndex}`);
      console.log(`Socket ${socket.id} joined group ${group}`, 'cyan');
    });

    socket.on('disconnect', async (reason) => {
      if (config.socketActivityBroadcaster) {
        socketDisconnecting({ token, socket, reason });
      } else {
        if (!token) { return; }
        console.log(`user disconnected, reason: ${reason}`, 'yellow');
      }
    });

    socket.on('updateLocation', async (newLocation) => {
      console.log('updating location to: ', newLocation.pathName, 'yellow')

      let returnedUser: SessionLayout | undefined;
      if (config.socketActivityBroadcaster) {
        returnedUser = await socketLeaveRoom({ token, socket, newPath: newLocation.pathName });
      }

      if (!newLocation) { return; }
      const user = returnedUser || await getSession(token);
      if (!user) { return; }

      user.location = newLocation;
      return await saveSession(token, user);
    });

    if (config.socketActivityBroadcaster) {
      initAcitivityBroadcaster({ socket, token });
    }

    if (token) {
      socket.join(token);
    }
  
  });
  return io;
}
</file>

<file path="server/sockets/utils/activityBroadcaster.ts">
// ------------
// Activity Broadcaster
// ------------
// This module provides info about the users activty
// this is usefull to make a game to pause it for example when the user is not active

import { Server, Socket } from "socket.io";
import { deleteSession, getSession } from "../../functions/session";
import handleSyncRequest from "../handleSyncRequest";
import { ioInstance } from "../socket";

export const disconnectTimers = new Map<string, NodeJS.Timeout>();
export const disconnectReasonsWeIgnore: string[] = ['ping timeout', ];
export const disconnectReasonsWeAllow: string[] = ['transport close', 'transport error'];
export const tempDisconnectedSockets = new Set<string>();
export const clientSwitchedTab = new Set<string>();

export const socketConnected = async ({
  token,
  io
}: {
  token: string,
  io: Server
}) => {
  const timer = disconnectTimers.get(token);
  if (timer) { 
    console.log(`user came back with token: ${token}`, 'yellow');
    clearTimeout(timer);
    disconnectTimers.delete(token);
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else {
      console.log(`a user connected with token: ${token}`, 'cyan');
    }
  }

  const session = await getSession(token);
  const userId = session?.id || null;
  const code = session?.code || null;

  if (!code) { return; }
  if (!userId) { return; }

  informRoomPeers({ token, io, event: 'userBack', extraData: { ignoreSelf: true } });
}


export const socketLeaveRoom = async ({ token, socket, newPath }: {
  token: string | null,
  socket: Socket,
  newPath: string | null
}) => {

  //? retrieve users session data
  if (!token) { 
    console.log('trying to update room peers but no token provided', 'red'); 
    return;
  }

  const user = await getSession(token);
  if (!user?.id) { 
    console.log(`no session data for given token: ${token}`, 'red'); 
    return;
  }

  const { pathName, searchParams } = user.location || {};



  /////////////
  //? EXAMPLE USAGE
  /////////////

  
  // console.log(`
  //   check1: ${pathName == '/games/test123'}
  //   check2: ${user.code}
  //   check3: ${!newPath || newPath !== pathName}
  // `, 'cyan');
  
  // //? if user is at a certain location we run a sync function to update the other players that are in the same room has him
  // if (
  //   pathName == '/games/test123' &&
  //   user.code &&
  //   (!newPath || newPath !== pathName)
  // ) {
  //   console.log('socket is leaving test123 game', 'cyan');
  //   handleSyncRequest({
  //     msg: { 
  //       name: 'sync/games/test123/playerLeave', 
  //       data: { gameCode: user.code, oldUser: user },
  //       cb: 'playerLeave',
  //       receiver: searchParams?.code, ignoreSelf: true
  //     },
  //     socket,
  //     token
  //   });
  //   socket.leave(user.code);
  // }

  return user;

}

const getDisconnectTime = ({ 
  token, 
  reason 
}: {
  token: string,
  reason: string | undefined
}) => {
  return clientSwitchedTab.has(token) 
    ? 20000 
    // ? 3000 
    : disconnectReasonsWeAllow.includes(reason ?? "NULL") 
    ? 60000 
    : 2000
}

export const socketDisconnecting = async ({
  token,
  reason,
  socket
}: {
  token: string,
  reason: string,
  socket: Socket
}) => {

  if (disconnectReasonsWeIgnore.includes(reason)) {
    console.log(`user disconnected but we ignore it, reason: ${reason}`, 'yellow');
    return; 
  }

  if (!token) { return; }
  if (!tempDisconnectedSockets.has(token)) {
    tempDisconnectedSockets.add(token);
  } else {
    return; //? if the user is already in the tempDisconnectedSockets array we ignore the disconnect event
  }

  const time = getDisconnectTime({ token, reason });

  let deleteSessionOnDisconnect = true;
  if (clientSwitchedTab.has(token)) {
    deleteSessionOnDisconnect = false;
    clientSwitchedTab.delete(token);
  }

  console.log(`user disconnected, reason: ${reason}, timer: ${time/1000} seconds`, 'yellow');

  const timeout = setTimeout(async () => {
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else { return; } //? if the user has reconnected we dont run the logout function

    if (disconnectTimers.get(token) !== timeout) { return };

    await socketLeaveRoom({ token, socket, newPath: null });

    //? we only delete the session if the user disconnected themself, it the server kicked them it means that they were kicked from a game
    if (deleteSessionOnDisconnect) {
      await deleteSession(token);
    }

    console.log(`user fully disconnected, reason: ${reason}, timer : ${time/1000} seconds, deleteSessionOnDisconnect: ${deleteSessionOnDisconnect}`, 'yellow');
  }, time);

  if (disconnectTimers.has(token)) {
    clearTimeout(disconnectTimers.get(token)!);
    disconnectTimers.delete(token);
  }
  disconnectTimers.set(token, timeout);

}

const informRoomPeers = async ({
  token,
  io = ioInstance,

  event,
  extraData,
}: {
  token: string,
  io?: Server | null

  event: 'userAfk' | 'userBack',
  extraData?: any
}) => {
  if (!io) { 
    console.log('no io instance found to inform room peers', 'red');
    return; 
  }

  const session = await getSession(token);
  if (session.code) {
    const roomSockets = io.sockets.adapter.rooms.get(session.code);
    console.log(roomSockets);
    
    for (const socketId of roomSockets || []) {
      const tempSocket = io.sockets.sockets.get(socketId as string);
      if (!tempSocket) { continue; }

      if (extraData?.ignoreSelf) {
        console.log(' skipping self emit ');
        
        const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
        const tempSessionToken = tempSocket.handshake.auth?.token
        const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
          : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
          : null; 

        if (token == tempToken) { continue; } //? we dont send the event to the client who called the event
      }

      if (event == 'userAfk') {
        console.log({ userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
        tempSocket?.emit('userAfk', { userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
      } else if (event == 'userBack') {
        tempSocket?.emit('userBack', { userId: session.id });
      }
    }
  }
}

export const initAcitivityBroadcaster = ({
  token,
  socket
}: {
  token: string,
  socket: Socket,
}) => {
  socket.on("intentionalDisconnect", async () => {
    clientSwitchedTab.add(token);
    const time = getDisconnectTime({ token, reason: undefined });

    await informRoomPeers({ token, event: 'userAfk', extraData: { time } });

    socket.disconnect(false);
  });
}
</file>

<file path="server/sockets/utils/logout.ts">
import { Socket } from "socket.io";
import redis from "../../functions/redis";
import { tryCatch } from "../../functions/tryCatch";
import { disconnectTimers, tempDisconnectedSockets } from "./activityBroadcaster";
import { deleteSession } from "../../functions/session";
import { socketLeaveRoom } from "./activityBroadcaster";

export const logout = async ({ token, socket, userId }: {
  token: string | null,
  socket: Socket | undefined,
  userId: string | null,
}) => {
  const [error, result] = await tryCatch(async () => {
    if (!socket) { 
      console.log('Trying to logout but invalid socket', 'red');
      return;
    }
    if (!token) { 
      console.log('Trying to logout without a token', 'red');
      return;
    }
    
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    }

    if (disconnectTimers.has(token)) {
      const timer = disconnectTimers.get(token);
      if (timer) {
        clearTimeout(timer);
        disconnectTimers.delete(token);
      } 
    }

    console.log(`Logging out user with token: ${token}`, 'cyan');
    
    await socketLeaveRoom({ token, socket, newPath: null });
    await deleteSession(token);
    const tokensOfActiveUsers = `${process.env.PROJECT_NAME}-activeUsers:${userId}`
    await redis.srem(tokensOfActiveUsers, token);
    socket.leave(token);
    return true;
  });
  if (error) {
    if (socket) {
      socket.emit(`logout`, "error");
    }
  } else if (result) {
    if (socket) {
      socket.emit(`logout`, "success");
    }
  }
}
</file>

<file path="server/sockets/utils/onLocationChange.ts">

</file>

<file path="server/utils/console.log.ts">
const COLORS: Record<string, string> = {
  black: "\x1b[30m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  white: "\x1b[37m",
  reset: "\x1b[0m",
};

export const initConsolelog = () => {
  const originalLog = console.log;
  console.log = (...args: any[]) => {
    const stack = new Error().stack?.split("\n")[2]?.trim();
    if (!stack) return originalLog(...args);
  
    let lineInfo = stack.substring(stack.indexOf("(") + 1, stack.lastIndexOf(")"));
    if (lineInfo === "") lineInfo = stack;
    const extractedInfo = lineInfo
      .substring(lineInfo.lastIndexOf("\\") + 1)
      .replace(/:\d+$/, "");
  
    // find color keyword and remove it from args
    let colorCode = COLORS.white;
    for (const key of Object.keys(COLORS)) {
      const index = args.findIndex((a) => a === key);
      if (index !== -1) {
        colorCode = COLORS[key];
        args.splice(index, 1);
        break;
      }
    }
  
    // handle object vs text
    if (typeof args[0] === "object") {
      originalLog(`${colorCode}${extractedInfo}${COLORS.reset}`);
      originalLog(args);
    } else {
      originalLog(`${colorCode}${extractedInfo} -- ${args.join(" ")}${COLORS.reset}`);
    }
  };
}
</file>

<file path="server/utils/getParams.ts">
import { IncomingMessage, ServerResponse } from "http";
import { tryCatch } from "../functions/tryCatch";

type getParamsType = {
  method: string;
  req: IncomingMessage;
  res: ServerResponse;
  queryString?: string;
}

export default async function getParams({ method, req, res, queryString }: getParamsType): Promise<Record<string, any> | null> {

  if (method == "GET") {
    //? if get request we return the query string as an object
    return Object.fromEntries(new URLSearchParams(queryString || '')) as Record<string, string>;
  }

  //? if a POST, PUT or DELETE method we return the body as an object
  return new Promise((resolve, reject) => {
    const contentType = req.headers['content-type'] || '';

    //? we store the passed data chunks in a string
      let body = '';
      req.on('data', (chunk) => {
        body += chunk.toString();
      }); 

      req.on('end', async () => {
        //? here we parse the data depending on the content type
        //? if the content type is application/x-www-form-urlencoded we parse the data as a URLSearchParams object
        if (contentType.startsWith('application/x-www-form-urlencoded')) {
          const parseData = () => {
            const data = new URLSearchParams(body);
            return Object.fromEntries(data);
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        //? if the content type is application/json we parse the data as a JSON object
        if (contentType.startsWith('application/json')) {
          const parseData = () => {
            return JSON.parse(body || '{}');
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        resolve({ body });
      })

      req.on('error', (error) => {
        reject(error);
      })
    // }

  });
}
</file>

<file path="server/utils/repl.ts">
import { getAllGameDatas, getGameData, saveGameData } from "../functions/game"
import { deleteSession, getAllSessions, getSession } from "../functions/session"
import repl from 'repl';

export const initRepl = () => {
  const replInstance = repl.start({
    prompt: 'server> ',
    useColors: true,
    useGlobal: true,
  })
  
  replInstance.context.getAllSessions = async () => {
    console.log(await getAllSessions())
  }

  replInstance.context.getSession = async (token: string) => {
  
    const session = await getSession(token)
    if (session && typeof session == 'object' && Object.keys(session).length > 0) {
      console.log(session) 
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.deleteSession = async (token: string) => {
  
    const result = await deleteSession(token)
    console.log(result)
  }
  
  replInstance.context.getGame = async (code: string, keys?: string) => {
    if (!code) {
      console.log(await getAllGameDatas())
      return;
    }
  
    const gameData = await getGameData(code)
    if (typeof gameData == 'object' && gameData?.gameCode) {
      if (keys) {
        const parts = keys
        .replace(/\[(\w+)\]/g, ".$1")   // turn [0] into .0
        .replace(/^\./, "")             // remove leading dot
        .split(/(?:\?\.)|\./);          // split on ?. or .
        
        // @ts-ignore
        console.log(parts.reduce((acc, key) => acc?.[key], gameData));
      } else {
        console.log(gameData) 
      }
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.updateGame = async (code: string, keys: string, value: any) => {
    if (!code || !keys) {
      console.log("Usage: updateGame(code, 'nested.path.like.this', value)");
      return;
    }
  
    let gameData = await getGameData(code);
    if (typeof gameData !== "object" || !gameData?.gameCode) {
      console.log("No session found");
      return;
    }
  
    // Parse the keys string into parts (supporting [0], ?. etc.)
    const parts = keys
      .replace(/\[(\w+)\]/g, ".$1") // turn [0] into .0
      .replace(/^\./, "")           // remove leading dot
      .split(/(?:\?\.)|\./);        // split on ?. or .
  
    // Walk into object and set the value
    let target = gameData;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (!(key in target)) {
        // @ts-ignore
        target[key] = {}; // create missing objects
      }
      // @ts-ignore
      target = target[key];
    }
  
    const lastKey = parts[parts.length - 1];
    // @ts-ignore
    target[lastKey] = value;
  
    // Persist the change (assuming you already have a saveGameData function)
    await saveGameData(code, gameData);
  
    console.log(`Updated ${keys} to:`, value);
  };
  
  
  replInstance.context.commands = () => {
    console.log('commands:')
    console.log('getSession(token) -- if no token provided then it will return all sessions')
    console.log('deleteSession(token) -- if no token provided then it will delete all sessions')
    console.log('getGame(code) -- if no code provided then it will return all sessions')
  }
}
</file>

<file path="src/_components/Avatar.tsx">
import { backendUrl, SessionLayout } from "config";
import { useAvatarContext } from "./AvatarProvider";

export default function Avatar({
  user,
  textSize,
}: {
  user: SessionLayout 
  | {name: string, avatar?: string, avatarFallback?: string},
  textSize?: "text-sm" | "text-base" | "text-lg" | "text-xl" | "text-2xl" | "text-3xl" | "text-4xl" | "text-5xl" | "text-6xl" | "text-7xl" | "text-8xl" | "text-9xl"
}) {
  const { avatarStatuses, setAvatarStatus } = useAvatarContext();

  // Unique key per avatar
  if (!user) { return null; }

  const key = user.avatar || user.avatarFallback || user.name;
  const avatarStatus = key ? avatarStatuses[key] : null;

  const formattedName = user?.name?.[0]?.toUpperCase() || "?";

  return user?.avatar && (avatarStatus === 'avatar' || !avatarStatus) ? (
    <Img user={user} key={key} setAvatarStatus={setAvatarStatus} />
  ) : (
    <FallbackImg user={user} formattedName={formattedName} textSize={textSize} />
  );
}

const Img = ({ user, setAvatarStatus }: any) => {
  if (!user?.avatar) {
    const key = user.avatar || user.avatarFallback || user.name;
    setAvatarStatus(key, 'fallback');
    return null;
  }

  const key = user.avatar || user.avatarFallback || user.name;

  return (
    <img
      className="rounded-full w-full h-full select-none object-cover aspect-square"
      src={user.avatar.startsWith('http') ? user.avatar : `${backendUrl}/uploads/${user.avatar}`}
      alt="Avatar"
      onError={() => setAvatarStatus(key, 'fallback')}
      onLoad={() => setAvatarStatus(key, 'avatar')}
    />
  );
};

const FallbackImg = ({ user, formattedName, textSize }: any) => {
  return (
    <div
      className={`rounded-full bg-gray-300 text-white flex items-center justify-center w-full h-full select-none ${textSize || 'text-lg'}`}
      style={{ backgroundColor: user?.avatarFallback }}
    >
      {user?.name && user.name !== 'Wachten op speler' ? formattedName : null}
    </div>
  );
};
</file>

<file path="src/_components/AvatarProvider.tsx">
import { createContext, useContext, useState, ReactNode } from "react";

type AvatarStatus = 'avatar' | 'fallback';

interface AvatarContextType {
  avatarStatuses: Record<string, AvatarStatus>;
  setAvatarStatus: (key: string, status: AvatarStatus) => void;
}

const AvatarContext = createContext<AvatarContextType | null>(null);

export const AvatarProvider = ({ children }: { children: ReactNode }) => {
  const [avatarStatuses, setAvatarStatuses] = useState<Record<string, AvatarStatus>>({});

  const setAvatarStatus = (key: string, status: AvatarStatus) => {
    setAvatarStatuses(prev => ({ ...prev, [key]: status }));
  };

  return (
    <AvatarContext.Provider value={{ avatarStatuses, setAvatarStatus }}>
      {children}
    </AvatarContext.Provider>
  );
};

export const useAvatarContext = () => {
  const ctx = useContext(AvatarContext);
  if (!ctx) throw new Error("useAvatarContext must be used within AvatarProvider");
  return ctx;
};
</file>

<file path="src/_components/ConfirmMenu.tsx">
import { ReactNode, useState } from 'react';
import { menuHandler } from 'src/_functions/menuHandler';

interface ConfirmMenuProps {
  title: string;
  content?: string | ReactNode;
  // confirm: () => void;
  input?: string;
  resolve: (val: boolean) => void;
}

export const ConfirmMenu = ({ title, content, input, resolve }: ConfirmMenuProps) => {
// export const ConfirmMenu = ({ title, content, confirm, input, resolve }: ConfirmMenuProps) => {
  const [inputValue, setInputValue] = useState('');

  const handleConfirm = () => {
    if (input && input !== inputValue) return;
    // confirm();
    resolve(true);
    menuHandler.close();
  };

  const handleCancel = () => {
    resolve(false);
    menuHandler.close();
  };

  const inputRequiredAndInvalid = input && input !== inputValue ? true : false;

  return (
    <div className="p-6 flex flex-col gap-4 bg-white w-full max-w-md">
      <h2 className="text-xl font-bold">{title}</h2>

      {typeof content === 'string' ? (
        <p className="text-gray-700">{content}</p>
      ) : (
        content
      )}

      {input && (
        <div className="flex flex-col gap-1">
          <label className="text-sm text-gray-600">
            Type <span className="font-mono bg-gray-100 px-1">{input}</span> to confirm:
          </label>
          <input
            type="text"
            className="border rounded px-2 py-1 focus:border outline-none focus:ring-0"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
          />
        </div>
      )}

      <div className="flex gap-4 justify-end">
        <button
          onClick={handleCancel}
          className="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          disabled={inputRequiredAndInvalid}
          className={`px-4 py-2 rounded text-sm text-white transition font-semibold
            ${inputRequiredAndInvalid
              ? 'bg-blue-300 cursor-not-allowed'
              : 'bg-blue-500 hover:bg-blue-700 cursor-pointer'
            }`}
        >
          Confirm
        </button>
      </div>
    </div>
  );
};

// export const confirmDialog = async (props: Omit<ConfirmMenuProps, 'resolve'>): Promise<boolean> => {
//   return await menuHandler.open(
//     <ConfirmMenu {...props} resolve={(a) => {console.log(a)}} />,
//     { dimBackground: true, background: 'bg-white', size: 'sm' }
//   );
// };
export const confirmDialog = (props: Omit<ConfirmMenuProps, 'resolve'>): Promise<boolean> => {
  return new Promise((resolve) => {
    menuHandler.open(
      <ConfirmMenu {...props} resolve={resolve} />,
      { dimBackground: true, background: 'bg-white', size: 'sm' }
    );
  });
};
</file>

<file path="src/_components/Icon.tsx">
interface Props {
	name: string,
	size?: string,
	weight?: string,
  customClasses?: string,
  onClick?: () => void
}

export default function Icon({ name, size, weight, customClasses, onClick }: Props) {
  if (!name) return null

  return (
    <span
      style={{ fontSize: size ? size : '20px', fontWeight: weight ? weight : 'lighter' }}
      className={`material-icons select-none ${customClasses}`}
      onClick={onClick}
    >
      {name}
    </span>
  )
}
</file>

<file path="src/_components/LocationProvider.tsx">
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { updateLocationRequest } from 'src/_sockets/socketInitializer';

export default function LocationProvider({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  
  useEffect(() => {
    //? when the user changes the url, update the location in the users session data on the server, also update navbar from default tempalte
    const searchParams: Record<string, string> = {};
    for (const [key, value] of new URLSearchParams(location.search)) {
      searchParams[key] = value;
    }
    const locationObj = {
      pathName: location.pathname,
      searchParams
    }

    void updateLocationRequest({ location: locationObj })
  }, [location]);

  //? Outlet is all the child components in the browser router
  return (
    <>
      {children}
    </>
  );
}
</file>

<file path="src/_components/LoginForm.tsx">
import { useRef, useState } from "react";
import { Link } from "react-router-dom";
import config, { providers, SessionLayout } from "config";
import tryCatch from "src/_functions/tryCatch";
import notify from "../_functions/notify";
const env = import.meta.env;

export default function LoginForm({ formType }: { formType: "login" | "register" }) {
  const isLogin = formType === "login";
  const title = isLogin ? "Sign in to your account" : "Create a new account";
  const subtitleText = isLogin ? "Don't have an account yet? " : "Already have an account? ";
  const subtitleLink = isLogin ? "Create one now" : "Log in";
  const redirectURL = isLogin ? "/register" : "/login";
  const buttonText = isLogin ? "Log in" : "Sign up";

  const buttonRef = useRef<HTMLButtonElement>(null);
  const [loading, setLoading] = useState(false);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      buttonRef.current?.click();
    }
  };

  const handleSubmit = async (e: React.MouseEvent<HTMLButtonElement>, provider: string) => {
    e.preventDefault();
    if (loading) return;
    setLoading(true);

    if (provider !== "credentials") {
      window.location.href = `${config.backendUrl}/auth/api/${provider}`;
      return;
    }

    const form = (e.target as HTMLElement).closest("form");
    if (!form) {
      setLoading(false);
      return console.error("Form not found");
    }

    const getValue = (name: string) =>
      (form.querySelector(`input[name="${name}"]`) as HTMLInputElement)?.value || "";

    const name = getValue("name");
    const email = getValue("email");
    const password = getValue("password");
    const confirmPassword = getValue("confirmPassword");

    const fetchUser = async () => {
      const res = await fetch(`${config.backendUrl}/auth/api/credentials`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email, password, confirmPassword, provider }),
        credentials: "include",
      });
      return (await res.json()) as { status: boolean; reason: string, newToken: string | null, session: SessionLayout | undefined };
    };

    const [error, response] = await tryCatch(fetchUser);
    if (error || !response?.reason) {
      // notify.error("Unexpected error occurred.");
      notify.error({ key: 'commen/.404' })
      console.error(error || "No JSON response");
      return setLoading(false);
    }

    if (!response.status) {
      notify.error({ key: response.reason });
      return setLoading(false);
    }

    notify.success({ key: response.reason });
    setTimeout(() => {
      if (response.newToken) {
        if (env.VITE_SESSION_BASED_TOKEN == 'true') {
          sessionStorage.setItem("token", response.newToken);
        }
      }
      window.location.href = response.newToken ? config.loginRedirectUrl : config.loginPageUrl;
      // window.location.href = config.loginPageUrl;
    }, 1000);
  };

  return (
    <div className="w-full overflow-y-auto flex items-center justify-center">
      <form
        onKeyDown={handleKeyDown}
        className="p-8 bg-container rounded-md text-title flex flex-col gap-10 max-w-[400px] w-full"
      >
        <div className="flex flex-col gap-2">
          <h1 className="font-semibold text-lg">{title}</h1>
          <p className="font-medium text-sm text-commen">
            {subtitleText}
            <Link to={redirectURL} className="text-blue-500 cursor-pointer">
              {subtitleLink}
            </Link>
          </p>
        </div>

        {providers.includes("credentials") && (
          <>
            <div className="flex flex-col gap-4">
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label className="font-medium text-sm">Name</label>
                  <input
                    name="name"
                    type="text"
                    placeholder="John Pork"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}
              <div className="flex flex-col gap-2">
                <label className="font-medium text-sm">Email address</label>
                <input
                  name="email"
                  type="email"
                  placeholder="johnpork@gmail.com"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              <div className="flex flex-col gap-2">
                <label className="font-medium text-sm">Password</label>
                <input
                  name="password"
                  type="password"
                  placeholder="********"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label className="font-medium text-sm">Confirm password</label>
                  <input
                    name="confirmPassword"
                    type="password"
                    placeholder="********"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}

              <div className="flex items-center justify-center">
                {isLogin && (
                  <button className="px-8 h-10 cursor-pointer rounded-md text-blue-500 hover:scale-105 transition-all duration-300">
                    Forgot Password?
                  </button>
                )}
              </div>

              <button
                ref={buttonRef}
                className="px-8 h-10 rounded-md bg-blue-500 text-title hover:scale-105 transition-all duration-300 cursor-pointer"
                onClick={(e) => void handleSubmit(e, "credentials")}
              >
                {loading ? "Loading..." : buttonText}
              </button>
            </div>

            <div className="flex items-center w-full text-gray-500 text-sm before:flex-1 before:border-t before:border-container-border before:content-[''] after:flex-1 after:border-t after:border-container-border after:content-['']">
              <span className="px-4 bg-container text-title">Or continue with</span>
            </div>
          </>
        )}

        <div className="grid grid-cols-2 gap-2">
          {providers
            .filter((p) => p !== "credentials")
            .map((provider) => (
              <button
                key={provider}
                onClick={(e) => void handleSubmit(e, provider)}
                className="h-10 rounded-md cursor-pointer bg-container text-title border border-container-border flex gap-2 items-center justify-center hover:scale-105 transition-all duration-300"
              >
                <img src={`/${provider}.png`} alt={provider} className="w-5 h-5" />
                <span className="text-lg">{provider.charAt(0).toUpperCase() + provider.slice(1)}</span>
              </button>
            ))}
        </div>
      </form>
    </div>
  );
}
</file>

<file path="src/_components/MenuHandler.tsx">
import { createContext, useContext, useState, ReactNode, ReactElement, useEffect, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { v4 as uuidv4 } from 'uuid';

// Types
interface MenuEntry {
  id: string;
  element: ReactElement;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
  resolver?: (value: any) => void;
}

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

interface MenuHandlerContextType {
  open: (element: ReactElement, options?: MenuOptions) => Promise<any>;
  replace: (element: ReactElement, options?: MenuOptions) => Promise<any>;
  close: () => void;
  closeAll: () => void;
  logStack: () => void;
}

interface SlideInWrapperProps {
  children: ReactNode;
  isTop: boolean;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
}

const SlideInWrapper = ({ children, options, isTop, isClosing, soonIsTop }: SlideInWrapperProps) => {
  const [location, setLocation] = useState<'left' | 'center' | 'right'>('right');

  useLayoutEffect(() => {
    // Start with off-screen to the right
    setLocation('right');

    const timer = requestAnimationFrame(() => {
      setLocation('center'); // trigger the transition
    });

    return () => cancelAnimationFrame(timer);
  }, []);

  useEffect(() => {

    // console.log("isClosing: ", isClosing, 'location: ', location, "top: ", isTop)
    if (!isTop && location === 'center') {
      setLocation('left'); // trigger the transition    
    } else if (isClosing && location === 'center') {
      setLocation('right'); // trigger the transition
    } else if (location === 'left' && soonIsTop) {
      setLocation('center'); // trigger the transition
    }
  }, [isTop, isClosing, soonIsTop]);

  const translate =
  location === 'center'
      ? '0 0'
      : location === 'left'
      ? '-100% 0'
      : '100% 0'; // initial

  return (
    <div
      className={`w-full overflow-hidden absolute flex flex-col text-black transform transition-transform duration-300 
        ${options.background ?? ''}
      `}
      style={{ translate }}
    >
      {children}
    </div>
  );
};


const MenuHandlerContext = createContext<MenuHandlerContextType | null>(null);

export const useMenuHandler = () => {
  const ctx = useContext(MenuHandlerContext);
  if (!ctx) throw new Error('useMenuHandler must be used within MenuHandlerProvider');
  return ctx;
};

export const MenuHandlerProvider = ({ children }: { children: ReactNode }) => {
  const [stack, setStack] = useState<MenuEntry[]>([]);

  const open = (element: ReactElement, options: MenuOptions = {}) => {
    return new Promise((resolve) => {
      const id = uuidv4();
      setStack((prev) => [...prev, { id, element, options, resolver: resolve }]);
    });
  };

  const replace = (element: ReactElement, options: MenuOptions = {}) => {
    return new Promise((resolve) => {
      const id = uuidv4();
      setStack((prev) => {
        const newStack = [...prev];
        newStack.pop();
        newStack.push({ id, element, options, resolver: resolve });
        return newStack;
      });
    });
  };

  const close = () => {
    setStack((prev) => {
      if (prev.length === 0) return prev;
      const lastitem = prev.length == 1
      const newStack = [...prev];
      const top = newStack[newStack.length - 1];
      const second = newStack[newStack.length - 2];
  
      // Prevent double-close
      if ((top as any).isClosing) return prev;
  
      // Mark top as closing
      if (!lastitem) {
        newStack[newStack.length - 1] = { ...top, isClosing: true };
        if (second) {
          newStack[newStack.length - 2] = { ...second, soonIsTop: true };
        }
      } else {
        top.resolver?.(null); // Resolve the promise with nul
        return [];
      }
  
      // Delay removal for animation
      if (!lastitem) {
        setTimeout(() => {
          setStack((current) => {
            const last = current[current.length - 1];
            const tempSecond = current[current.length - 2];
            if (last?.id === top.id && (last as any).isClosing) {
              if (last.resolver) last.resolver(null);
              if (tempSecond?.id && tempSecond.id == second?.id && (tempSecond as any).soonIsTop) {
                current[current.length - 2] = {...tempSecond, soonIsTop: false };
              }
              return current.slice(0, -1);
            }
            return current;
          });
        }, 200); // Match animation duration
      }
      return newStack;
    });
  };
  

  const closeAll = () => {
    setStack((prev) => {
      prev.forEach((entry) => entry.resolver?.(null));
      return [];
    });
  };

  const logStack = () => {
    console.log('Menu stack:', stack.map(s => s.id));
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') close();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const stackTop = stack[stack.length - 1] || {};
  // const { size = 'md', background = 'bg-white' } = options;

  const sizeClass = {
    sm: '384px', // max-w-sm
    md: '512px', // max-w-md
    lg: '768px', // max-w-lg
  }[stackTop?.options?.size || 'sm'];
  const [lastChildHeight, setLastChildHeight] = useState<number>(0);
  useEffect(() => {
    const lastChild = document.getElementById('test123')?.lastElementChild;
    if (lastChild) {
      setLastChildHeight(lastChild.getBoundingClientRect().height);
    } else {
      setLastChildHeight(0);
    }
  }, [stack]);

  let attempToCloseAll = false;
  
  return (
    <MenuHandlerContext.Provider value={{ open, replace, close, closeAll, logStack }}>
      {children}
      {createPortal(
        <div 
          className={`absolute top-0 left-0 w-full h-full flex items-center justify-center z-[1000] overflow-hidden ${stack.length == 0 ? 'pointer-events-none' : ''}`}
          style={{ backgroundColor: stackTop.options && stackTop.options?.dimBackground != false ? 'rgba(0, 0, 0, 0.7)' : 'transparent'  }}
          // onClick={closeAll}
          onMouseDown={() => attempToCloseAll = true}
          onMouseUp={() => {
            if (!attempToCloseAll) { return }
            closeAll();
          }}
        >
          <div 
            id="test123"
            className={`rounded-md overflow-hidden relative h-auto 
              transition-[opacity,transform,height,width] duration-200 origin-bottom-right 
            `}
            style={{ width: sizeClass, height: lastChildHeight+'px' }}
            onMouseDown={(e) => e.stopPropagation()}
            onMouseUp={(e) => e.stopPropagation()}
          >
            {stack.map((entry, index) => (
              <SlideInWrapper
                key={entry.id}
                isTop={index === stack.length - 1}
                isClosing={entry.isClosing}
                soonIsTop={entry.soonIsTop}
                // onBackgroundClick={closeAll}
                options={entry.options}
              >
                {entry.element}
              </SlideInWrapper>
            ))}
          </div>
        </div>,
        document.body
      )}
    </MenuHandlerContext.Provider>
  );
};
</file>

<file path="src/_components/Middleware.tsx">
import { ReactNode, useEffect, useState } from "react";
import middlewareHandler from "src/_functions/middlewareHandler"
import { useLocation, useNavigate } from "react-router-dom";
import { useSession } from "../_providers/SessionProvider";

export default function Middleware({ children }: { children: ReactNode }) {
  const [allowed, setAllowed] = useState(false);
  const [checking, setChecking] = useState(true);

  const location = useLocation();
  const navigate = useNavigate();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
    let isMounted = true;
    setAllowed(false);
    setChecking(true);

    void (async () => {
      const params = new URLSearchParams(location.search);
      const queryObject: Record<string, string> = {};

      params.forEach((value, key) => {
        queryObject[key] = value;
      });

      let count = 0;
      while (!sessionLoaded) { 
        await new Promise(res => setTimeout(res, 10));
        count++;
        if (count > 500) break; // after 5 seconds we stop waiting for the session
      }

      // const session = await apiRequest({ name: 'session' }) as SessionLayout;
      const result = await middlewareHandler({ location: location.pathname, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

      if (!isMounted) return;
      if (result?.success) {
        setAllowed(true);
      } else if (result?.redirect) {
        void navigate(result.redirect);
      } else {
        void navigate(-1);
      }

      setChecking(false);

      return () => {
        isMounted = false;
      }

    })();

    //! dont remove isMounted, read below
    //? i dont know why but the isMounted = false will always be false but because of this the navigate(-1) will always redirect to the previous page
    //? if we remove the isMounted variable than it will redirect to the previous page and then to the page before that one and so on wich we dont want
    //? e.g if we are on /test and go to /admin wich is not allowed we come back to /test, if we spam this request we come back to /test but if we remove the isMounted
    //? we first go back to /test but the second time we go back to the route before /test e.g /dashboard wich we dont want
    return () => {
      isMounted = false;
    };
  }, [location.pathname, sessionLoaded]); // important: rerun on path change

  if (checking || !allowed) return null;
  return <div className="w-full h-full">{children}</div>;
}
</file>

<file path="src/_components/Navbar.tsx">
import { ReactNode, useEffect, useRef, useState } from "react";
import { useLocation } from "react-router-dom";
import { SessionLayout } from "config";
import Icon from "./Icon";
import initializeRouter from "./Router";
import Avatar from "./Avatar";
import { useSession } from "../_providers/SessionProvider";
import { apiRequest } from "src/_sockets/apiRequest";

const navbarItems = [
  {
    init: function InitComponent({  session }: NavbarItemProps) {
      if (!session) { return null }
      return (
        <div className="w-6 h-6">
          <Avatar 
            user={session}
          />
        </div>
      )
    },
  },
  {
    icon: 'close_fullscreen',
    label: 'Close sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('folded')
    },
    hideOnFolded: true
  },
  {
    icon: 'open_in_full',
    label: 'Show sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('expended')
    },
    hideOnExpended: true
  },
  {
    icon: 'home',
    label: 'Test',
    path: '/test'
  },
  {
    icon: 'settings',
    label: 'Settings',
    path: '/settings'
  },
  {
    icon: 'admin_panel_settings',
    label: 'Admin',
    path: '/admin'
  },
  {
    icon: 'logout',
    label: 'Logout',
    bottom: true,
    action: async () => {
      await apiRequest({ name: 'logout' });
    }
  },
]

const activePopups: HTMLElement[] = [];
const clearPopups = () => {
  for (const popup of activePopups) {
    popup.remove();
  }
  activePopups.length = 0;
};

const displayPopup = ({ element, text }: { element: HTMLElement, text: string }) => {
  const popup = document.createElement('div');
  popup.className = `
    bg-gray-200 text-gray-700 rounded-md p-2 absolute z-50 shadow-lg whitespace-nowrap pointer-events-none
    transform scale-90 opacity-0 transition-all duration-200
  `;

  popup.innerHTML = text;

  const rect = element.getBoundingClientRect();
  if (rect.width == 0 && rect.height == 0) { return };
  
  popup.style.position = 'absolute';
  popup.style.top = `${(rect.top + window.scrollY - 10).toString()}px`;
  popup.style.left = `${(rect.left + window.scrollX + rect.width + 5).toString()}px`;
  document.body.appendChild(popup);

  activePopups.push(popup);
  void popup.offsetHeight;

  popup.classList.remove('scale-90', 'opacity-0');
  popup.classList.add('scale-100', 'opacity-100');

  element.addEventListener('mouseleave', () => { 
    popup.remove(); 
    const index = activePopups.indexOf(popup);
    if (index !== -1) activePopups.splice(index, 1);
  }, { once: true });
};

interface NavbarItemProps {
  item: {
    init?: ({ item, state, setState, pathname, session }: {
      item: NavbarItemProps["item"],
      state: NavbarItemProps["state"],
      setState: NavbarItemProps["setState"],
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => ReactNode,
    icon?: string,
    label?: string,
    path?: string,
    action?: ({ item, state, setState, pathname, session }: { 
      item: NavbarItemProps["item"], 
      state: NavbarItemProps["state"], 
      setState: NavbarItemProps["setState"], 
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => void,
    bottom?: boolean,
    hideOnFolded?: boolean,
    hideOnExpended?: boolean
  },
  state: 'folded' | 'expended',
  setState: (state: 'folded' | 'expended') => void,
  pathname: string,
  session: SessionLayout | null,
  router: (location: string) => Promise<void> | void
}

const NavbarItem = ({ item, state, setState, pathname, session, router }: NavbarItemProps) => {
  const toggleId = useRef<number | null>(null);
  return (
   <div className={`hover:bg-gray-200 hover:text-gray-600 w-full h-10 items-center rounded-sm transition-all duration-100 cursor-pointer gap-2 py-2
      ${state == 'expended' && item.hideOnExpended ? 'hidden' :
        state == 'folded' && item.hideOnFolded ? 'hidden' : 
        'flex'
      }
      ${state == 'folded' ? 'px-2' : 'px-2'}
      ${item.path == pathname ? 'bg-gray-200' : ''}
      ${item.bottom ? 'mt-auto' : ''}
    `}
    onMouseEnter={(e) => {
      if (state == 'expended') { return }
      const target = e.currentTarget as HTMLElement;
      const randomId = Math.floor(Math.random() * 1000000000000000);
      toggleId.current = randomId;
      setTimeout(() => {
        requestAnimationFrame(() => {
          if (item.label == undefined) { return }
          if (toggleId.current != randomId) { return }
          console.log('toggleId', toggleId.current);
          displayPopup({ element: target, text: item.label });
        })
      }, 100);
    }}
    onMouseLeave={() => {
      if (state == 'expended') { return }
      toggleId.current = null;
    }}
    onClick={async () => {
      if (item.action) { item.action({ item, state, setState, pathname, session, router }) }
      else if (item.path) { 
        clearPopups();
        void await router(item.path);
        setState('folded');
      }
    }}>
      {item.init ? 
        item.init({ item, state, setState, pathname, session: session, router })
      :
      <>
        <Icon 
          name={item.icon || ''} 
          size={state === 'folded' ? '18px' : '22px'}
          weight={'lighter'}
          customClasses={"relative left-0.75"}
        />
        {state == 'expended' &&
          <div className="line-clamp-1 select-none">{item.label}</div>
        }
      </>
      }
   </div> 
  ) 
}

export default function Navbar() {

  const [state, setState] = useState<'folded' | 'expended'>('folded');
  const location = useLocation();
  const router = initializeRouter()
  const { session } = useSession();

  useEffect(() => {
    clearPopups();
  }, [location.pathname]);

  const ref = useRef<HTMLDivElement>(null);
  const [parentWidth, setParentWidth] = useState<number>(0);

  useEffect(() => {
    const parent = ref.current?.parentElement;
    if (!parent) return;

    const observer = new ResizeObserver((entries) => {
      for (let entry of entries) {
        setParentWidth(entry.contentRect.width);
      }
    });

    observer.observe(parent);

    return () => observer.disconnect();
  }, []);

  if (!session) { return; }

  return (
    <div ref={ref}>
      {parentWidth < 768 &&
        <>
          <div className="w-full py-2 px-4 bg-white text-black flex justify-between items-center">
            <div className="w-8 h-8">
              <Avatar 
                user={session}
              />
            </div>
            <div className="">
              <Icon
                name={state == 'expended'? 'close_fullscreen' : 'open_in_full'}
                size={'22px'}
                weight={'lighter'}
                onClick={() => {
                  const value = state == 'expended'? 'folded' : 'expended';
                  setState(value)
                }}
              />
            </div>
          </div>
        </>
      }
      <div className={`h-full bg-white text-gray-500 flex flex-col items-center @md:py-4 transition-all duration-200 @md:px-2 absolute z-20 @md:z-0 @md:relative
        ${state == 'folded' ? 
          '@md:w-14 w-0 gap-3' : 
          'w-64 gap-1 px-2'
        }`}>

          {(parentWidth >= 768 || state === 'expended') && (
            <>
              {/* Top items */}
              {navbarItems.filter(item => !item.bottom).map((item, index) => {
                const shouldRender = item.init || (item.icon && item.label);
                if (!shouldRender) return null;

                return (
                  <NavbarItem
                    key={index}
                    pathname={location.pathname}
                    item={item}
                    state={state}
                    setState={setState}
                    session={session}
                    router={router}
                  />
                );
              })}

              {/* Bottom items, inside a mt-auto wrapper */}
              <div className="mt-auto w-full flex flex-col gap-2 items-center">
                {navbarItems.filter(item => item.bottom).map((item, index) => {
                  const shouldRender = item.init || (item.icon && item.label);
                  if (!shouldRender) return null;

                  return (
                    <NavbarItem
                      key={`bottom-${index}`}
                      pathname={location.pathname}
                      item={item}
                      state={state}
                      setState={setState}
                      session={session}
                      router={router}
                    />
                  );
                })}
              </div>
            </>
          )}

      </div>
      <div className={`@md:hidden flex absolute top-0 left-0 z-10 bg-black ${state != 'folded' ? 'opacity-80' : 'opacity-0 pointer-events-none'} transition-all duration-300 w-full h-full`}
        onClick={() => { setState('folded') }}>
      </div>
    </div>
  )
}
</file>

<file path="src/_components/Router.tsx">
import { useLocation, useNavigate } from "react-router-dom";
import middlewareHandler from "src/_functions/middlewareHandler";
import { useSession } from "../_providers/SessionProvider";

const getParams = (locationSearch: string) => {
  const params = new URLSearchParams(locationSearch);
  const queryObject: Record<string, string> = {};

  params.forEach((value, key) => {
    queryObject[key] = value;
  });

  return queryObject;
}

export default function initializeRouter() {
  const navigateHandler = useNavigate();
  const location = useLocation();
  const { session } = useSession();

  const navigate = async (path: string) => {
    // const session = await apiRequest({ name: 'session' }) as SessionLayout;
    const queryObject = getParams(location.search);
    const result = await middlewareHandler({ location: path, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

    if (result?.success) {
      return navigateHandler(path);
    } else if (result?.redirect) {
      return navigateHandler(result.redirect);
    } else {
      return
    }
  }

  return navigate
}
</file>

<file path="src/_components/TemplateProvider.tsx">
import { useEffect, useState } from 'react';
import Navbar from "src/_components/Navbar";
import Middleware from 'src/_components/Middleware';
import initializeRouter from './Router';
import { useLocation } from 'react-router-dom';
import Avatar from './Avatar';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faGear, faHome } from '@fortawesome/free-solid-svg-icons';
import { useSession } from '../_providers/SessionProvider';
import { useMenuHandler } from './MenuHandler';
import { ConfirmMenu } from './ConfirmMenu';
import ThemeToggler from './ThemeToggler';
import { dev } from '../../config';
import { useSocketStatus } from 'src/_providers/socketStatusProvider';
import { apiRequest } from 'src/_sockets/apiRequest';
import config from "config";

const Templates = {
  dashboard: DashboardTemplate,
  home: HomeTemplate,
  plain: PlainTemplate,
}
export  type Template = 'dashboard' | 'plain' | 'home';

function DashboardTemplate({ children }: { children: React.ReactNode }) {
  return (
    <div className="w-full h-full flex flex-row bg-white">
      <div className="w-full h-full flex flex-col md:flex-row">
        <Navbar/>
        <div className="md:flex-grow h-full text-black bg-blue-50">
          <Middleware>
            {children}
          </Middleware>
        </div>
      </div>
    </div>
  )
}

function HomeTemplate({ children }: { children: React.ReactNode }) {

  const router = initializeRouter();
  const location = useLocation();
  const { session } = useSession();
  const ref = useMenuHandler();

  return (
    <div className="w-full h-full overflow-hidden flex flex-col text-title text-sm md:text-lg">

      <div className='w-full flex items-center p-2 bg-container gap-4'>
        <div className='h-full flex-1 flex gap-2 items-center'>
          <div className='min-w-8 max-w-8 h-8'>
            {session && (
              <Avatar user={session} />
            )}
          </div>
          <h1 className='font-semibold text-base line-clamp-1'>{session?.name}</h1>
        </div>

        <button 
          className='p-2 bg-container2 border border-container2-border rounded-md cursor-pointer'
          onClick={() => {
            // console.log('clicked');
            if (location.pathname.startsWith('/games')) {
              ref.open(
                <ConfirmMenu
                  title="Spel verlaten?"
                  content="Weet je zeker dat je het spel wilt verlaten?"
                  resolve={(status: boolean) => {
                    if (!status) { return; }
                    ref.close();
                    router(location.pathname == '/settings' ? '/home' : '/settings')
                  }}
                />
              )
            } else {
              router(location.pathname == '/settings' ? '/home' : '/settings')
            }
          }}
        >
          <FontAwesomeIcon icon={location.pathname == '/settings' ? faHome : faGear} size='lg' />
        </button>

        <button 
          className='bg-container2 border border-container2-border rounded-md py-2 px-6 cursor-pointer font-semibold'
          onClick={() => apiRequest({ name: 'logout' })}
        >
          Uitloggen
        </button>
      </div>

      <div className='overflow-hidden w-full flex-grow'>
        <Middleware>
          {children}
        </Middleware>
      </div>

    </div>
  )
}

function PlainTemplate({ children }: { children: React.ReactNode }) {
  const { updateTheme } = ThemeToggler();

  useEffect(() => {
    updateTheme(config.defaultTheme);
    document.documentElement.classList.toggle("dark", config.defaultTheme === "dark");
  }, [location]);

  return (
    <div className="w-full h-full">
      {children}
    </div>
  )
}

export default function TemplateProvider({
  children,
  initialTemplate,
}: {
  children: React.ReactNode;
  initialTemplate: Template;
}) {
  const [template] = useState<Template>(initialTemplate);

  const TemplateComponent = Templates[template] || PlainTemplate;

  const { session } = useSession();
  const location = useLocation();
  const { updateTheme } = ThemeToggler();
  const { socketStatus } = useSocketStatus();

  useEffect(() => {
    if (session?.theme) {
      updateTheme(session.theme);
      document.documentElement.classList.toggle("dark", session.theme === "dark");
    }
  }, [session, location]);

  if (dev) {
    return (
      <div className='w-full h-full relative'>
        <div className='absolute top-2 right-2 z-50 bg-red-500 text-white px-2 py-1 rounded-md text-xs font-bold'>
          Socket status: {socketStatus.self.status}
          {socketStatus.self.status === "RECONNECTING" && socketStatus.self.reconnectAttempt ? ` (attempt ${socketStatus.self.reconnectAttempt})` : ''}
        </div>
        <TemplateComponent>{children}</TemplateComponent>
      </div>
    );  
  }

  return (
    <TemplateComponent>{children}</TemplateComponent>
  );
}
</file>

<file path="src/_components/ThemeToggler.tsx">
import { useState } from "react";

export default function ThemeToggler() {

  const [theme, setTheme] = useState<"light" | "dark">("dark");

  //? on default we set the theme to the session of the user but we allow to change it using a useState hook
  //? reason for this is that the settings page can display how it looks in the differnt theme without needing to call the server to update the sesion if the user hasnt clicked save yet
  const updateTheme = (newTheme: string) => {
    setTheme(newTheme == 'light' ? newTheme : "dark");
    document.documentElement.classList.toggle("dark", !(newTheme == "light"));
  };

  return { theme, updateTheme };
}
</file>

<file path="src/_components/TranslationProvider.tsx">
// src/_components/translationProvider.tsx
import { createContext, Dispatch, ReactNode, SetStateAction, useContext, useEffect, useMemo, useState } from "react";
import { useSession } from "../_providers/SessionProvider";
import nlJson from "src/_locales/nl.json";
import enJson from "src/_locales/en.json";
import deJson from "src/_locales/de.json";
import frJson from "src/_locales/fr.json";
import config from "config";

const TranslationContext = createContext<{
  translations: Record<string, any>,
  setLanguage: Dispatch<SetStateAction<'nl' | 'en' | 'de' | 'fr'>>;
} | null>(null);

const getLanguage = (language: string) => {
  switch (language) {
    case "nl": return nlJson;
    case "en": return enJson;
    case "de": return deJson;
    case "fr": return frJson;
    default: return enJson;
  }
};

export const TranslationProvider = ({ children }: { children: ReactNode }) => {
  const { session } = useSession();
  // const language = session?.language || config.defaultLanguage;
  const [language, setLanguage] = useState<'nl' | 'en' | 'de' | 'fr'>((session?.language || config.defaultLanguage) as 'nl' | 'en' | 'de' | 'fr');
  const translations = useMemo(() => getLanguage(language), [language]);

  useEffect(() => {
    if (session?.language) {
      setLanguage(session.language as 'nl' | 'en' | 'de' | 'fr');
    }
  },  [window.location.pathname, session])

  return (
    <TranslationContext.Provider value={{ translations, setLanguage }}>
      {children}
    </TranslationContext.Provider>
  );
};

export const useTranslation = () => {
  const context = useContext(TranslationContext);
  if (!context) {
    throw new Error("useTranslation must be used within a TranslationProvider");
  }
  return context.translations;
};

export const useUpdateLanguage = () => {
  const context = useContext(TranslationContext);
  if (!context) {
    throw new Error("setLanguage must be used within a TranslationProvider");
  }
  return context.setLanguage;
}

// helper function for dynamic translation
export const translate = ({ translationList, key, params }: {
  translationList: Record<string, any>,
  key: string,
  params?: { key: string, value: string | number | boolean }[]
}) => {
  let result = key.split(".").reduce((acc: any, part) => acc?.[part], translationList);
  if (typeof result !== "string") return key;
  if (!params) return result;

  for (const param of params) {
    if (!param.key) continue;
    if (typeof param.value === "undefined") continue;
    const regex = new RegExp(`{{${param.key}}}`, "g");
    result = result.replace(regex, param.value.toString());
  }
  return result;
};
</file>

<file path="src/_functions/confetti.ts">
declare const confetti: (options: { particleCount: number; spread: number; origin: { y: number } }) => void;

//? function makes confetti appear on the screen
export default function launchConfetti(): void {
  if (typeof confetti === 'function') {
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { y: 0.6 },
    });
  } else {
    console.warn("Confetti script is not loaded yet.");
  }
};
</file>

<file path="src/_functions/icon.ts">
// src/icons.ts
export { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
export * from "@fortawesome/free-solid-svg-icons";
// export * from "@fortawesome/free-regular-svg-icons";
// export * from "@fortawesome/free-brands-svg-icons";
</file>

<file path="src/_functions/menuHandler.ts">
import { ReactElement } from 'react';
import { useMenuHandler } from 'src/_components/MenuHandler';

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

let handler: ReturnType<typeof useMenuHandler> | null = null;
export const setMenuHandlerRef = (ref: ReturnType<typeof useMenuHandler>) => {
  handler = ref;
};

export const menuHandler = {
  open: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.open(component, options);
  },
  replace: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.replace(component, options);
  },
  close: (success?: boolean) => {
    handler?.close();
    return success;
  },
  closeAll: () => handler?.closeAll(),
  logStack: () => handler?.logStack()
};
</file>

<file path="src/_functions/middlewareHandler.ts">
//? here you can add your own route
//? return an object with the success key set to true if the user is allowed to access the route
//? return an object with the redirect key set to the path you want to redirect the user to if you want to redirect the user to a different page
//? return nothing if the user is not allowed to access the route and it will be send back to its previous page
//? if you dont add your page in here it will allow the user to access the page
import { SessionLayout } from "config";
import notify from "src/_functions/notify";

// @ts-ignore // we use ts-ignore because we dont use the searcParams in the example and this will cause a bundle error
export default function middlewareHandler({ location, searchParams, session }: { location: string, searchParams: Record<string, any>, session: SessionLayout | null }) {
  console.log(session)

  switch (location) {
    case '/test':
      if (session?.email && session?.provider) { 
        return { success: true }; 
      }
      return { redirect: '/login' };

    case '/admin':
      if (session?.email && session?.provider && session?.admin === true) {
        return { success: true }; 
      } else if (!session?.email || !session?.provider) {
        return { redirect: '/login' };
      } else if (!session?.admin) { 
        notify.error({ key: 'middleware.notAdmin' });
      }
      return

    case '/games/boerZoektVrouw':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    case '/home':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    case '/games':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    default:
      return { success: true };
  }
}
</file>

<file path="src/_functions/notify.ts">
import { toast } from "sonner";
import { translate } from "src/_components/TranslationProvider";
import nlJson from "src/_locales/nl.json";
import enJson from "src/_locales/en.json";
import deJson from "src/_locales/de.json";
import frJson from "src/_locales/fr.json";
import { getCurrentSession } from "src/_providers/SessionProvider";
// import Translator from "./translator";

const Translator = () => {
  const session = getCurrentSession();
  if (!session) { return }

  switch (session.language) {
    case "nl": return nlJson;
    case "en": return enJson;
    case "de": return deJson;
    case "fr": return frJson;
    default: return enJson;
  }
}

const notify = {
  success: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.success(translate({ translationList, key, params })); }
  },
  error: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.error(translate({ translationList, key, params })); }
  },
  info: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.info(translate({ translationList, key, params })); }
  },
  warning: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.warning(translate({ translationList, key, params })); }
  },
}

export default notify;
</file>

<file path="src/_functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="src/_functions/translator.ts">
// useTranslator.ts
import { useTranslation, translate } from "src/_components/TranslationProvider";

export const useTranslator = () => {
  const translations = useTranslation();
  return ({ key, params }: { key: string; params?: { key: string; value: string | number | boolean }[] }) =>
    translate({ translationList: translations, key, params });
};
</file>

<file path="src/_functions/tryCatch.ts">
//? wrap your funcions in this function and check if the first value has a truthy value if it does than there is an error
//? if the first value is null than there is no error and you can access the second value wich is the response of your function
export default async function <T, P>(
  func: (values: P) => Promise<T> | T, 
  params?: P
): Promise<[unknown, T | null]> {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error: unknown) {
    return [error, null];
  }
}
</file>

<file path="src/_locales/de.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FEHLER",
    "404": "Etwas ist schiefgelaufen, versuche es später erneut."
  },
  "middleware": {
    "notAdmin": "Du bist kein Admin."
  },
  "login": {
    "empty": "Keine E-Mail oder kein Passwort angegeben.",
    "emailCharacterLimit": "E-Mail darf nicht länger als 191 Zeichen sein.",
    "passwordCharacterMinimum": "Passwort muss mindestens 8 Zeichen lang sein.",
    "passwordCharacterLimit": "Passwort darf nicht länger als 191 Zeichen sein.",
    "nameCharacterLimit": "Name darf nicht länger als 191 Zeichen sein.",
    "invalidEmailFormat": "Ungültiges E-Mail-Format.",
    "passwordNotMatch": "Passwörter stimmen nicht überein.",
    "emailExists": "E-Mail existiert bereits.",
    "userCreated": "Benutzer erstellt.",
    "createUserFailed": "Fehler beim Erstellen des Benutzers.",
    "userNotFound": "Benutzer nicht gefunden.",
    "wrongPassword": "Passwort stimmt nicht überein.",
    "loggedIn": "Benutzer eingeloggt.",
    "providerNotFound": "Provider nicht gefunden.",
    "noReason": "Kein Grund angegeben."
  },
  "settings": {
    "changeAvatar": "Avatar ändern",
    "changeAvatarDescription": "JPG, GIF oder PNG. Max 4 MB.",
    "language": {
      "title": "Sprache",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Hell",
      "dark": "Dunkel"
    },
    "saveChanges": "Änderungen speichern",
    "updatedUser": "Benutzer aktualisiert",
    "failedUpdateUser": "Fehler beim Aktualisieren des Benutzers",
    "noChangesMade": "Keine Änderungen vorgenommen",
    "sizeToLarge": "Maximale Uploadgröße ist 4~5 MB, wähle ein kleineres Bild!!",
    "loadingImg": "Foto wird geladen",
    "imgLoaded": "Foto wurde geladen"
  }
}
</file>

<file path="src/_locales/en.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERROR",
    "404": "Something went wrong, try again later."
  },
  "middleware": {
    "notAdmin": "You are not an admin."
  },
  "login": {
    "empty": "No email or password provided.",
    "emailCharacterLimit": "Email can't be longer than 191 characters.",
    "passwordCharacterMinimum": "Password must be at least 8 characters long.",
    "passwordCharacterLimit": "Password can't be longer than 191 characters.",
    "nameCharacterLimit": "Name can't be longer than 191 characters.",
    "invalidEmailFormat": "Invalid email format.",
    "passwordNotMatch": "Passwords do not match.",
    "emailExists": "Email already exists.",
    "userCreated": "User created.",
    "createUserFailed": "Failed to create new user.",
    "userNotFound": "User not found.",
    "wrongPassword": "Password does not match.",
    "loggedIn": "User logged in.",
    "providerNotFound": "Provider not found.",
    "noReason": "No reason provided."
  },
  "settings": {
    "changeAvatar": "Change avatar",
    "deleteAvatar": "Delete avatar",
    "changeAvatarDescription": "JPG, GIF or PNG. 4MB max.",
    "language": {
      "title": "Language",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Theme",
      "light": "Light",
      "dark": "Dark"
    },
    "saveChanges": "Save changes",
    "updatedUser": "updated the user",
    "failedUpdateUser": "Failed to update the user",
    "noChangesMade": "No changes made",
    "sizeToLarge": "Max upload size is 4~5 MB, chose a smaller img!!",
    "loadingImg": "Photo is loading",
    "imgLoaded": "Photo has loaded"
  }
}
</file>

<file path="src/_locales/fr.json">
{
  "test": "Bonjour {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERREUR",
    "404": "Un problème est survenu, réessayez plus tard."
  },
  "middleware": {
    "notAdmin": "Vous n'êtes pas administrateur."
  },
  "login": {
    "empty": "Aucun e-mail ou mot de passe fourni.",
    "emailCharacterLimit": "L'e-mail ne peut pas dépasser 191 caractères.",
    "passwordCharacterMinimum": "Le mot de passe doit comporter au moins 8 caractères.",
    "passwordCharacterLimit": "Le mot de passe ne peut pas dépasser 191 caractères.",
    "nameCharacterLimit": "Le nom ne peut pas dépasser 191 caractères.",
    "invalidEmailFormat": "Format d'e-mail invalide.",
    "passwordNotMatch": "Les mots de passe ne correspondent pas.",
    "emailExists": "L'e-mail existe déjà.",
    "userCreated": "Utilisateur créé.",
    "createUserFailed": "Échec de la création de l'utilisateur.",
    "userNotFound": "Utilisateur non trouvé.",
    "wrongPassword": "Le mot de passe est incorrect.",
    "loggedIn": "Utilisateur connecté.",
    "providerNotFound": "Fournisseur introuvable.",
    "noReason": "Aucune raison fournie."
  },
  
  "settings": {
    "changeAvatar": "Changer d'avatar",
    "changeAvatarDescription": "JPG, GIF ou PNG. Max 4 Mo.",
    "language": {
      "title": "Langue",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thème",
      "light": "Clair",
      "dark": "Sombre"
    },
    "saveChanges": "Enregistrer les modifications",
    "updatedUser": "utilisateur mis à jour",
    "failedUpdateUser": "Échec de la mise à jour de l'utilisateur",
    "noChangesMade": "Aucun changement effectué",
    "sizeToLarge": "La taille maximale est de 4~5 Mo, choisissez une image plus petite !!",
    "loadingImg": "La photo est en cours de chargement",
    "imgLoaded": "La photo a été chargée"
  }
}
</file>

<file path="src/_locales/nl.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FOUT",
    "404": "Er is iets misgegaan, probeer het later opnieuw."
  },
  "middleware": {
    "notAdmin": "Je bent geen admin."
  },
  "login": {
    "empty": "Geen e-mail of wachtwoord opgegeven.",
    "emailCharacterLimit": "E-mail mag niet langer zijn dan 191 tekens.",
    "passwordCharacterMinimum": "Wachtwoord moet minimaal 8 tekens lang zijn.",
    "passwordCharacterLimit": "Wachtwoord mag niet langer zijn dan 191 tekens.",
    "nameCharacterLimit": "Naam mag niet langer zijn dan 191 tekens.",
    "invalidEmailFormat": "Ongeldig e-mailformaat.",
    "passwordNotMatch": "Wachtwoorden komen niet overeen.",
    "emailExists": "E-mail bestaat al.",
    "userCreated": "Gebruiker aangemaakt.",
    "createUserFailed": "Gebruiker aanmaken mislukt.",
    "userNotFound": "Gebruiker niet gevonden.",
    "wrongPassword": "Wachtwoord komt niet overeen.",
    "loggedIn": "Gebruiker ingelogd.",
    "providerNotFound": "Provider niet gevonden.",
    "noReason": "Geen reden opgegeven."
  },
  "settings": {
    "changeAvatar": "Verander avatar",
    "changeAvatarDescription": "JPG, GIF of PNG. Max 4MB.",
    "language": {
      "title": "Taal",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Licht",
      "dark": "Donker"
    },
    "saveChanges": "Wijzigingen opslaan",
    "updatedUser": "gebruiker bijgewerkt",
    "failedUpdateUser": "Bijwerken gebruiker mislukt",
    "noChangesMade": "Geen wijzigingen gemaakt",
    "sizeToLarge": "Maximale uploadgrootte is 4~5 MB, kies een kleinere afbeelding!!",
    "loadingImg": "Foto word geladen",
    "imgLoaded": "Foto is geladen"
  }
}
</file>

<file path="src/_providers/SessionProvider.tsx">
import { dev, SessionLayout } from '../../config';
import { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { apiRequest } from 'src/_sockets/apiRequest';
import { socketInstance, useSocket } from 'src/_sockets/socketInitializer';

type UserContextType = {
  session: SessionLayout | null;
  // setSession: Dispatch<SetStateAction<SessionLayout | null>>;
  sessionLoaded: boolean;
};

let latestSession: SessionLayout | null = null;

const UserContext = createContext<UserContextType | undefined>(undefined);

export const SessionProvider = ({ children }: { children: ReactNode }) => {
  const [session, setSession] = useState<SessionLayout | null>(null);
  const [sessionLoaded, setSessionLoaded] = useState(false);
  useSocket(session); //? starts the socket connection

  useEffect(() => {
    console.log('jowjowjowj');
    latestSession = session;
  }, [session])

  useEffect(() => {
    (async () => {
      const response = await apiRequest({ name: 'session' }) as SessionLayout | null;
      setSession(response);
      setSessionLoaded(true);
    })()
  }, [])

  useEffect(() => {
    if (!socketInstance) return;

    const handler = (data: string) => {
      if (dev) { console.log('updateSession', JSON.parse(data)); }
      const parsed = JSON.parse(data) as SessionLayout;
      setSession(prev => ({
        ...(prev as SessionLayout),
        ...parsed,
        avatar: parsed?.avatar + '?v=' + Date.now()
      }));
    }

    socketInstance.on('updateSession', handler)

    return () => {
      if (!socketInstance) return;
      socketInstance.off('updateSession', handler);
    }
    
  // }, [socketInstance])
  }, [])

  return (
    <UserContext.Provider value={{ session, sessionLoaded }}>
      {children}
    </UserContext.Provider>
  );
};

// 5. Create a custom hook for easier usage
export const useSession = () => {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useSession must be used within a SessionProvider');
  }
  return context;
};

export const getCurrentSession = () => latestSession;
</file>

<file path="src/_providers/socketStatusProvider.tsx">
import {
  createContext,
  useContext,
  useState,
  ReactNode,
  Dispatch,
  SetStateAction,
} from "react";

export type SOCKETSTATUS =
  | "CONNECTED"
  | "DISCONNECTED"
  | "RECONNECTING"
  | "STARTUP";

export interface statusContent {
  status: SOCKETSTATUS;
  reconnectAttempt?: number;
  endTime?: number;
}

interface SocketStatusContextType {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
}

const SocketStatusContext = createContext<SocketStatusContextType | undefined>(
  undefined
);

export const SocketStatusProvider = ({ children }: { children: ReactNode }) => {
  const [socketStatus, setSocketStatus] = useState({
    self: {
      status: "STARTUP" as SOCKETSTATUS,
    },
  });

  return (
    <SocketStatusContext.Provider value={{ socketStatus, setSocketStatus }}>
      {children}
    </SocketStatusContext.Provider>
  );
};

export const useSocketStatus = () => {
  const context = useContext(SocketStatusContext);
  if (!context) {
    throw new Error("useSocketStatus must be used within a SocketStatusProvider");
  }
  return context;
};
</file>

<file path="src/_sockets/apiRequest.ts">
import { dev } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
const env = import.meta.env;

//? if we use apiRequest function and the called api name starts with 1 of the names below we apply a abort controller
const abortControllers = new Map<string, AbortController>();
const abortControllerNames = ['get', 'fetch', 'load', 'is', 'has', 'list', 'all', 'search', 'view', 'retrieve'];

interface apiRequestType {
  name: string;
  data?: object;
}

export interface apiRequestReponse {
  status: 'success' | 'error' | any;
  result?: Record<string, any> | any;
  message?: string;
  messageParams?: Record<string, any>;
}

export const apiRequest = ({ name, data }: apiRequestType) => {
  return new Promise(async (resolve, reject) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name");
        toast.error("Invalid name");
      }
      return resolve(null);
    }

    if (!data || typeof data !== "object") {
      data = {};
    }

    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
  
    const useAbortController = abortControllerNames.some((tempName) => name.startsWith(tempName)) && env.VITE_SESSION_BASED_TOKEN != 'true';
    const pathname = window.location.pathname;
    const fullname = name != 'session' && name != 'logout' ? `api${pathname}/${name}` : name;
    // example: api/games/boerZoektVrouw/getGameData
  
    let signal: AbortSignal | null = null;
    let abortFunc = () => {};

    if (useAbortController) {
      if (abortControllers.has(fullname)) {
        //? if we have an abort controller we abort it and create a new one
        const prevAbortController = abortControllers.get(fullname);
        prevAbortController?.abort();
      }
      //? here we create a new abort controller and add it to the map with the api fullname as the key
      const abortController = new AbortController();
      abortControllers.set(fullname, abortController);
      abortFunc = () => {
        if (signal) { signal.removeEventListener("abort", abortFunc); }
        reject(`Request ${fullname} aborted`)
      };
      //? here we bind the abortFunc to the abort event so it will be called when the abort controller is aborted
      signal = abortController.signal;
      signal.addEventListener("abort", abortFunc);
    }

    const tempIndex = incrementResponseIndex();
    socket.emit('apiRequest', { name: fullname, data, responseIndex: tempIndex });
    
    if (dev && name != 'session' && name != 'logout') { console.log(`Client API Request(${tempIndex}): `, { name, data }) }
    socket.once(`apiResponse-${tempIndex}`, ({ result, message, status }: {
      result: any;
      message: string;
      status: "success" | "error";
    }) => {
      if (signal && signal.aborted) { return; }

      if (status === "error") {
        if (dev) {
          console.error('message:', message);
          toast.error(message);
        }
        return resolve({
          status,
          message
        })
      }

      if (dev && name != 'session' && name != 'logout') { console.log(`Server API Response(${tempIndex}): `, { name, ...result }) }
      if (dev && name == 'session') { console.log(`Session result(${tempIndex}): `, result) }
      if (dev && name == 'logout') { console.log(`Logout result(${tempIndex}): `, result) }

      if (signal) {
        signal.removeEventListener("abort", abortFunc);
        abortControllers.delete(fullname);
      }
      
      resolve(result)
    });
  })
}
</file>

<file path="src/_sockets/socketInitializer.ts">
import { toast } from "sonner";
import { io, Socket } from 'socket.io-client';
import config, { dev, backendUrl, SessionLayout } from "config";
import { useSocketStatus } from "../_providers/socketStatusProvider";
import { RefObject, useEffect, useRef } from "react";
import { initSyncRequest, useSyncEventTrigger } from "./syncRequest";

export let socketInstance: Socket | null = null;
export let socket: Socket | null = null;

let responseIndex = 0;
export const incrementResponseIndex = () => {
  return responseIndex = responseIndex + 1;
}

export function useSocket(session: SessionLayout | null) {
  const { socketStatus, setSocketStatus } = useSocketStatus();
  const { triggerSyncEvent } = useSyncEventTrigger();
  const sessionRef = useRef(session);

  useEffect(() => {
    console.log('bamibamiba', session);
    sessionRef.current = session;
  }, [session])

  useEffect(() => {
    const socketOptions: any = {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      autoConnect: true,
      withCredentials: true,
      auth: {}
    };

    if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
      const token = sessionStorage.getItem("token");
      if (token) {
        socketOptions.auth = { token };
      }
    }

    socketInstance = io(backendUrl, socketOptions);

    socket = socketInstance;


    const handleVisibility = async () => {
      if (!config.socketActivityBroadcaster) { return; }

      console.log(document.visibilityState)
        if (!socket) { return; }

      //? user switched tab or navigated away
      if (document.visibilityState === "hidden") {
        socket.emit("intentionalDisconnect");

      //? user switched back to the tab
      } else if (document.visibilityState === "visible") {
        if (socketStatus.self.status !== "CONNECTED") { 
          socket.connect();
        }
        socket?.emit("intentionalReconnect");
      }
    };
    document.addEventListener("visibilitychange", handleVisibility);

    if (config.socketActivityBroadcaster) {
      initSyncRequest({
        socketStatus, 
        setSocketStatus,
        sessionRef: sessionRef as RefObject<SessionLayout>
      })
    } else {
      socket.on("connect", () => {
        console.log("Connected to server");
      });

      socket.on("disconnect", () => {
        console.log("Disconnected, trying to reconnect...");
      });

      socket.on("reconnect_attempt", (attempt) => {
        console.log(`Reconnecting attempt ${attempt}...`);
      });

      socket.on("connect_error", (err) => {
        if (dev) {
          console.error(`Connection error: ${err.message}`);
          toast.error(`Connection error: ${err.message}`);
        }
      });

    }
    
    socket.on("logout", (status: "success" | "error") => {
      if (status === "success") {
        if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
          sessionStorage.clear();
        }
        window.location.href = config.loginPageUrl;
      } else {
        console.error("Logout failed");
        toast.error("Logout failed");
      }
    });

    socketInstance.on("sync", ({ cb, clientData, serverData, message, status }) => {
      const path = window.location.pathname;
      if (dev) console.log("Server Sync Response:", { cb, clientData, serverData, status, message });

      if (status === "error") {
        if (dev) {
          console.log(message);
          toast.error(message);
        }
        return;
      }

      triggerSyncEvent(`sync${path}/${cb}`, clientData, serverData);
    });


    return () => {
      if (socketInstance) {
        socketInstance.disconnect();
        socketInstance = null;
        socket = null;
        setSocketStatus(prev => ({
        ...prev,
        self: {
          status: "DISCONNECTED",
          reconnectAttempt: undefined,
          endTime: undefined,
        }
      }));
      }

      document.removeEventListener("visibilitychange", handleVisibility)
    };

  }, []);

  return socketInstance;
}


export const waitForSocket = async () => {

  let i = 0;
  while (!socket) {
    await new Promise((resolve) => setTimeout(resolve, 10));
    i++
    if (i > 500) { 
      if (dev) {
        console.error("Socket is not initialized, giving up");
        toast.error("Socket is not initialized, giving up");
      }
      return false 
    } //? we give it 500 * 10 so 5000ms or 5s to load the socket connection
  }

  return true
}

export const joinRoom = async (group: string) => {
  return new Promise(async (resolve) => {
    if (!group || typeof group!== "string") {
      if (dev) {
        console.error("Invalid group");
        toast.error("Invalid group");
      }
      return resolve(null);
    }
  
    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
  
    const tempIndex = incrementResponseIndex();
    socket.emit('joinRoom', { group, responseIndex: tempIndex });
  
    socket.once(`joinRoom-${tempIndex}`, () => {
      return resolve(true);
    });
  })
}

export const updateLocationRequest = async ({ location }: {location: {pathName: string, searchParams: Record<string, string>}}) => {
  if (!location.pathName || !location.searchParams) {
    if (dev) {
      console.error("Invalid location");
      toast.error("Invalid location"); 
    }
    return null;
  }

  if (!await waitForSocket()) { return }
  if (!socket) { return null; }

  socket.emit('updateLocation', location);
}
</file>

<file path="src/_sockets/syncRequest.ts">
import { dev, SessionLayout } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
import { statusContent } from "src/_providers/socketStatusProvider";
import { Dispatch, RefObject, SetStateAction } from "react";

const syncEvents: Record<string, ((params: { clientData: any; serverData: any; aditionalData: any }) => void)> = {};

type syncRequestType = {
  name: string;
  data?: object | null;
  receiver: any;
  ignoreSelf?: boolean;
}

export const syncRequest = async ({ name, data, receiver, ignoreSelf }: syncRequestType) => {
  return new Promise(async (resolve) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name for syncRequest");
        toast.error("Invalid name for syncRequest");
      }
      return resolve(null);
    }
  
    if (!data || typeof data !== "object") {
      data = {};
    }
  
    if (!receiver) {
      if (dev) {
        console.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
        toast.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
      }
      return resolve(null);
    }
  
    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
    
    const tempIndex = incrementResponseIndex();
    const pathname = window.location.pathname;
    const fullName = `sync${pathname}/${name}`;
    //? example: api/games/boerZoektVrouw/getGameData
  
    if (dev) { console.log(`Client Sync Request: `, { name, data, receiver, ignoreSelf }) }
  
    socket.emit('sync', { name: fullName, data, cb: name, receiver, responseIndex: tempIndex, ignoreSelf });

    socket.once(`sync-${tempIndex}`, (data: { status: "success" | "error", message: string }) => {
      if (data.status === "error") {
        if (dev) {
          console.error(`Sync ${name} failed: ${data.message}`);
          toast.error(`Sync ${name} failed: ${data.message}`);
        }
        return resolve(false);
      }
      resolve(data.status == "success");
    });
  })
}

export const useSyncEvents = () => {

  const upsertSyncEventCallback = (name: string, cb: (params: { clientData: any; serverData: any; }) => void) => {
    const path = window.location.pathname;
    syncEvents[`sync${path}/${name}`] = cb;
  }

  return { upsertSyncEventCallback };
}

export const useSyncEventTrigger = () => {

  const triggerSyncEvent = (name: string, clientData: any = {}, serverData: any = {}, aditionalData: any = {}) => {
    const cb = syncEvents[name];
    if (!cb) {
      if (dev) {
        console.log(syncEvents)
        console.error(`Sync event ${name} not found`);
        toast.error(`Sync event ${name} not found`);
      }
      return;
    }
    if (typeof cb == 'function') {
      cb({ clientData, serverData, aditionalData });
    }
  }

  return { triggerSyncEvent }
}

export const initSyncRequest = async ({
  socketStatus, 
  setSocketStatus,
  sessionRef
}: {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
  sessionRef: RefObject<SessionLayout> | null;
}) => {

  if (!await waitForSocket()) { return; }
  if (!socket) { return; }
  if (!sessionRef) { return; }

  socket.on("connect", () => {
    console.log(socketStatus)
    console.log("Connected to server");
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "CONNECTED",
        // reconnectAttempt: undefined,
      }
    }));
  });

  socket.on("disconnect", () => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
      }
    }));
    console.log("Disconnected, trying to reconnect...");
  });

  socket.on("reconnect_attempt", (attempt) => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "RECONNECTING",
        reconnectAttempt: attempt,
      }
    }));
    console.log(`Reconnecting attempt ${attempt}...`);
  });

  //? will not trigger when you call this event
  socket.on("userAfk", ({ userId, endTime }) => {
    if (userId == sessionRef.current?.id) { 
      setSocketStatus(prev => ({
        ...prev,
        self: {
          status: "DISCONNECTED",
          reconnectAttempt: undefined,
          endTime
        }
      }));
    } else {
      setSocketStatus(prev => ({
        ...prev,
        [userId]: {
          status: "DISCONNECTED",
          endTime
        }
      }));
    }
  });

  //? will not trigger when you call this event
  socket.on("userBack", ({ userId }) => {
    console.log("userBack", { userId });
    
    setSocketStatus(prev => {
      const newStatus = { ...prev };
      newStatus[userId] = {
        status: "CONNECTED",
        endTime: undefined,
      };
      return newStatus;
    });
  });

  socket.on("connect_error", (err) => {
    console.log("connect_error", { err });
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
        reconnectAttempt: undefined,
      }
    }));
    if (dev) {
      console.error(`Connection error: ${err.message}`);
      toast.error(`Connection error: ${err.message}`);
    }
  });

}
</file>

<file path="src/admin/page.tsx">
export default function Home() {
  return (
    <div className='flex items-center justify-center text-4xl font-semibold w-full h-full'>
      Admin
    </div>
  )
}
</file>

<file path="src/index.css">
@import "tailwindcss";

@theme {
  --color-background: #EFF6FF; /* blue-50 */

  --color-container: #FFFFFF; /* white */
  --color-container-border: #E5E7EB; /* gray-200 */
  --color-container-hover: #F3F4F6; /* gray-100 light hover */

  --color-container2: #F8FAFC; /* slate-50 */
  --color-container2-border: #E2E8F0; /* slate-200 */
  --color-container2-hover: #F1F5F9; /* light hover */

  --color-container3: #E5E7EB; /* gray-200 */
  --color-container3-border: #CBD5E1; /* gray-300 */
  --color-container3-hover: #D1D5DB; /* slightly darker */

  --color-container4: #F1F5F9; /* slate-100 */
  --color-container4-border: #E2E8F0; /* gray-200 */
  --color-container4-hover: #E2E8F0; /* slightly darker */

  --color-loadingScreen: #FAF9FF;

  --color-title: #000000; /* black */
  --color-commen: #1E293B; /* slate-800 */
  --color-muted: #64748B; /* slate-500 */

  /* Correct / wrong */
  --color-correct: #22C55E; /* green-500 */
  --color-correct-hover: #16A34A; /* green-600 */

  --color-wrong: #EF4444; /* red-500 */
  --color-wrong-hover: #DC2626; /* red-600 */

  --color-loadingscreen: #BFDBFE;             /* blue-200, a bit darker */

  --color-loadingscreen-container: #EFF6FF;   /* blue-50, subtle container */
  --color-loadingscreen-container-selected: #DBEAFE; /* blue-100, stands out */
  --color-loadingscreen-container-border: #93C5FD;   /* blue-300 border */
  --color-loadingscreen-container-text: #1E3A8A;     /* blue-900, strong text */
  
}

.dark {
  --color-background: #111827;          /* gray-900 */

  --color-container: #1F2937; /* gray-800 */
  --color-container-border: #374151; /* gray-700 */
  --color-container-hover: #3F4B63; /* slightly lighter dark hover */

  --color-container2: #374151; /* gray-700 */
  --color-container2-border: #4B5563; /* gray-600 */
  --color-container2-hover: #565E72;

  --color-container3: #4B5563; /* gray-600 */
  --color-container3-border: #6B7280; /* gray-500 */
  --color-container3-hover: #272F41;

  --color-container4: #1F2937; /* gray-800 */
  --color-container4-border: #374151; /* gray-700 */
  --color-container4-hover: #CBD5E1;

  --color-loadingScreen: #192432;
  
  --color-title: #FFFFFF;               /* white */
  --color-commen: #E5E7EB;              /* gray-200 */
  --color-muted: #9CA3AF;               /* gray-400 */

  /* Correct / wrong */
  --color-correct: #22C55E; /* green-500, same in dark */
  --color-correct-hover: #16A34A; /* green-600 */

  --color-wrong: #EF4444; /* red-500 */
  --color-wrong-hover: #DC2626; /* red-600 */

  --color-loadingscreen: #111827;             /* gray-900, a bit darker */

--color-loadingscreen-container: #1E293B;   /* slate-800, container base */
--color-loadingscreen-container-selected: #374151; /* gray-700, selected */
--color-loadingscreen-container-border: #4B5563;   /* gray-600 border */
--color-loadingscreen-container-text: #F1F5F9;     /* slate-100, readable text */

}

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: white;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body {
  margin: 0;
  width: 100%;
  height: 100%;
}

@layer utilities {
  .h-safe {
    height: calc(var(--vh, 1vh) * 100);
  }
}
</file>

<file path="src/login/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-background">
      <LoginForm formType="login" />
    </div>
  )
}
</file>

<file path="src/main.tsx">
import { createRoot } from 'react-dom/client'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import { Toaster } from 'sonner'
import 'src/index.css'
import 'src/scrollbar-dark.css'
import VConsole from 'vconsole';
import { mobileConsole } from 'config'
import LocationProvider from 'src/_components/LocationProvider'
import { MenuHandlerProvider } from './_components/MenuHandler'
import TemplateProvider from './_components/TemplateProvider'
import type { Template } from './_components/TemplateProvider';
import { AvatarProvider } from './_components/AvatarProvider'
import { SessionProvider } from './_providers/SessionProvider'
import { TranslationProvider } from './_components/TranslationProvider'
import { SocketStatusProvider } from './_providers/socketStatusProvider'

type PageWithTemplate = React.ComponentType & { template?: Template };
const getRoutes = (pages: Record<string, { default: PageWithTemplate, template?: Template }>) => {
  const routes = [];

  for (const [path, module] of Object.entries(pages)) {
    const pathSegments = path.split('/');
    if (pathSegments.some(segment => segment.startsWith('_'))) continue;

    const routePath = path.replace('./', '').replace('.tsx', '').toLowerCase() || '/';
    const subPath = routePath.endsWith('/page')
      ? routePath.slice(0, -5)
      : routePath.endsWith('page')
      ? '/'
      : false;
    if (!subPath) continue;

    const template = module.template ?? 'plain';
    const Page = module.default;

    routes.push({
      path: subPath,
      element: (
        <LocationProvider>
            <TemplateProvider key={`${template}-${subPath}`} initialTemplate={template}>
              <Page />
            </TemplateProvider>
        </LocationProvider>
      ),
    });
  }

  return routes;
};

//! eslint will tell you that the as Record<string, { default: React.ComponentType }> is not needed but it is for typescript to know what the type of pages is
const pages = import.meta.glob('./**/*.tsx', { eager: true }) as Record<
  string,
  { default: React.ComponentType; template?: Template }
>;
const router = createBrowserRouter([{
  path: '/',
  children: getRoutes(pages)
}])

if (mobileConsole) { new VConsole(); }

const root = document.getElementById("root");
if (root) {
  createRoot(root).render(
    <div className='w-full h-safe m-0 p-0 overflow-hidden'>
      <Toaster richColors />
        <SocketStatusProvider>
          <SessionProvider>
            <TranslationProvider>
              <AvatarProvider>
                <MenuHandlerProvider>
                    <RouterProvider router={router}/>
                </MenuHandlerProvider>
              </AvatarProvider>
            </TranslationProvider>
          </SessionProvider>
        </SocketStatusProvider>
    </div>
  );
}
</file>

<file path="src/page.tsx">
import config from "config";
import { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useSession } from "./_providers/SessionProvider";
const env = import.meta.env;

export const template = 'plain'
export default function App() {
  const navigate = useNavigate();
  const location = useLocation();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
 
    const params = new URLSearchParams(location.search);
    const token = params.get('token');
    if (token && env.VITE_SESSION_BASED_TOKEN == 'true') {
      sessionStorage.setItem('token', token);
      window.location.href = window.location.pathname;
      return;
    }

    if (sessionLoaded) {
      if (session?.id) {
        navigate(config.loginRedirectUrl);
      } else {
        navigate(config.loginPageUrl);
      }
    }

  }, [navigate, location, session, sessionLoaded]);

  useEffect(() => {
    let timeout = setTimeout(() => {
      if (!sessionLoaded) {
        navigate(config.loginPageUrl)
      }
    }, 1000);
    return () => {
      clearTimeout(timeout)
    }
  }, [sessionLoaded])


  return null;
}
</file>

<file path="src/register/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center bg-background">
        <LoginForm formType="register" />
      </div>
    )
}
</file>

<file path="src/scrollbar-dark.css">
/* Global scrollbar styling */

/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background-color: #a3a3a3; /* Medium dark gray */
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background-color: #6b6b6b; /* Lighter gray on hover */
}

::-webkit-scrollbar-button {
    display: none;
}
</file>

<file path="src/scrollbar-white.css">
/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px; /* Customize width */
    height: 8px; /* Customize height for horizontal scrollbars */
}
  
::-webkit-scrollbar-track {
    background: transparent; /* Remove the white background behind the scrollbar */
}
  
::-webkit-scrollbar-thumb {
    background-color: #ffffff; /* Customize thumb color */
    border-radius: 4px; /* Optional: make scrollbar thumb rounded */
    transition: all 0.3s; /* Optional: add hover effect */
    padding: 20px; /* Optional: just make scrollbar thinner */
}
  
::-webkit-scrollbar-thumb:hover {
    background-color: #ffffff; /* Customize thumb color on hover */
}
  
::-webkit-scrollbar-button {
    display: none; /* Remove arrows */
}
</file>

<file path="src/settings/_api/updateUser.ts">
import { PrismaClient } from '@prisma/client';
import { AuthProps, SessionLayout } from 'config';
import path from 'path';
import { GameDataProps } from 'server/functions/game';
import sharp from "sharp";

interface Functions {
  prisma: PrismaClient;

  saveSession: (sessionId: string, data: any) => Promise<boolean>;
  getSession: (sessionId: string) => Promise<any | null>;
  deleteSession: (sessionId: string) => Promise<boolean>;

  saveGameData: (gameCode: string, data: GameDataProps) => Promise<boolean>;
  getGameData: (gameCode: string) => Promise<GameDataProps | null>;
  deleteGameData: (gameCode: string) => Promise<boolean>;
  gameExists: (gameCode: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;

  [key: string]: any; // allows for other functions that are not defined as a type but do exist in the functions folder
};

interface ApiParams {
  data: Record<string, any>;
  functions: Functions;
  user: SessionLayout;
};


const auth: AuthProps = {
  login: true, //? checks if the session data has an id. 
  additional: [
  ]
}

// const __filename = fileURLToPath(import.meta.url);
// const __dirname = path.dirname(__filename);
const main = async ({ data, functions, user }: ApiParams) => {

  const { avatar, name, theme, language } = data;

  if (avatar) {
    console.log(avatar)
    const matches = avatar.match(/^data:(.+);base64,(.+)$/);
    if (matches) {
      const base64Data = matches[2];
      const buffer = Buffer.from(base64Data, "base64");

      // save as WebP under user's ID
      const fileName = `${user.id}.webp`;
      const filePath = path.join(process.cwd(), "uploads", fileName);

      try {
        await sharp(buffer)
          .webp({ quality: 80 }) // adjust quality if you want
          .toFile(filePath);

        console.log(`✅ Avatar saved for ${user.name} at ${filePath}`);
      } catch (err) {
        console.error("Error saving avatar:", err);
        return { status: "error" };
      }
    } else { console.log("failed to upload new avatar") }
  }

  let newData = {};

  if (avatar) newData = { ...newData, avatar: `${user.id}` }
  if (name) newData = { ...newData, name }
  if (theme) newData = { ...newData, theme }
  if (language) newData = { ...newData, language }

  //? here we can assume the avatar was uploaded successfully if avatar !=  null

  console.log(user)
  if (!user.token) return { status:'error' }

  await functions.prisma.user.update({
    where: { id: user.id },
    data: newData
  })

  await functions.saveSession(user.token, {...user, ...newData});

  return { status: 'success' }
}

export { auth, main }
</file>

<file path="src/settings/page.tsx">
import { useCallback, useEffect, useState } from "react";
import notify from "src/_functions/notify";
import ThemeToggler from "src/_components/ThemeToggler";
import { backendUrl } from "../../config";
import { useUpdateLanguage } from "src/_components/TranslationProvider";
import Avatar from "src/_components/Avatar";
import { useTranslator } from "src/_functions/translator";
import { apiRequest, apiRequestReponse } from "src/_sockets/apiRequest";
import { useSession } from "src/_providers/SessionProvider";

const incrementAvatarVersion = (url: string) => {
  const match = url.match(/[?&]v=(\d+)/);
  return match ? parseInt(match[1]) + 1 : 1;
}

export const template = 'home';
export default function Home() {

  const { session } = useSession();
  const { updateTheme } = ThemeToggler();
  const setLanguage = useUpdateLanguage();
  const translate = useTranslator();

  const [newLanguage, setNewLanguage] = useState<'nl' | 'en' | 'de' | 'fr'>(session?.language as 'nl' | 'en' |'de' | 'fr' || '');
  const [newAvatar, setNewAvatar] = useState<string>(session?.avatar || '');
  const [newName, setNewName] = useState<string>(session?.name || '');
  const [newTheme, setNewTheme] = useState<'light' | 'dark'>(session?.theme || 'dark');

  if (!session) return null;

  let url;

  if (newAvatar.includes('base64')) {
    url = new URL(newAvatar, window.location.origin);
    url.search = ""; // remove query params
  }

  const displayUrl = newAvatar.includes('base64') 
    ? url?.toString() 
    : newAvatar.startsWith("http")
    ? newAvatar
    : `${backendUrl}/uploads/${session.avatar}`
  console.log(displayUrl)

  const saveUser = useCallback(async () => {
    if (
      newLanguage == session.language
      && newAvatar == session.avatar
      && newName == session.name
      && newTheme == session.theme
    ) {
      notify.info({ key: 'settings.noChangesMade' })
      return;
    }
    const response = await apiRequest({
      name: 'updateUser',
      data: {
        language: newLanguage != session.language? newLanguage : undefined,
        avatar: newAvatar != session.avatar? newAvatar : undefined,
        name: newName != session.name? newName : undefined,
        theme: newTheme != session.theme? newTheme : undefined,
      },
    }) as apiRequestReponse
    if (response.status === 'success') {
      notify.success({ key: 'settings.updatedUser' })
    } else {
      notify.error({ key: 'settings.failedUpdateUser' })
    }
  }, [newLanguage, newAvatar, newName, newTheme, session]);


  //? we trigger saveUser when the newAvatar changes so that the avatar is saved immidiatly, we dont call the saveUser in the onchange callback cause than it causes a race codition between the function calling and newAvatar having the new value
  useEffect(() => {
    if (!newAvatar) return;
    
    saveUser();
  }, [newAvatar])

  return (
    <div className='flex items-center justify-center w-full h-full bg-background'>
      <div className="bg-container border-2 border-container-border flex flex-col p-8 gap-4 rounded-2xl max-w-[360px] w-[90%]">

        <div className="flex gap-4 items-center">
          { newAvatar || session.avatar ? (
            <img src={displayUrl} 
              className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none"></img>
          ) : (
            <div className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none">
              <Avatar
                user={{
                  name: session.name,
                  avatarFallback: session.avatarFallback
                }}
                textSize="text-4xl"
              />
            </div>
          )}
          <div className="space-y-2">
            <input type="file" className="hidden"></input>
            <button
              className="w-full py-1 bg-container2 border-container2-border border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                const input = document.querySelector('input[type="file"]') as HTMLInputElement;
                input.click();
                input.onchange = async () => {
                  const file = input.files?.[0];
                  if (!file) return;
                  const maxSize = 4 * 1024 * 1024; // 4 MB
                  if (file.size > maxSize) {
                    notify.error({ key:'settings.sizeToLarge' })
                    return;
                  }

                  notify.info({ key: 'settings.loadingImg' })
                  const reader = new FileReader();
                  reader.onload = async () => {
                    setNewAvatar(prevUrl => `${reader.result}?v=${incrementAvatarVersion(prevUrl||"")}`)
                    notify.success({ key: 'settings.imgLoaded' })
                  };
                  reader.readAsDataURL(file);
                }
              }}
            >
              {/* Change avatar */}
              {translate({ key: 'settings.changeAvatar' })}
            </button>
            {/* <button 
              className="w-full py-1 bg-wrong/50 border-wrong border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                ref.open(
                  <ConfirmMenu
                    title={(translate({ key: 'settings.changeAvatar' }))}
                    content={'asd'}
                    resolve={(success) => {
                      console.log(success)
                    }}
                  />
                )
              }}
            >
              {translate({ key: 'settings.deleteAvatar' })}
            </button> */}
            <div className="text-muted text-sm">
              {/* JPG, GIV or PNG. 1MB max. */}
              {translate({ key:'settings.changeAvatarDescription' })}
            </div>
          </div>
        </div>

        <div className="space-y-2 w-full">
          <div className="text-lg font-semibold">Name</div>
          <input 
            className={`w-full bg-container2 border-container2-border border-2 focus:outline-0 focus:border-container3-border transition-all duration-150 p-2 rounded-md`}
            value={newName}
            onChange={(e) => { setNewName(e.target.value) }}
          ></input>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Language */}
            {translate({ key:'settings.language.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => { 
                setNewLanguage('nl');
                setLanguage('nl');
               }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'nl' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* NL */}
              {translate({ key:'settings.language.nl' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('en'); 
                setLanguage('en');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'en' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* EN */}
              {translate({ key:'settings.language.en' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('de'); 
                setLanguage('de');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'de' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* DE */}
              {translate({ key:'settings.language.de' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('fr'); 
                setLanguage('fr');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'fr' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* FR */}
              {translate({ key:'settings.language.fr' })}
            </button>
          </div>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Theme */}
            {translate({ key:'settings.theme.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => { 
                setNewTheme('light');
                updateTheme('light'); 
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme == 'light' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Light mode */}
              {translate({ key:'settings.theme.light' })}
            </button>
            <button
              onClick={() => { 
                setNewTheme('dark');
                updateTheme('dark'); 
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme == 'dark' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Dark mode */}
              {translate({ key:'settings.theme.dark' })}
            </button>
          </div>
        </div>

        <button 
          className="w-full bg-blue-500 text-white py-2 rounded-lg"
          onClick={saveUser}
        >
          {/* Save data */}
          {translate({ key:'settings.saveChanges' })}
        </button>

      </div>
    </div>
  )
}
</file>

<file path="src/test/_sync/updateCounter_client.ts">
import { ClientSyncProps } from "config";

const main = ({ user }: ClientSyncProps) => {
  //? here you can do certain checks for each user and determine if they should get the event or not
  //? e.g. user.admin == true or user.location.pathName == '/test'
  console.log(user)
  if (user?.location?.pathName == '/test') {
    return {
      status: 'success',
    };
  }
}

export { main }
</file>

<file path="src/test/_sync/updateCounter_server.ts">
import { AuthProps, ServerSyncProps } from "config";

const auth: AuthProps = {
  login: true,
  additional: []
}

const main = async ({ clientData }: ServerSyncProps) => {

  console.log(clientData);
  // here you can maybe update a counter in your server memory with redis or update your database cause this file only runs once

  return {
    status: 'success',
    increase: clientData.increase
  }
}

export { main, auth };
</file>

<file path="src/test/page.tsx">
import { joinRoom } from "src/_sockets/socketInitializer";
import { useEffect } from 'react';
import notify from "src/_functions/notify";
import { setMenuHandlerRef } from "src/_functions/menuHandler";
import { syncRequest, useSyncEvents } from "src/_sockets/syncRequest";
import { apiRequest } from "src/_sockets/apiRequest";
import { useSession } from "src/_providers/SessionProvider";
import { useMenuHandler } from "src/_components/MenuHandler";
import { confirmDialog } from "src/_components/ConfirmMenu";

export const template = 'home';
export default function Home() {
  const { session } = useSession();

  useEffect(() => {
    joinRoom('test');
  }, [])

  const ref = useMenuHandler();
  setMenuHandlerRef(ref);

  const { upsertSyncEventCallback } = useSyncEvents();

  upsertSyncEventCallback('updateCounter', ({ serverData }) => {
    const counter = document.getElementById('counter');
    if (!counter) { return; }
    const count = parseInt(counter.innerText);
    counter.innerText = (serverData.increase ? count + 1 : count - 1).toString();
  })

  return (
    <div className="h-full flex flex-grow flex-col items-center justify-center gap-4">
      <button className="px-6 rounded-md cursor-pointer h-10 bg-pink-500 text-white" 
        onClick={() => { void syncRequest({ name: 'updateCounter', data: { product: 'shoes', increase: true }, receiver: 'test' }) }}>
        click me to increase shoes counter over all clients <strong>(sync request)!!</strong>
      </button>
      <button className="px-6 rounded-md cursor-pointer h-10 bg-pink-500 text-white" 
        onClick={() => { void syncRequest({ name: 'updateCounter', data: { product: 'shoes', increase: false }, receiver: 'test' }) }}>
        click me to decrease shoes counter over all clients <strong>(sync request)!!</strong>
      </button>
      <div className="shoesCounter bg-pink-500 p-2 rounded-md text-white">
        shoes: <strong id="counter">0</strong>
      </div>
      <button className="min-w-40 px-6  rounded-md cursor-pointer h-10 bg-green-500 text-white"
        onClick={() => { void apiRequest({ name: 'testApi' })}}>
          click me to call an testApi <strong>(check client and server console)</strong>
      </button>
      <button className="min-w-40 px-6 rounded-md cursor-pointer h-10 bg-orange-500 text-white"
        onClick={() => { void apiRequest({ name: 'logout' }) }}>
          logout
      </button>
      <button className="bg-purple-500 text-white rounded-md p-2 cursor-pointer"
        onClick={() => { notify.success({ key: 'test', params: [{ key: 'name', value: session?.name || 'loading' }] }) }}>
        Click me for a notification!!
      </button>
      <button 
        className="min-w-40 px-6 rounded-md cursor-pointer h-10 bg-blue-500 text-white"
        onClick={() => {
          ref.open(
            <div className="p-4 gap-4 flex flex-col">

              <h2>Menu</h2>
              <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                onClick={() => { ref.close() }}
              >close</button>
              <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                onClick={() => { ref.open(
                  <div className="p-4 gap-4 flex flex-col">
                    <h2>Menu 2</h2>
                    <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                      onClick={() => { ref.close() }}
                    >close</button>
                    <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                      onClick={async () => {
                        const result = await confirmDialog({
                          title: 'test',
                          content: <p>test <strong>test2</strong></p>,
                          input: 'test'
                        })
                        console.log(`Confirm Dialog returned: ${result}`);
                      }}
                    >
                      open
                    </button>
                  </div>, { dimBackground: true, background: 'bg-orange-200', size:'sm'  }
                )}}
              >
                open
              </button>
            </div>, { dimBackground: true, background: 'bg-white', size: 'md' }
          )
        }}
      >
        click me to open external menu
      </button>
    </div>
  );
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
// tailwind.config.js
module.exports = {
  darkMode: "class",
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {}
    },
  },
  plugins: [require("@tailwindcss/container-queries")],
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,
    
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "./",
    "paths": {
      "src/*": ["src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "exclude": [ // this excludes files from being build
    "src/**/api",                    // exclude any api folder
    "src/**/sync/*_server.ts",       // only exclude server_*.ts files inside sync folders
    "src/**/sync/*_server.tsx",      // (optional) if you use TSX files too
    "src/**/sync/*_server.js",       // (optional) in case you have JS mixed in
    "src/**/sync/*_server.jsx",       // (optional) same for JSX
  ]

}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="tsconfig.server.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "lib": ["ES2022"],
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "rewriteRelativeImportExtensions": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist/server",
    "resolveJsonModule": true,
    "types": ["node"],
    "sourceMap": true
  },
  "include": ["server/**/*"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path';
// import tsconfigPaths from 'vite-tsconfig-paths'

// https://vite.dev/config/
export default defineConfig({
  base: '/',
  plugins: [
    react(),
    // tsconfigPaths()
  ],
  build: {
    rollupOptions: {
      external: (id) => { // this is just for the server side to tell these files will be available at runtime, to ignore files in build process go to tsconfig.app.json
        // Match if path includes /api/
        if (/\/api\//.test(id)) return true;
  
        // Ignore files in a sync folder ending with _server.ts
        if (/\/sync\/.*\/.*_server\.ts$/.test(id) || /\/sync\/.*_server\.ts$/.test(id)) return true;

        return false;
      },
    },
    target: 'esnext', // This makes sure the server redirects all 404s to index.html
  },
  resolve: {
    alias: {
      'src': path.resolve(__dirname, './src'),
      'config': path.resolve(__dirname, './config'),
    },
  },
  server: {
    watch: {
      usePolling: true,
      ignored: [
        "**/src/**/**/*{api,sync}/**"
      ]
    },
  }
})
</file>

<file path="server/utils/serveAvatars.ts">
import path from "path";
import { access } from 'fs/promises';
import fs from "fs";
import { ServerResponse } from "http";

export const serveAvatar = async ({ 
  routePath,
  res,
}: {
  routePath: string;
  res: ServerResponse;
}) => {
  const uploadsFolder = path.join(process.cwd(), "uploads");
      
  // Always append .webp since that's the stored format
  const fileId = path.basename(routePath, path.extname(routePath)); // remove any extension if present
  const fileName = `${fileId}.webp`;
  const filePath = path.join(uploadsFolder, fileName);

  if (!fileId) return;

  try {
    await access(filePath)

    res.writeHead(200, {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=86400",
    });

    const readStream = fs.createReadStream(filePath);
    readStream.pipe(res);
  } catch (err) {
    // console.log('File not found:', err, 'red');
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("File not found");
  };

  return;
}
</file>

<file path="src/test/_api/testApi.ts">
import { PrismaClient } from '@prisma/client';
import { AuthProps, SessionLayout } from 'config';

interface Functions {
  prisma: PrismaClient;

  saveSession: (sessionId: string, data: any) => Promise<boolean>;
  getSession: (sessionId: string) => Promise<any | null>;
  deleteSession: (sessionId: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;

  [key: string]: any; // allows for other functions that are not defined as a type but do exist in the functions folder
};

interface ApiParams {
  data: Record<string, any>;
  functions: Functions;
  user: SessionLayout;
};


const auth: AuthProps = {
  login: true, //? checks if the session data has an id. 
  additional: [
    // { key: 'groupId', mustBeFalsy: false }, //? checks if the groupId is truethy, so if groupId is an empty string or 0 it will not pass
    // { key: 'admin', value: true }, //? checks if admin = true
    // { key: 'email', type: 'string' }, //? checks if the email is a string
    // { key: 'updatedAt', nullish: false } //? checks if the updatedAt is not null or undefined 
    //? you can perform certain checks with more than 1 condition but in the end they all have there own use case.
  ]
}

const main = async ({ data, functions, user }: ApiParams) => {
  console.log(data)
  console.log(user)
  console.log('you just called the randomApi.ts')
  return { status: 'success', result: { name: 'John' } }
}

export { auth, main }
</file>

</files>
