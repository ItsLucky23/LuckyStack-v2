Future Work (Not in This Plan)

split the framework up into different npm packages, this requires us to analyze the complete codebase and replace any hardcoded value with configurable values and make more things optional / split them from existing code so that the user never has to change anything in the npm packages and can change them in other files we tell the user to add into there primary folder.
add a logging tool
add a metrics tool
add a tracing tool
NPM package modularization - Split into @luckystack/*
Session storage abstraction - Support PostgreSQL/JWT
Location Provider - Optional feature just like socket broadcaster




Places to replace with TS API isntead of the regex bullshit

High priority:
extractors.ts
Replace regex-based parsing of ApiParams, SyncParams, return types, unions/generics.
typeContext.ts
Replace regex import/export parsing with AST import/export nodes.
functionsMeta.ts
Replace signature inference regex with function/type nodes.
Medium priority:
apiMeta.ts
auth, httpMethod, rateLimit extraction via AST constants.
templateInjector.ts
Safer “find/replace” using AST + printer for typed sections.
Low priority / keep as-is:
discovery.ts (filesystem scanning is fine)
hotReload.ts (watch logic itself is fine)
Complexity impact

Code complexity: higher at first (AST traversal + node kind handling).
Maintenance complexity: lower long-term (far fewer parser edge-case bugs).
Reliability: much higher for nested types, aliases, conditional/mapped/generic types.
Speed impact

If you use only ts.createSourceFile (no type checker): usually small overhead, still fast.
If you use full Program + TypeChecker: slower cold start, but much better correctness.
With caching/incremental strategy, runtime stays practical:
Parse changed files only.
Rebuild/check only affected dependency graph.
Keep a long-lived Program in dev mode when possible.
Practical recommendation

Phase 1: AST-only parser (no checker) for imports/params/returns.
Phase 2: add TypeChecker only for unresolved aliases/cross-file complex types.
Phase 3: remove regex fallbacks once coverage is stable.
